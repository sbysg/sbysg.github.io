<!-- build time: Sat Nov 04 2023 21:46:07 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta http-equiv="X-UA-COMPATIBLE" content="IE=edge,chrome=1"><meta name="renderer" content="webkit"><link rel="icon" type="image/ico" sizes="32x32" href="/assets/favicon.ico"><link rel="apple-touch-icon" sizes="180x180" href="/assets/apple-touch-icon.png"><meta name="msvalidate.01" content="1234"><link rel="alternate" href="/rss.xml" title="夢のない賢魚です" type="application/rss+xml"><link rel="alternate" href="/atom.xml" title="夢のない賢魚です" type="application/atom+xml"><link rel="alternate" type="application/json" title="夢のない賢魚です" href="https://sbysg.github.io/feed.json"><link rel="preconnect" href="https://lf9-cdn-tos.bytecdntp.com"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://unpkg.com"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.3.6"><script src="https://cdn.staticfile.org/vue/3.2.45/vue.global.prod.js"></script><link rel="stylesheet" href="https://unpkg.com/@waline/client@v2/dist/waline.css"><meta name="keywords" content="Redis"><link rel="canonical" href="https://sbysg.github.io/2023/10/22/database/no-sql/redis/Java%E9%9D%A2%E8%AF%95%E9%A2%98-07-Redis/"><title>redis</title><meta name="generator" content="Hexo 6.3.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">redis</h1><div class="meta"><span class="item" title="创建时间：2023-10-22 00:09:40"><span class="icon"><i class="ic i-calendar"></i></span><span class="text">发表于</span><time itemprop="dateCreated datePublished" datetime="2023-10-22T00:09:40+08:00">2023-10-22</time></span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i></span><span class="text">本文字数</span><span>36k</span><span class="text">字</span></span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i></span><span class="text">阅读时长</span><span>32 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span><span class="line"></span><span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Ya Hallo</a></li></ul><ul class="right" id="rightNav"><li class="item theme" @click="changeThemeByBtn"><i class="ic" :class="{'i-sun': !themeStatus,'i-moon': themeStatus}"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div class="pjax" id="imgs"><ul><li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1giciszlczyj20zk0m816d.jpg"></li><li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1gicm0fdw5cj20zk0m8hdt.jpg"></li><li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1giclh0m9pdj20zk0m8hdt.jpg"></li><li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1gipeyhsblkj20zk0m81kx.jpg"></li><li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1giclgrvbd6j20zk0m8qv5.jpg"></li><li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1gipey0a334j20zk0m8qpt.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"></path></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"></use><use xlink:href="#gentle-wave" x="48" y="3"></use><use xlink:href="#gentle-wave" x="48" y="5"></use><use xlink:href="#gentle-wave" x="48" y="7"></use></g></svg></div><main><div class="inner"><div class="pjax" id="main"><div class="article wrap"><div class="breadcrumb" itemlistelement itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i><span><a href="/">首页</a></span><i class="ic i-angle-right"></i><span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/database/" itemprop="item" rel="index" title="分类于数据库"><span itemprop="name">数据库<meta itemprop="position" content="0"></span></a></span></div><article class="post block" itemscope itemtype="http://schema.org/Article" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://sbysg.github.io/2023/10/22/database/no-sql/redis/Java%E9%9D%A2%E8%AF%95%E9%A2%98-07-Redis/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/assets/avatar.jpg"><meta itemprop="name" content="biya"><meta itemprop="description" content="biya, 摸鱼之道，就在其中"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="夢のない賢魚です"></span><div class="body md" itemprop="articleBody"><div class="tabs" id="summary"><div class="show-btn"></div><div class="nav"><ul class="special"></ul></div><div class="tab" data-id="summary" data-title="自我介绍"><p>我是基于ChatGPT-turbo-3.5实现的AI助手，在此网站上负责整理和概括文章</p></div><div class="tab active" data-id="summary" data-title="文章概括"><p></p></div></div><h1 id="java面试题-redis"><a class="anchor" href="#java面试题-redis">#</a> Java 面试题 - Redis</h1><h2 id="redis"><a class="anchor" href="#redis">#</a> Redis</h2><h3 id="1-redis是什么简述它的优缺点"><a class="anchor" href="#1-redis是什么简述它的优缺点">#</a> 1. Redis 是什么？简述它的优缺点？</h3><p>Redis 本质上是一个 Key-Value 类型的内存数据库，很像 Memcached，整个数据库加载在内存当中操作，定期通过异步操作把数据库中的数据 flush 到硬盘上进行保存。</p><p>因为是纯内存操作，Redis 的性能非常出色，每秒可以处理超过 10 万次读写操作，是已知性能最快的 Key-Value 数据库。</p><p><strong>优点</strong>：</p><ul><li>读写性能极高， Redis 能读的速度是 110000 次 /s，写的速度是 81000 次 /s。</li><li>支持数据持久化，支持 AOF 和 RDB 两种持久化方式。</li><li>支持事务， Redis 的所有操作都是原子性的，意思就是要么成功执行要么失败完全不执行。单个操作是原子性的。多个操作也支持事务，即原子性，通过 MULTI 和 EXEC 指令包起来。</li><li>数据结构丰富，除了支持 string 类型的 value 外，还支持 hash、set、zset、list 等数据结构。</li><li>支持主从复制，主机会自动将数据同步到从机，可以进行读写分离。</li><li>丰富的特性 – Redis 还支持 publish/subscribe， 通知， key 过期等特性。</li></ul><p><strong>缺点</strong>：</p><ul><li>数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此 Redis 适合的场景主要局限在较小数据量的高性能操作和运算上。</li><li>主机宕机，宕机前有部分数据未能及时同步到从机，切换 IP 后还会引入数据不一致的问题，降低了系统的可用性。</li></ul><h3 id="2-redis为什么这么快"><a class="anchor" href="#2-redis为什么这么快">#</a> 2. Redis 为什么这么快？</h3><ul><li><p>内存存储：Redis 是使用内存 (in-memeroy) 存储，没有磁盘 IO 上的开销。数据存在内存中，类似于 HashMap，HashMap 的优势就是查找和操作的时间复杂度都是 O (1)。</p></li><li><p>单线程实现（ Redis 6.0 以前）：Redis 使用单个线程处理请求，避免了多个线程之间线程切换和锁资源争用的开销。注意：单线程是指的是在核心网络模型中，网络请求模块使用一个线程来处理，即一个线程处理所有网络请求。</p></li><li><p>非阻塞 IO：Redis 使用多路复用 IO 技术，将 epoll 作为 I/O 多路复用技术的实现，再加上 Redis 自身的事件处理模型将 epoll 中的连接、读写、关闭都转换为事件，不在网络 I/O 上浪费过多的时间。</p></li><li><p>优化的数据结构：Redis 有诸多可以直接应用的优化数据结构的实现，应用层可以直接使用原生的数据结构提升性能。</p></li><li><p>使用底层模型不同：Redis 直接自己构建了 VM (虚拟内存) 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。</p><blockquote><p>Redis 的 VM (虚拟内存) 机制就是暂时把不经常访问的数据 (冷数据) 从内存交换到磁盘中，从而腾出宝贵的内存空间用于其它需要访问的数据 (热数据)。通过 VM 功能可以实现冷热数据分离，使热数据仍在内存中、冷数据保存到磁盘。这样就可以避免因为内存不足而造成访问速度下降的问题。</p><p>Redis 提高数据库容量的办法有两种：一种是可以将数据分割到多个 RedisServer 上；另一种是使用虚拟内存把那些不经常访问的数据交换到磁盘上。<strong>需要特别注意的是 Redis 并没有使用 OS 提供的 Swap，而是自己实现。</strong></p></blockquote></li></ul><h3 id="3-redis相比memcached有哪些优势"><a class="anchor" href="#3-redis相比memcached有哪些优势">#</a> 3. Redis 相比 Memcached 有哪些优势？</h3><ul><li><p>数据类型：Memcached 所有的值均是简单的字符串，Redis 支持更为丰富的数据类型，支持 string (字符串)，list (列表)，Set (集合)、Sorted Set (有序集合)、Hash (哈希) 等。</p></li><li><p>持久化：Redis 支持数据落地持久化存储，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。 memcache 不支持数据持久存储 。</p></li><li><p>集群模式：Redis 提供主从同步机制，以及 Cluster 集群部署能力，能够提供高可用服务。Memcached 没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据</p></li><li><p>性能对比：Redis 的速度比 Memcached 快很多。</p></li><li><p>网络 IO 模型：Redis 使用单线程的多路 IO 复用模型，Memcached 使用多线程的非阻塞 IO 模式。</p></li><li><p>Redis 支持服务器端的数据操作：Redis 相比 Memcached 来说，拥有更多的数据结构和并支持更丰富的数据操作，通常在 Memcached 里，你需要将数据拿到客户端来进行类似的修改再 set 回去。</p><p>这大大增加了网络 IO 的次数和数据体积。在 Redis 中，这些复杂的操作通常和一般的 GET/SET 一样高效。所以，如果需要缓存能够支持更复杂的结构和操作，那么 Redis 会是不错的选择。</p></li></ul><h3 id="4-为什么要用-redis-做缓存"><a class="anchor" href="#4-为什么要用-redis-做缓存">#</a> 4. 为什么要用 Redis 做缓存？</h3><p><strong>从高并发上来说：</strong></p><ul><li>直接操作缓存能够承受的请求是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。</li></ul><p><strong>从高性能上来说：</strong></p><ul><li>用户第一次访问数据库中的某些数据。 因为是从硬盘上读取的所以这个过程会比较慢。将该用户访问的数据存在缓存中，下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。如果数据库中的对应数据改变的之后，同步改变缓存中相应的数据。</li></ul><h3 id="5-为什么要用-redis-而不用-mapguava-做缓存"><a class="anchor" href="#5-为什么要用-redis-而不用-mapguava-做缓存">#</a> 5. 为什么要用 Redis 而不用 map/guava 做缓存？</h3><p>缓存分为本地缓存和分布式缓存。以 java 为例，使用自带的 map 或者 guava 实现的是本地缓存，最主要的特点是轻量以及快速，生命周期随着 jvm 的销毁而结束，并且在多实例的情况下，每个实例都需要各自保存一份缓存，缓存不具有一致性。</p><p>使用 Redis 或 memcached 之类的称为分布式缓存，在多实例的情况下，各实例共用一份缓存数据，缓存具有一致性。缺点是需要保持 Redis 或 memcached 服务的高可用，整个程序架构上较为复杂。</p><p>对比:</p><ul><li>Redis 可以用几十 G 内存来做缓存，Map 不行，一般 JVM 也就分几个 G 数据就够大了；</li><li>Redis 的缓存可以持久化，Map 是内存对象，程序一重启数据就没了；</li><li>Redis 可以实现分布式的缓存，Map 只能存在创建它的程序里；</li><li>Redis 可以处理每秒百万级的并发，是专业的缓存服务，Map 只是一个普通的对象；</li><li>Redis 缓存有过期机制，Map 本身无此功能；Redis 有丰富的 API，Map 就简单太多了；</li><li>Redis 可单独部署，多个项目之间可以共享，本地内存无法共享；</li><li>Redis 有专门的管理工具可以查看缓存数据。</li></ul><h3 id="6-redis的常用场景有哪些"><a class="anchor" href="#6-redis的常用场景有哪些">#</a> 6. Redis 的常用场景有哪些？</h3><p><strong>1、缓存</strong></p><p>缓存现在几乎是所有中大型网站都在用的必杀技，合理的利用缓存不仅能够提升网站访问速度，还能大大降低数据库的压力。Redis 提供了键过期功能，也提供了灵活的键淘汰策略，所以，现在 Redis 用在缓存的场合非常多。</p><p><strong>2、排行榜</strong></p><p>很多网站都有排行榜应用的，如京东的月度销量榜单、商品按时间的上新排行榜等。Redis 提供的有序集合数据类构能实现各种复杂的排行榜应用。</p><p><strong>3、计数器</strong></p><p>什么是计数器，如电商网站商品的浏览量、视频网站视频的播放数等。为了保证数据实时效，每次浏览都得给 + 1，并发量高时如果每次都请求数据库操作无疑是种挑战和压力。Redis 提供的 incr 命令来实现计数器功能，内存操作，性能非常好，非常适用于这些计数场景。</p><p><strong>4、分布式会话</strong></p><p>集群模式下，在应用不多的情况下一般使用容器自带的 session 复制功能就能满足，当应用增多相对复杂的系统中，一般都会搭建以 Redis 等内存数据库为中心的 session 服务，session 不再由容器管理，而是由 session 服务及内存数据库管理。</p><p><strong>5、分布式锁</strong></p><p>在很多互联网公司中都使用了分布式技术，分布式技术带来的技术挑战是对同一个资源的并发访问，如全局 ID、减库存、秒杀等场景，并发量不大的场景可以使用数据库的悲观锁、乐观锁来实现，但在并发量高的场合中，利用数据库锁来控制资源的并发访问是不太理想的，大大影响了数据库的性能。可以利用 Redis 的 setnx 功能来编写分布式的锁，如果设置返回 1 说明获取锁成功，否则获取锁失败，实际应用中要考虑的细节要更多。</p><p><strong>6、 社交网络</strong></p><p>点赞、踩、关注 / 被关注、共同好友等是社交网站的基本功能，社交网站的访问量通常来说比较大，而且传统的关系数据库类型不适合存储这种类型的数据，Redis 提供的哈希、集合等数据结构能很方便的的实现这些功能。如在微博中的共同好友，通过 Redis 的 set 能够很方便得出。</p><p><strong>7、最新列表</strong></p><p>Redis 列表结构，LPUSH 可以在列表头部插入一个内容 ID 作为关键字，LTRIM 可用来限制列表的数量，这样列表永远为 N 个 ID，无需查询最新的列表，直接根据 ID 去到对应的内容页即可。</p><p><strong>8、消息系统</strong></p><p>消息队列是大型网站必用中间件，如 ActiveMQ、RabbitMQ、Kafka 等流行的消息队列中间件，主要用于业务解耦、流量削峰及异步处理实时性低的业务。Redis 提供了发布 / 订阅及阻塞队列功能，能实现一个简单的消息队列系统。另外，这个不能和专业的消息中间件相比。</p><h3 id="7-redis的数据类型有哪些"><a class="anchor" href="#7-redis的数据类型有哪些">#</a> 7. Redis 的数据类型有哪些？</h3><p>有五种常用数据类型：String、Hash、Set、List、SortedSet。以及三种特殊的数据类型：Bitmap、HyperLogLog、Geospatial ，其中 HyperLogLog、Bitmap 的底层都是 String 数据类型，Geospatial 的底层是 Sorted Set 数据类型。</p><p><strong>五种常用的数据类型</strong>：</p><p>1、String：String 是最常用的一种数据类型，普通的 key- value 存储都可以归为此类。其中 Value 既可以是数字也可以是字符串。使用场景：常规 key-value 缓存应用。常规计数：微博数， 粉丝数。</p><p>2、Hash：Hash 是一个键值 (key =&gt; value) 对集合。Redishash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象，并且可以像数据库中 update 一个属性一样只修改某一项属性值。</p><p>3、Set：Set 是一个无序的天然去重的集合，即 Key-Set。此外还提供了交集、并集等一系列直接操作集合的方法，对于求共同好友、共同关注什么的功能实现特别方便。</p><p>4、List：List 是一个有序可重复的集合，其遵循 FIFO 的原则，底层是依赖双向链表实现的，因此支持正向、反向双重查找。通过 List，我们可以很方面的获得类似于最新回复这类的功能实现。</p><p>5、SortedSet：类似于 java 中的 TreeSet，是 Set 的可排序版。此外还支持优先级排序，维护了一个 score 的参数来实现。适用于排行榜和带权重的消息队列等场景。</p><p><strong>三种特殊的数据类型</strong>：</p><p>1、Bitmap：位图，Bitmap 想象成一个以位为单位数组，数组中的每个单元只能存 0 或者 1，数组的下标在 Bitmap 中叫做偏移量。使用 Bitmap 实现统计功能，更省空间。如果只需要统计数据的二值状态，例如商品有没有、用户在不在等，就可以使用 Bitmap，因为它只用一个 bit 位就能表示 0 或 1。</p><p>2、Hyperloglog。HyperLogLog 是一种用于统计基数的数据集合类型，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大</p><p>时，计算基数所需的空间总是固定 的、并且是很小的。每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基 数。场景：统计网页的 UV（即 Unique Visitor，不重复访客，一个人访问某个网站多次，但是还是只计算为一次）。</p><p>要注意，HyperLogLog 的统计规则是基于概率完成的，所以它给出的统计结果是有一定误差的，标准误算率是 0.81%。</p><p>3、Geospatial ：主要用于存储地理位置信息，并对存储的信息进行操作，适用场景如朋友的定位、附近的人、打车距离计算等。</p><h2 id="持久化"><a class="anchor" href="#持久化">#</a> 持久化</h2><h3 id="1-redis持久化机制"><a class="anchor" href="#1-redis持久化机制">#</a> 1. Redis 持久化机制？</h3><p>为了能够重用 Redis 数据，或者防止系统故障，我们需要将 Redis 中的数据写入到磁盘空间中，即持久化。</p><p>Redis 提供了两种不同的持久化方法可以将数据存储在磁盘中，一种叫快照 <code>RDB</code> ，另一种叫只追加文件 <code>AOF</code> 。</p><p><strong>RDB</strong></p><p>在指定的时间间隔内将内存中的数据集快照写入磁盘 ( <code>Snapshot</code> )，它恢复时是将快照文件直接读到内存里。</p><p><strong>优势</strong>：适合大规模的数据恢复；对数据完整性和一致性要求不高</p><p><strong>劣势</strong>：在一定间隔时间做一次备份，所以如果 Redis 意外 <code>down</code> 掉的话，就会丢失最后一次快照后的所有修改。</p><p><strong>AOF</strong></p><p>以日志的形式来记录每个写操作，将 Redis 执行过的所有写指令记录下来 (读操作不记录)，只许追加文件但不可以改写文件，Redis 启动之初会读取该文件重新构建数据，换言之，Redis 重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。</p><p>AOF 采用文件追加方式，文件会越来越大，为避免出现此种情况，新增了重写机制，当 AOF 文件的大小超过所设定的阈值时， Redis 就会启动 AOF 文件的内容压缩，只保留可以恢复数据的最小指令集.。</p><p><strong>优势</strong></p><ul><li>每修改同步： <code>appendfsync always</code> 同步持久化，每次发生数据变更会被立即记录到磁盘，性能较差但数据完整性比较好</li><li>每秒同步： <code>appendfsync everysec</code> 异步操作，每秒记录，如果一秒内宕机，有数据丢失</li><li>不同步： <code>appendfsync no</code> 从不同步</li></ul><p><strong>劣势</strong></p><ul><li>相同数据集的数据而言 <code>aof</code> 文件要远大于 <code>rdb</code> 文件，恢复速度慢于 <code>rdb</code></li><li><code>aof</code> 运行效率要慢于 <code>rdb</code> ，每秒同步策略效率较好，不同步效率和 <code>rdb</code> 相同</li></ul><h3 id="2-如何选择合适的持久化方式"><a class="anchor" href="#2-如何选择合适的持久化方式">#</a> 2. 如何选择合适的持久化方式</h3><ul><li>如果是数据不那么敏感，且可以从其他地方重新生成补回的，那么可以关闭持久化。</li><li>如果是数据比较重要，不想再从其他地方获取，且可以承受数分钟的数据丢失，比如缓存等，那么可以只使用 RDB。</li><li>如果是用做内存数据库，要使用 Redis 的持久化，建议是 RDB 和 AOF 都开启，或者定期执行 bgsave 做快照备份，RDB 方式更适合做数据的备份，AOF 可以保证数据的不丢失。</li></ul><p><strong>补充：Redis4.0 对于持久化机制的优化</strong></p><p>Redis4.0 相对与 3.X 版本其中一个比较大的变化是 4.0 添加了新的混合持久化方式。</p><p>简单的说：新的 AOF 文件前半段是 RDB 格式的全量数据后半段是 AOF 格式的增量数据，如下图：</p><p><img data-src="https://images2018.cnblogs.com/blog/1075473/201807/1075473-20180726181756270-1907770368.png" alt="img"></p><p><strong>优势</strong>：混合持久化结合了 RDB 持久化 和 AOF 持久化的优点， 由于绝大部分都是 RDB 格式，加载速度快，同时结合 AOF，增量的数据以 AOF 方式保存了，数据更少的丢失。</p><p><strong>劣势</strong>：兼容性差，一旦开启了混合持久化，在 4.0 之前版本都不识别该 aof 文件，同时由于前部分是 RDB 格式，阅读性较差。</p><h3 id="3-redis持久化数据和缓存怎么做扩容"><a class="anchor" href="#3-redis持久化数据和缓存怎么做扩容">#</a> 3. Redis 持久化数据和缓存怎么做扩容？</h3><ul><li>如果 Redis 被当做缓存使用，使用一致性哈希实现动态扩容缩容。</li><li>如果 Redis 被当做一个持久化存储使用，必须使用固定的 keys-to-nodes 映射关系，节点的数量一旦确定不能变化。否则的话 (即 Redis 节点需要动态变化的情况），必须使用可以在运行时进行数据再平衡的一套系统，而当前只有 Redis 集群可以做到这样。</li></ul><h2 id="过期键的删除策略-淘汰策略"><a class="anchor" href="#过期键的删除策略-淘汰策略">#</a> 过期键的删除策略、淘汰策略</h2><h3 id="1-redis过期键的删除策略"><a class="anchor" href="#1-redis过期键的删除策略">#</a> 1. Redis 过期键的删除策略</h3><p><strong>Redis 的过期删除策略就是：惰性删除和定期删除两种策略配合使用。</strong></p><p><strong>惰性删除</strong>：惰性删除不会去主动删除数据，而是在访问数据的时候，再检查当前键值是否过期，如果过期则执行删除并返回 null 给客户端，如果没有过期则返回正常信息给客户端。它的优点是简单，不需要对过期的数据做额外的处理，只有在每次访问的时候才会检查键值是否过期，缺点是删除过期键不及时，造成了一定的空间浪费。</p><p><strong>定期删除</strong>：Redis 会周期性的随机测试一批设置了过期时间的 key 并进行处理。测试到的已过期的 key 将被删除。</p><p>附：删除 key 常见的三种处理方式。</p><p><strong>1、定时删除</strong></p><p>在设置某个 key 的过期时间同时，我们创建一个定时器，让定时器在该过期时间到来时，立即执行对其进行删除的操作。</p><p>优点：定时删除对内存是最友好的，能够保存内存的 key 一旦过期就能立即从内存中删除。</p><p>缺点：对 CPU 最不友好，在过期键比较多的时候，删除过期键会占用一部分 CPU 时间，对服务器的响应时间和吞吐量造成影响。</p><p><strong>2、惰性删除</strong></p><p>设置该 key 过期时间后，我们不去管它，当需要该 key 时，我们在检查其是否过期，如果过期，我们就删掉它，反之返回该 key。</p><p>优点：对 CPU 友好，我们只会在使用该键时才会进行过期检查，对于很多用不到的 key 不用浪费时间进行过期检查。</p><p>缺点：对内存不友好，如果一个键已经过期，但是一直没有使用，那么该键就会一直存在内存中，如果数据库中有很多这种使用不到的过期键，这些键便永远不会被删除，内存永远不会释放。从而造成内存泄漏。</p><p><strong>3、定期删除</strong></p><p>每隔一段时间，我们就对一些 key 进行检查，删除里面过期的 key。</p><p>优点：可以通过限制删除操作执行的时长和频率来减少删除操作对 CPU 的影响。另外定期删除，也能有效释放过期键占用的内存。</p><p>缺点：难以确定删除操作执行的时长和频率。如果执行的太频繁，定期删除策略变得和定时删除策略一样，对 CPU 不友好。如果执行的太少，那又和惰性删除一样了，过期键占用的内存不会及时得到释放。另外最重要的是，在获取某个键时，如果某个键的过期时间已经到了，但是还没执行定期删除，那么就会返回这个键的值，这是业务不能忍受的错误。</p><h3 id="2-redis-key的过期时间和永久有效分别怎么设置"><a class="anchor" href="#2-redis-key的过期时间和永久有效分别怎么设置">#</a> 2. Redis key 的过期时间和永久有效分别怎么设置？</h3><p>通过 expire 或 pexpire 命令，客户端可以以秒或毫秒的精度为数据库中的某个键设置生存时间。</p><p>与 expire 和 pexpire 命令类似，客户端可以通过 expireat 和 pexpireat 命令，以秒或毫秒精度给数据库中的某个键设置过期时间，可以理解为：让某个键在某个时间点过期。</p><h3 id="3-redis内存淘汰策略"><a class="anchor" href="#3-redis内存淘汰策略">#</a> 3. Redis 内存淘汰策略</h3><p>Redis 是不断的删除一些过期数据，但是很多没有设置过期时间的数据也会越来越多，那么 Redis 内存不够用的时候是怎么处理的呢？答案就是淘汰策略。此类的</p><p>当 Redis 的内存超过最大允许的内存之后，Redis 会触发内存淘汰策略，删除一些不常用的数据，以保证 Redis 服务器的正常运行。</p><p><strong>Redisv4.0 前提供 6 种数据淘汰策略</strong>：</p><ul><li>volatile-lru：利用 LRU 算法移除设置过过期时间的 key (LRU: 最近使用 Least Recently Used)</li><li>allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的）</li><li>volatile-ttl：从已设置过期时间的数据集（server.db [i].expires）中挑选将要过期的数据淘汰</li><li>volatile-random：从已设置过期时间的数据集（server.db [i].expires）中任意选择数据淘汰</li><li>allkeys-random：从数据集（server.db [i].dict）中任意选择数据淘汰</li><li>no-eviction：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！</li></ul><p><strong>Redisv4.0 后增加以下两种</strong>：</p><ul><li>volatile-lfu：从已设置过期时间的数据集 (server.db [i].expires) 中挑选最不经常使用的数据淘汰 (LFU (Least Frequently Used) 算法，也就是最频繁被访问的数据将来最有可能被访问到)</li><li>allkeys-lfu：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的 key。</li></ul><p>内存淘汰策略可以通过配置文件来修改，Redis.conf 对应的配置项是 maxmemory-policy 修改对应的值就行，默认是 noeviction。</p><h2 id="缓存异常"><a class="anchor" href="#缓存异常">#</a> 缓存异常</h2><blockquote><p>缓存异常有四种类型，分别是缓存和数据库的数据不一致、缓存雪崩、缓存击穿和缓存穿透。</p></blockquote><h3 id="1-如何保证缓存与数据库双写时的数据一致性"><a class="anchor" href="#1-如何保证缓存与数据库双写时的数据一致性">#</a> 1. 如何保证缓存与数据库双写时的数据一致性？</h3><blockquote><p>背景：使用到缓存，无论是本地内存做缓存还是使用 Redis 做缓存，那么就会存在数据同步的问题，因为配置信息缓存在内存中，而内存时无法感知到数据在数据库的修改。这样就会造成数据库中的数据与缓存中数据不一致的问题。</p></blockquote><p>共有四种方案：</p><ol><li>先更新数据库，后更新缓存</li><li>先更新缓存，后更新数据库</li><li>先删除缓存，后更新数据库</li><li>先更新数据库，后删除缓存</li></ol><p>第一种和第二种方案，没有人使用的，因为第一种方案存在问题是：并发更新数据库场景下，会将脏数据刷到缓存。</p><p>第二种方案存在的问题是：如果先更新缓存成功，但是数据库更新失败，则肯定会造成数据不一致。</p><p>目前主要用第三和第四种方案。</p><h3 id="2-先删除缓存后更新数据库"><a class="anchor" href="#2-先删除缓存后更新数据库">#</a> 2. 先删除缓存，后更新数据库</h3><p>该方案也会出问题，此时来了两个请求，请求 A（更新操作） 和请求 B（查询操作）</p><ol><li>请求 A 进行写操作，删除缓存</li><li>请求 B 查询发现缓存不存在</li><li>请求 B 去数据库查询得到旧值</li><li>请求 B 将旧值写入缓存</li><li>请求 A 将新值写入数据库</li></ol><p>上述情况就会导致不一致的情形出现。而且，如果不采用给缓存设置过期时间策略，该数据永远都是脏数据。</p><p><strong>答案一：延时双删</strong></p><p>最简单的解决办法延时双删</p><p>使用伪代码如下：</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">write</span><span class="token punctuation">(</span><span class="token class-name">String</span> key<span class="token punctuation">,</span><span class="token class-name">Object</span> data<span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>		<span class="token class-name">Redis</span><span class="token punctuation">.</span><span class="token function">delKey</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>	    db<span class="token punctuation">.</span><span class="token function">updateData</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>	    <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>	    <span class="token class-name">Redis</span><span class="token punctuation">.</span><span class="token function">delKey</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>	<span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>转化为中文描述就是 （1）先淘汰缓存 （2）再写数据库（这两步和原来一样） （3）休眠 1 秒，再次淘汰缓存，这么做，可以将 1 秒内所造成的缓存脏数据，再次删除。确保读请求结束，写请求可以删除读请求造成的缓存脏数据。自行评估自己的项目的读数据业务逻辑的耗时，写数据的休眠时间则在读数据业务逻辑的耗时基础上，加几百 ms 即可。</p><p>如果使用的是 Mysql 的读写分离的架构的话，那么其实主从同步之间也会有时间差。</p><p><img data-src="http://blog-img.coolsen.cn/img/1735bb5881bbb1d4~tplv-t2oaga2asx-watermark.awebp" alt="主从同步时间差"></p><p>此时来了两个请求，请求 A（更新操作） 和请求 B（查询操作）</p><ol><li>请求 A 更新操作，删除了 Redis</li><li>请求主库进行更新操作，主库与从库进行同步数据的操作</li><li>请 B 查询操作，发现 Redis 中没有数据</li><li>去从库中拿去数据</li><li>此时同步数据还未完成，拿到的数据是旧数据</li></ol><p>此时的解决办法就是如果是对 Redis 进行填充数据的查询数据库操作，那么就强制将其指向主库进行查询。</p><p><img data-src="http://blog-img.coolsen.cn/img/1735bb5881a19fec~tplv-t2oaga2asx-watermark.awebp" alt="从主库中拿数据"></p><p><strong>答案二： 更新与读取操作进行异步串行化</strong></p><p>采用<strong>更新与读取操作进行异步串行化</strong></p><p><strong>异步串行化</strong></p><p>我在系统内部维护 n 个内存队列，更新数据的时候，根据数据的唯一标识，将该操作路由之后，发送到其中一个 jvm 内部的内存队列中（对同一数据的请求发送到同一个队列）。读取数据的时候，如果发现数据不在缓存中，并且此时队列里有更新库存的操作，那么将重新读取数据 + 更新缓存的操作，根据唯一标识路由之后，也将发送到同一个 jvm 内部的内存队列中。然后每个队列对应一个工作线程，每个工作线程串行地拿到对应的操作，然后一条一条的执行。</p><p>这样的话，一个数据变更的操作，先执行删除缓存，然后再去更新数据库，但是还没完成更新的时候，如果此时一个读请求过来，读到了空的缓存，那么可以先将缓存更新的请求发送到队列中，此时会在队列中积压，排在刚才更新库的操作之后，然后同步等待缓存更新完成，再读库。</p><p><strong>读操作去重</strong></p><p>多个读库更新缓存的请求串在同一个队列中是没意义的，因此可以做过滤，如果发现队列中已经有了该数据的更新缓存的请求了，那么就不用再放进去了，直接等待前面的更新操作请求完成即可，待那个队列对应的工作线程完成了上一个操作（数据库的修改）之后，才会去执行下一个操作（读库更新缓存），此时会从数据库中读取最新的值，然后写入缓存中。</p><p>如果请求还在等待时间范围内，不断轮询发现可以取到值了，那么就直接返回；如果请求等待的时间超过一定时长，那么这一次直接从数据库中读取当前的旧值。（返回旧值不是又导致缓存和数据库不一致了么？那至少可以减少这个情况发生，因为等待超时也不是每次都是，几率很小吧。这里我想的是，如果超时了就直接读旧值，这时候仅仅是读库后返回而不放缓存）</p><h3 id="3-先更新数据库后删除缓存"><a class="anchor" href="#3-先更新数据库后删除缓存">#</a> 3. 先更新数据库，后删除缓存</h3><p>这一种情况也会出现问题，比如更新数据库成功了，但是在删除缓存的阶段出错了没有删除成功，那么此时再读取缓存的时候每次都是错误的数据了。</p><p><img data-src="http://blog-img.coolsen.cn/img/1735bb5881fb4a1b~tplv-t2oaga2asx-watermark.awebp" alt="先更新数据库，后删除缓存"></p><p>此时解决方案就是利用消息队列进行删除的补偿。具体的业务逻辑用语言描述如下：</p><ol><li>请求 A 先对数据库进行更新操作</li><li>在对 Redis 进行删除操作的时候发现报错，删除失败</li><li>此时将 Redis 的 key 作为消息体发送到消息队列中</li><li>系统接收到消息队列发送的消息后再次对 Redis 进行删除操作</li></ol><p>但是这个方案会有一个缺点就是会对业务代码造成大量的侵入，深深的耦合在一起，所以这时会有一个优化的方案，我们知道对 Mysql 数据库更新操作后再 binlog 日志中我们都能够找到相应的操作，那么我们可以订阅 Mysql 数据库的 binlog 日志对缓存进行操作。</p><p><img data-src="http://blog-img.coolsen.cn/img/1735bb588215b298~tplv-t2oaga2asx-watermark.awebp" alt="利用订阅 binlog 删除缓存"></p><h3 id="4-什么是缓存击穿"><a class="anchor" href="#4-什么是缓存击穿">#</a> 4. 什么是缓存击穿？</h3><p>缓存击穿跟缓存雪崩有点类似，缓存雪崩是大规模的 key 失效，而缓存击穿是某个热点的 key 失效，大并发集中对其进行请求，就会造成大量请求读缓存没读到数据，从而导致高并发访问数据库，引起数据库压力剧增。这种现象就叫做缓存击穿。</p><p>从两个方面解决，第一是否可以考虑热点 key 不设置过期时间，第二是否可以考虑降低打在数据库上的请求数量。</p><p>解决方案：</p><ul><li>在缓存失效后，通过互斥锁或者队列来控制读数据写缓存的线程数量，比如某个 key 只允许一个线程查询数据和写缓存，其他线程等待。这种方式会阻塞其他的线程，此时系统的吞吐量会下降</li><li>热点数据缓存永远不过期。永不过期实际包含两层意思：<ul><li>物理不过期，针对热点 key 不设置过期时间</li><li>逻辑过期，把过期时间存在 key 对应的 value 里，如果发现要过期了，通过一个后台的异步线程进行缓存的构建</li></ul></li></ul><h3 id="5-什么是缓存穿透"><a class="anchor" href="#5-什么是缓存穿透">#</a> 5. 什么是缓存穿透？</h3><p>缓存穿透是指用户请求的数据在缓存中不存在即没有命中，同时在数据库中也不存在，导致用户每次请求该数据都要去数据库中查询一遍。如果有恶意攻击者不断请求系统中不存在的数据，会导致短时间大量请求落在数据库上，造成数据库压力过大，甚至导致数据库承受不住而宕机崩溃。</p><blockquote><p>缓存穿透的关键在于在 Redis 中查不到 key 值，它和缓存击穿的根本区别在于传进来的 key 在 Redis 中是不存在的。假如有黑客传进大量的不存在的 key，那么大量的请求打在数据库上是很致命的问题，所以在日常开发中要对参数做好校验，一些非法的参数，不可能存在的 key 就直接返回错误提示。</p></blockquote><p><img data-src="http://blog-img.coolsen.cn/img/2021013117512340.png" alt="img"></p><p>解决方法：</p><ul><li>将无效的 key 存放进 Redis 中：</li></ul><p>当出现 Redis 查不到数据，数据库也查不到数据的情况，我们就把这个 key 保存到 Redis 中，设置 value=&quot;null&quot;，并设置其过期时间极短，后面再出现查询这个 key 的请求的时候，直接返回 null，就不需要再查询数据库了。但这种处理方式是有问题的，假如传进来的这个不存在的 Key 值每次都是随机的，那存进 Redis 也没有意义。</p><ul><li>使用布隆过滤器：</li></ul><p>如果布隆过滤器判定某个 key 不存在布隆过滤器中，那么就一定不存在，如果判定某个 key 存在，那么很大可能是存在 (存在一定的误判率)。于是我们可以在缓存之前再加一个布隆过滤器，将数据库中的所有 key 都存储在布隆过滤器中，在查询 Redis 前先去布隆过滤器查询 key 是否存在，如果不存在就直接返回，不让其访问数据库，从而避免了对底层存储系统的查询压力。</p><blockquote><p>如何选择：针对一些恶意攻击，攻击带过来的大量 key 是随机，那么我们采用第一种方案就会缓存大量不存在 key 的数据。那么这种方案就不合适了，我们可以先对使用布隆过滤器方案进行过滤掉这些 key。所以，针对这种 key 异常多、请求重复率比较低的数据，优先使用第二种方案直接过滤掉。而对于空数据的 key 有限的，重复率比较高的，则可优先采用第一种方式进行缓存。</p></blockquote><h3 id="6-什么是缓存雪崩"><a class="anchor" href="#6-什么是缓存雪崩">#</a> 6. 什么是缓存雪崩？</h3><p>如果缓在某一个时刻出现大规模的 key 失效，那么就会导致大量的请求打在了数据库上面，导致数据库压力巨大，如果在高并发的情况下，可能瞬间就会导致数据库宕机。这时候如果运维马上又重启数据库，马上又会有新的流量把数据库打死。这就是缓存雪崩。</p><p>造成缓存雪崩的关键在于同一时间的大规模的 key 失效，主要有两种可能：第一种是 Redis 宕机，第二种可能就是采用了相同的过期时间。</p><p>解决方案：</p><p>1、事前：</p><ul><li>均匀过期：设置不同的过期时间，让缓存失效的时间尽量均匀，避免相同的过期时间导致缓存雪崩，造成大量数据库的访问。如把每个 Key 的失效时间都加个随机值， <code>setRedis（Key，value，time + Math.random() * 10000）；</code> ，保证数据不会在同一时间大面积失效。</li><li>分级缓存：第一级缓存失效的基础上，访问二级缓存，每一级缓存的失效时间都不同。</li><li>热点数据缓存永远不过期。永不过期实际包含两层意思：<ul><li>物理不过期，针对热点 key 不设置过期时间</li><li>逻辑过期，把过期时间存在 key 对应的 value 里，如果发现要过期了，通过一个后台的异步线程进行缓存的构建</li></ul></li><li>保证 Redis 缓存的高可用，防止 Redis 宕机导致缓存雪崩的问题。可以使用 主从 + 哨兵，Redis 集群来避免 Redis 全盘崩溃的情况。</li></ul><p>2、事中：</p><ul><li>互斥锁：在缓存失效后，通过互斥锁或者队列来控制读数据写缓存的线程数量，比如某个 key 只允许一个线程查询数据和写缓存，其他线程等待。这种方式会阻塞其他的线程，此时系统的吞吐量会下降</li><li>使用熔断机制，限流降级。当流量达到一定的阈值，直接返回 “系统拥挤” 之类的提示，防止过多的请求打在数据库上将数据库击垮，至少能保证一部分用户是可以正常使用，其他用户多刷新几次也能得到结果。</li></ul><p>3、事后：</p><p>开启 Redis 持久化机制，尽快恢复缓存数据，一旦重启，就能从磁盘上自动加载数据恢复内存中的数据。</p><h3 id="7-什么是缓存预热"><a class="anchor" href="#7-什么是缓存预热">#</a> 7. 什么是缓存预热？</h3><p>缓存预热是指系统上线后，提前将相关的缓存数据加载到缓存系统。避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题，用户直接查询事先被预热的缓存数据。</p><p>如果不进行预热，那么 Redis 初始状态数据为空，系统上线初期，对于高并发的流量，都会访问到数据库中， 对数据库造成流量的压力。</p><p>缓存预热解决方案：</p><ul><li>数据量不大的时候，工程启动的时候进行加载缓存动作；</li><li>数据量大的时候，设置一个定时任务脚本，进行缓存的刷新；</li><li>数据量太大的时候，优先保证热点数据进行提前加载到缓存。</li></ul><h3 id="8-什么是缓存降级"><a class="anchor" href="#8-什么是缓存降级">#</a> 8. 什么是缓存降级？</h3><p>缓存降级是指缓存失效或缓存服务器挂掉的情况下，不去访问数据库，直接返回默认数据或访问服务的内存数据。降级一般是有损的操作，所以尽量减少降级对于业务的影响程度。</p><p>在进行降级之前要对系统进行梳理，看看系统是不是可以丢卒保帅；从而梳理出哪些必须誓死保护，哪些可降级；比如可以参考日志级别设置预案：</p><ul><li>一般：比如有些服务偶尔因为网络抖动或者服务正在上线而超时，可以自动降级；</li><li>警告：有些服务在一段时间内成功率有波动（如在 95~100% 之间），可以自动降级或人工降级，并发送告警；</li><li>错误：比如可用率低于 90%，或者数据库连接池被打爆了，或者访问量突然猛增到系统能承受的最大阀值，此时可以根据情况自动降级或者人工降级；</li><li>严重错误：比如因为特殊原因数据错误了，此时需要紧急人工降级。</li></ul><h2 id="线程模型"><a class="anchor" href="#线程模型">#</a> 线程模型</h2><h3 id="1-redis为何选择单线程"><a class="anchor" href="#1-redis为何选择单线程">#</a> 1. Redis 为何选择单线程？</h3><p>在 Redis 6.0 以前，Redis 的核心网络模型选择用单线程来实现。先来看下官方的回答：</p><blockquote><p>It's not very frequent that CPU becomes your bottleneck with Redis， as usually Redisis either memory or network bound. For instance， using pipelining Redisrunning on an average Linux system can deliver even 1 million requests per second， so if your application mainly uses O(N) or O(log(N)) commands， it is hardly going to use too much CPU.</p></blockquote><p>核心意思就是，对于一个 DB 来说，CPU 通常不会是瓶颈，因为大多数请求不会是 CPU 密集型的，而是 I/O 密集型。具体到 Redis 的话，如果不考虑 RDB/AOF 等持久化方案，Redis 是完全的纯内存操作，执行速度是非常快的，因此这部分操作通常不会是性能瓶颈，Redis 真正的性能瓶颈在于网络 I/O，也就是客户端和服务端之间的网络传输延迟，因此 Redis 选择了单线程的 I/O 多路复用来实现它的核心网络模型。</p><p>实际上更加具体的选择单线程的原因如下：</p><ul><li>避免过多的上下文切换开销：如果是单线程则可以规避进程内频繁的线程切换开销，因为程序始终运行在进程中单个线程内，没有多线程切换的场景。</li><li>避免同步机制的开销：如果 Redis 选择多线程模型，又因为 Redis 是一个数据库，那么势必涉及到底层数据同步的问题，则必然会引入某些同步机制，比如锁，而我们知道 Redis 不仅仅提供了简单的 key-value 数据结构，还有 list、set 和 hash 等等其他丰富的数据结构，而不同的数据结构对同步访问的加锁粒度又不尽相同，可能会导致在操作数据过程中带来很多加锁解锁的开销，增加程序复杂度的同时还会降低性能。</li><li>简单可维护：如果 Redis 使用多线程模式，那么所有的底层数据结构都必须实现成线程安全的，这无疑又使得 Redis 的实现变得更加复杂。</li></ul><p>总而言之，Redis 选择单线程可以说是多方博弈之后的一种权衡：在保证足够的性能表现之下，使用单线程保持代码的简单和可维护性。</p><h3 id="2-redis真的是单线程"><a class="anchor" href="#2-redis真的是单线程">#</a> 2. Redis 真的是单线程？</h3><p>讨论 这个问题前，先看下 Redis 的版本中两个重要的节点：</p><ol><li>Redisv4.0（引入多线程处理异步任务）</li><li>Redis 6.0（在网络模型中实现多线程 I/O ）</li></ol><p>所以，网络上说的 Redis 是单线程，通常是指在 Redis 6.0 之前，其核心网络模型使用的是单线程。</p><p>且 Redis6.0 引入<strong>多线程 I/O</strong>，只是用来<strong>处理网络数据的读写和协议的解析</strong>，而<strong>执行命令依旧是单线程</strong>。</p><blockquote><p>Redis 在 v4.0 版本的时候就已经引入了的多线程来做一些异步操作，此举主要针对的是那些非常耗时的命令，通过将这些命令的执行进行异步化，避免阻塞单线程的事件循环。</p><p>在 Redisv4.0 之后增加了一些的非阻塞命令如 <code>UNLINK</code> 、 <code>FLUSHALL ASYNC</code> 、 <code>FLUSHDB ASYNC</code> 。</p></blockquote><h3 id="3-redis-60为何引入多线程"><a class="anchor" href="#3-redis-60为何引入多线程">#</a> 3. Redis 6.0 为何引入多线程？</h3><p>很简单，就是 Redis 的网络 I/O 瓶颈已经越来越明显了。</p><p>随着互联网的飞速发展，互联网业务系统所要处理的线上流量越来越大，Redis 的单线程模式会导致系统消耗很多 CPU 时间在网络 I/O 上从而降低吞吐量，要提升 Redis 的性能有两个方向：</p><ul><li>优化网络 I/O 模块</li><li>提高机器内存读写的速度</li></ul><p>后者依赖于硬件的发展，暂时无解。所以只能从前者下手，网络 I/O 的优化又可以分为两个方向：</p><ul><li>零拷贝技术或者 DPDK 技术</li><li>利用多核优势</li></ul><p>零拷贝技术有其局限性，无法完全适配 Redis 这一类复杂的网络 I/O 场景，更多网络 I/O 对 CPU 时间的消耗和 Linux 零拷贝技术。而 DPDK 技术通过旁路网卡 I/O 绕过内核协议栈的方式又太过于复杂以及需要内核甚至是硬件的支持。</p><p>总结起来，Redis 支持多线程主要就是两个原因：</p><ul><li>可以充分利用服务器 CPU 资源，目前主线程只能利用一个核</li><li>多线程任务可以分摊 Redis 同步 IO 读写负荷</li></ul><h3 id="4-redis-60-采用多线程后性能的提升效果如何"><a class="anchor" href="#4-redis-60-采用多线程后性能的提升效果如何">#</a> 4. Redis 6.0 采用多线程后，性能的提升效果如何？</h3><p>Redis 作者 antirez 在 RedisConf 2019 分享时曾提到：Redis 6 引入的多线程 IO 特性对性能提升至少是一倍以上。</p><p>国内也有大牛曾使用 unstable 版本在阿里云 esc 进行过测试，GET/SET 命令在 4 线程 IO 时性能相比单线程是几乎是翻倍了。</p><h3 id="5-介绍下redis的线程模型"><a class="anchor" href="#5-介绍下redis的线程模型">#</a> 5. 介绍下 Redis 的线程模型</h3><p>Redis 的线程模型包括 Redis 6.0 之前和 Redis 6.0。</p><p>下面介绍的是 Redis 6.0 之前。</p><p>Redis 是基于 reactor 模式开发了网络事件处理器，这个处理器叫做文件事件处理器（file event handler）。由于这个文件事件处理器是单线程的，所以 Redis 才叫做单线程的模型。采用 IO 多路复用机制同时监听多个 Socket，根据 socket 上的事件来选择对应的事件处理器来处理这个事件。</p><blockquote><p>IO 多路复用是 IO 模型的一种，有时也称为异步阻塞 IO，是基于经典的 Reactor 设计模式设计的。多路指的是多个 Socket 连接，复用指的是复用一个线程。多路复用主要有三种技术：Select，Poll，Epoll。</p><p>Epoll 是最新的也是目前最好的多路复用技术。</p></blockquote><p>模型如下图：</p><p><img data-src="http://blog-img.coolsen.cn/img/202105092153018231.png" alt="202105092153018231.png"></p><p>文件事件处理器的结构包含了四个部分：</p><ul><li>多个 Socket。Socket 会产生 AE_READABLE 和 AE_WRITABLE 事件：<ul><li>当 socket 变得可读时或者有新的可以应答的 socket 出现时，socket 就会产生一个 AE_READABLE 事件</li><li>当 socket 变得可写时，socket 就会产生一个 AE_WRITABLE 事件。</li></ul></li><li>IO 多路复用程序</li><li>文件事件分派器</li><li>事件处理器。事件处理器包括：连接应答处理器、命令请求处理器、命令回复处理器，每个处理器对应不同的 socket 事件：<ul><li>如果是客户端要连接 Redis，那么会为 socket 关联连接应答处理器</li><li>如果是客户端要写数据到 Redis（读、写请求命令），那么会为 socket 关联命令请求处理器</li><li>如果是客户端要从 Redis 读数据，那么会为 socket 关联命令回复处理器</li></ul></li></ul><p>多个 socket 会产生不同的事件，不同的事件对应着不同的操作，IO 多路复用程序监听着这些 Socket，当这些 Socket 产生了事件，IO 多路复用程序会将这些事件放到一个队列中，通过这个队列，以有序、同步、每次一个事件的方式向文件时间分派器中传送。当事件处理器处理完一个事件后，IO 多路复用程序才会继续向文件分派器传送下一个事件。</p><p>下图是客户端与 Redis 通信的一次完整的流程：</p><p><img data-src="http://blog-img.coolsen.cn/img/202105092153019692.png" alt="202105092153019692.png"></p><ol><li>Redis 启动初始化的时候，Redis 会将连接应答处理器与 AE_READABLE 事件关联起来。</li><li>如果一个客户端跟 Redis 发起连接，此时 Redis 会产生一个 AE_READABLE 事件，由于开始之初 AE_READABLE 是与连接应答处理器关联，所以由连接应答处理器来处理该事件，这时连接应答处理器会与客户端建立连接，创建客户端响应的 socket，同时将这个 socket 的 AE_READABLE 事件与命令请求处理器关联起来。</li><li>如果这个时间客户端向 Redis 发送一个命令（set k1 v1），这时 socket 会产生一个 AE_READABLE 事件，IO 多路复用程序会将该事件压入队列中，此时事件分派器从队列中取得该事件，由于该 socket 的 AE_READABLE 事件已经和命令请求处理器关联了，因此事件分派器会将该事件交给命令请求处理器处理，命令请求处理器读取事件中的命令并完成。操作完成后，Redis 会将该 socket 的 AE_WRITABLE 事件与命令回复处理器关联。</li><li>如果客户端已经准备好接受数据后，Redis 中的该 socket 会产生一个 AE_WRITABLE 事件，同样会压入队列然后被事件派发器取出交给相对应的命令回复处理器，由该命令回复处理器将准备好的响应数据写入 socket 中，供客户端读取。</li><li>命令回复处理器写完后，就会删除该 socket 的 AE_WRITABLE 事件与命令回复处理器的关联关系。</li></ol><h3 id="6-redis-60-多线程的实现机制"><a class="anchor" href="#6-redis-60-多线程的实现机制">#</a> 6. Redis 6.0 多线程的实现机制？</h3><p><strong>流程简述如下</strong>：</p><ul><li>主线程负责接收建立连接请求，获取 Socket 放入全局等待读处理队列。</li><li>主线程处理完读事件之后，通过 RR（Round Robin）将这些连接分配给这些 IO 线程。</li><li>主线程阻塞等待 IO 线程读取 Socket 完毕。</li><li>主线程通过单线程的方式执行请求命令，请求数据读取并解析完成，但并不执行。</li><li>主线程阻塞等待 IO 线程将数据回写 Socket 完毕。</li></ul><p><img data-src="http://blog-img.coolsen.cn/img/image-20210828175543973.png" alt="image-20210828175543973"></p><p><strong>该设计有如下特点</strong>：</p><ul><li>IO 线程要么同时在读 Socket，要么同时在写，不会同时读或写。</li><li>IO 线程只负责读写 Socket 解析命令，不负责命令处理。</li></ul><h3 id="7-redis-60开启多线程后是否会存在线程并发安全问题"><a class="anchor" href="#7-redis-60开启多线程后是否会存在线程并发安全问题">#</a> 7. Redis 6.0 开启多线程后，是否会存在线程并发安全问题？</h3><p>从实现机制可以看出，Redis 的多线程部分只是用来处理网络数据的读写和协议解析，执行命令仍然是单线程顺序执行。</p><p>所以我们不需要去考虑控制 Key、Lua、事务，LPUSH/LPOP 等等的并发及线程安全问题。</p><h3 id="8-redis-60-与-memcached-多线程模型的对比"><a class="anchor" href="#8-redis-60-与-memcached-多线程模型的对比">#</a> 8. Redis 6.0 与 Memcached 多线程模型的对比</h3><ul><li><p>** 相同点：** 都采用了 Master 线程 -Worker 线程的模型。</p></li><li><p><strong>不同点</strong>：Memcached 执行主逻辑也是在 Worker 线程里，模型更加简单，实现了真正的线程隔离，符合我们对线程隔离的常规理解。</p><p>而 Redis 把处理逻辑交还给 Master 线程，虽然一定程度上增加了模型复杂度，但也解决了线程并发安全等问题。</p></li></ul><h2 id="事务"><a class="anchor" href="#事务">#</a> 事务</h2><h3 id="1-redis事务的概念"><a class="anchor" href="#1-redis事务的概念">#</a> 1. Redis 事务的概念</h3><p>Redis 的事务并不是我们传统意义上理解的事务，我们都知道 单个 Redis 命令的执行是原子性的，但 Redis 没有在事务上增加任何维持原子性的机制，所以 Redis <strong>事务的执行并不是原子性的</strong>。</p><p>事务可以理解为一个<strong>打包的批量执行脚本</strong>，但<strong>批量指令并非原子化</strong>的操作，中间某条指令的失败不会导致前面已做指令的回滚，也不会造成后续的指令不做。</p><p><strong>总结：</strong></p><ol><li><p>Redis 事务中如果有某一条命令执行失败，之前的命令不会回滚，其后的命令仍然会被继续执行。<strong>鉴于这个原因，所以说 Redis 的事务严格意义上来说是不具备原子性的</strong>。</p></li><li><p>Redis 事务中所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</p></li><li><p>在事务开启之前，如果客户端与服务器之间出现通讯故障并导致网络断开，其后所有待执行的语句都将不会被服务器执行。然而如果网络中断事件是发生在客户端执行 EXEC 命令之后，那么该事务中的所有命令都会被服务器执行。</p></li></ol><blockquote><p>当使用 Append-Only 模式时，Redis 会通过调用系统函数 write 将该事务内的所有写操作在本次调用中全部写入磁盘。然而如果在写入的过程中出现系统崩溃，如电源故障导致的宕机，那么此时也许只有部分数据被写入到磁盘，而另外一部分数据却已经丢失。Redis 服务器会在重新启动时执行一系列必要的一致性检测，一旦发现类似问题，就会立即退出并给出相应的错误提示。此时，我们就要充分利用 Redis 工具包中提供的 Redis-check-aof 工具，该工具可以帮助我们定位到数据不一致的错误，并将已经写入的部分数据进行回滚。修复之后我们就可以再次重新启动 Redis 服务器了。</p></blockquote><h3 id="2-redis事务的三个阶段"><a class="anchor" href="#2-redis事务的三个阶段">#</a> 2. Redis 事务的三个阶段</h3><ol><li>multi 开启事务</li><li>大量指令入队</li><li>exec 执行事务块内命令，<strong>截止此处一个事务已经结束。</strong></li><li>discard 取消事务</li><li>watch 监视一个或多个 key，如果事务执行前 key 被改动，事务将打断。unwatch 取消监视。</li></ol><p>事务执行过程中，如果服务端收到有 EXEC、DISCARD、WATCH、MULTI 之外的请求，将会把请求放入队列中排队.</p><h3 id="3-redis事务相关命令"><a class="anchor" href="#3-redis事务相关命令">#</a> 3. Redis 事务相关命令</h3><p>Redis 事务功能是通过 MULTI、EXEC、DISCARD 和 WATCH 四个原语实现的</p><ul><li>WATCH 命令是一个乐观锁，可以为 Redis 事务提供 check-and-set （CAS）行为。 可以监控一个或多个键，一旦其中有一个键被修改（或删除），之后的事务就不会执行，监控一直持续到 EXEC 命令。</li><li>MULTI 命令用于开启一个事务，它总是返回 OK。 MULTI 执行之后，客户端可以继续向服务器发送任意多条命令，这些命令不会立即被执行，而是被放到一个队列中，当 EXEC 命令被调用时，所有队列中的命令才会被执行。</li><li>EXEC：执行所有事务块内的命令。返回事务块内所有命令的返回值，按命令执行的先后顺序排列。 当操作被打断时，返回空值 nil 。 通过调用 DISCARD，客户端可以清空事务队列，并放弃执行事务， 并且客户端会从事务状态中退出。</li><li>UNWATCH 命令可以取消 watch 对所有 key 的监控。</li></ul><h3 id="4-redis事务支持隔离性吗"><a class="anchor" href="#4-redis事务支持隔离性吗">#</a> 4. Redis 事务支持隔离性吗？</h3><p>Redis 是单进程程序，并且它保证在执行事务时，不会对事务进行中断，事务可以运行直到执行完所有事务队列中的命令为止。因此，<strong>Redis 的事务是总是带有隔离性的</strong>。</p><h3 id="5-redis为什么不支持事务回滚"><a class="anchor" href="#5-redis为什么不支持事务回滚">#</a> 5. Redis 为什么不支持事务回滚？</h3><ul><li>Redis 命令只会因为错误的语法而失败，或是命令用在了错误类型的键上面，这些问题不能在入队时发现，这也就是说，从实用性的角度来说，失败的命令是由编程错误造成的，而这些错误应该在开发的过程中被发现，而不应该出现在生产环境中.</li><li>因为不需要对回滚进行支持，所以 Redis 的内部可以保持简单且快速。</li></ul><h3 id="6-redis事务其他实现"><a class="anchor" href="#6-redis事务其他实现">#</a> 6. Redis 事务其他实现</h3><ul><li>基于 Lua 脚本，Redis 可以保证脚本内的命令一次性、按顺序地执行， 其同时也不提供事务运行错误的回滚，执行过程中如果部分命令运行错误，剩下的命令还是会继续运行完。</li><li>基于中间标记变量，通过另外的标记变量来标识事务是否执行完成，读取数据时先读取该标记变量判断是否事务执行完成。但这样会需要额外写代码实现，比较繁琐。</li></ul><h2 id="主从-哨兵-集群"><a class="anchor" href="#主从-哨兵-集群">#</a> 主从、哨兵、集群</h2><h3 id="1-redis常见使用方式有哪些"><a class="anchor" href="#1-redis常见使用方式有哪些">#</a> 1. Redis 常见使用方式有哪些？</h3><p>Redis 的几种常见使用方式包括：</p><ul><li>Redis 单副本；</li><li>Redis 多副本（主从）；</li><li>Redis Sentinel（哨兵）；</li><li>Redis Cluster；</li><li>Redis 自研。</li></ul><p>使用场景：</p><p>如果数据量很少，主要是承载高并发高性能的场景，比如缓存一般就几个 G 的话，单机足够了。</p><p>主从模式：master 节点挂掉后，需要手动指定新的 master，可用性不高，基本不用。</p><p>哨兵模式：master 节点挂掉后，哨兵进程会主动选举新的 master，可用性高，但是每个节点存储的数据是一样的，浪费内存空间。数据量不是很多，集群规模不是很大，需要自动容错容灾的时候使用。</p><p>Redis cluster 主要是针对海量数据 + 高并发 + 高可用的场景，如果是海量数据，如果你的数据量很大，那么建议就用 Redis cluster，所有 master 的容量总和就是 Redis cluster 可缓存的数据容量。</p><h3 id="2-介绍下redis单副本"><a class="anchor" href="#2-介绍下redis单副本">#</a> 2. 介绍下 Redis 单副本</h3><p>Redis 单副本，采用单个 Redis 节点部署架构，没有备用节点实时同步数据，不提供数据持久化和备份策略，适用于数据可靠性要求不高的纯缓存业务场景。</p><p><img data-src="http://blog-img.coolsen.cn/img/image-20210829103307048.png" alt="image-20210829103307048"></p><p><strong>优点：</strong></p><ul><li>架构简单，部署方便；</li><li>高性价比：缓存使用时无需备用节点（单实例可用性可以用 supervisor 或 crontab 保证），当然为了满足业务的高可用性，也可以牺牲一个备用节点，但同时刻只有一个实例对外提供服务；</li><li>高性能。</li></ul><p><strong>缺点：</strong></p><ul><li>不保证数据的可靠性；</li><li>在缓存使用，进程重启后，数据丢失，即使有备用的节点解决高可用性，但是仍然不能解决缓存预热问题，因此不适用于数据可靠性要求高的业务；</li><li>高性能受限于单核 CPU 的处理能力（Redis 是单线程机制），CPU 为主要瓶颈，所以适合操作命令简单，排序、计算较少的场景。也可以考虑用 Memcached 替代。</li></ul><h3 id="3-介绍下redis多副本主从"><a class="anchor" href="#3-介绍下redis多副本主从">#</a> 3. 介绍下 Redis 多副本（主从）</h3><p>Redis 多副本，采用主从（replication）部署结构，相较于单副本而言最大的特点就是主从实例间数据实时同步，并且提供数据持久化和备份策略。主从实例部署在不同的物理服务器上，根据公司的基础环境配置，可以实现同时对外提供服务和读写分离策略。</p><p><img data-src="http://blog-img.coolsen.cn/img/image-20210829103327631.png" alt="image-20210829103327631"></p><p><strong>优点：</strong></p><ul><li>高可靠性：一方面，采用双机主备架构，能够在主库出现故障时自动进行主备切换，从库提升为主库提供服务，保证服务平稳运行；另一方面，开启数据持久化功能和配置合理的备份策略，能有效的解决数据误操作和数据异常丢失的问题；</li><li>读写分离策略：从节点可以扩展主库节点的读能力，有效应对大并发量的读操作。</li></ul><p><strong>缺点：</strong></p><ul><li>故障恢复复杂，如果没有 RedisHA 系统（需要开发），当主库节点出现故障时，需要手动将一个从节点晋升为主节点，同时需要通知业务方变更配置，并且需要让其它从库节点去复制新主库节点，整个过程需要人为干预，比较繁琐；</li><li>主库的写能力受到单机的限制，可以考虑分片；</li><li>主库的存储能力受到单机的限制，可以考虑 Pika；</li><li>原生复制的弊端在早期的版本中也会比较突出，如：Redis 复制中断后，Slave 会发起 psync，此时如果同步不成功，则会进行全量同步，主库执行全量备份的同时可能会造成毫秒或秒级的卡顿；又由于 COW 机制，导致极端情况下的主库内存溢出，程序异常退出或宕机；主库节点生成备份文件导致服务器磁盘 IO 和 CPU（压缩）资源消耗；发送数 GB 大小的备份文件导致服务器出口带宽暴增，阻塞请求，建议升级到最新版本。</li></ul><h3 id="4-介绍下redis-sentinel哨兵"><a class="anchor" href="#4-介绍下redis-sentinel哨兵">#</a> 4. 介绍下 Redis Sentinel（哨兵）</h3><blockquote><p>主从模式下，当主服务器宕机后，需要手动把一台从服务器切换为主服务器，这就需要人工干预，费事费力，还会造成一段时间内服务不可用。这种方式并不推荐，实际生产中，我们优先考虑哨兵模式。这种模式下，master 宕机，哨兵会自动选举 master 并将其他的 slave 指向新的 master。</p></blockquote><p>Redis Sentinel 是社区版本推出的原生高可用解决方案，其部署架构主要包括两部分：Redis Sentinel 集群和 Redis 数据集群。</p><p>其中 Redis Sentinel 集群是由若干 Sentinel 节点组成的分布式集群，可以实现故障发现、故障自动转移、配置中心和客户端通知。Redis Sentinel 的节点数量要满足 2n+1（n&gt;=1）的奇数个。</p><p><img data-src="http://blog-img.coolsen.cn/img/image-20210829103343110.png" alt="image-20210829103343110"></p><p><strong>优点：</strong></p><ul><li>Redis Sentinel 集群部署简单；</li><li>能够解决 Redis 主从模式下的高可用切换问题；</li><li>很方便实现 Redis 数据节点的线形扩展，轻松突破 Redis 自身单线程瓶颈，可极大满足 Redis 大容量或高性能的业务需求；</li><li>可以实现一套 Sentinel 监控一组 Redis 数据节点或多组数据节点。</li></ul><p><strong>缺点：</strong></p><ul><li>部署相对 Redis 主从模式要复杂一些，原理理解更繁琐；</li><li>资源浪费，Redis 数据节点中 slave 节点作为备份节点不提供服务；</li><li>Redis Sentinel 主要是针对 Redis 数据节点中的主节点的高可用切换，对 Redis 的数据节点做失败判定分为主观下线和客观下线两种，对于 Redis 的从节点有对节点做主观下线操作，并不执行故障转移。</li><li>不能解决读写分离问题，实现起来相对复杂。</li></ul><h3 id="5-介绍下redis-cluster"><a class="anchor" href="#5-介绍下redis-cluster">#</a> 5. 介绍下 Redis Cluster</h3><blockquote><p>Redis 的哨兵模式基本已经可以实现高可用，读写分离 ，但是在这种模式下每台 Redis 服务器都存储相同的数据，很浪费内存，所以在 Redis3.0 上加入了 Cluster 集群模式，实现了 Redis 的分布式存储，对数据进行分片，也就是说每台 Redis 节点上存储不同的内容。</p></blockquote><p>Redis Cluster 是社区版推出的 Redis 分布式集群解决方案，主要解决 Redis 分布式方面的需求，比如，当遇到单机内存，并发和流量等瓶颈的时候，Redis Cluster 能起到很好的负载均衡的目的。</p><p>Redis Cluster 集群节点最小配置 6 个节点以上（3 主 3 从），其中主节点提供读写操作，从节点作为备用节点，不提供请求，只作为故障转移使用。</p><p>Redis Cluster 采用虚拟槽分区，所有的键根据哈希函数映射到 0～16383 个整数槽内，每个节点负责维护一部分槽以及槽所印映射的键值数据。</p><p><img data-src="http://blog-img.coolsen.cn/img/image-20210829103444245.png" alt="image-20210829103444245"></p><p><strong>优点：</strong></p><ul><li>无中心架构；</li><li>数据按照 slot 存储分布在多个节点，节点间数据共享，可动态调整数据分布；</li><li>可扩展性：可线性扩展到 1000 多个节点，节点可动态添加或删除；</li><li>高可用性：部分节点不可用时，集群仍可用。通过增加 Slave 做 standby 数据副本，能够实现故障自动 failover，节点之间通过 gossip 协议交换状态信息，用投票机制完成 Slave 到 Master 的角色提升；</li><li>降低运维成本，提高系统的扩展性和可用性。</li></ul><p><strong>缺点：</strong></p><ul><li>Client 实现复杂，驱动要求实现 Smart Client，缓存 slots mapping 信息并及时更新，提高了开发难度，客户端的不成熟影响业务的稳定性。目前仅 JedisCluster 相对成熟，异常处理部分还不完善，比如常见的 “max redirect exception”。</li><li>节点会因为某些原因发生阻塞（阻塞时间大于 clutser-node-timeout），被判断下线，这种 failover 是没有必要的。</li><li>数据通过异步复制，不保证数据的强一致性。</li><li>多个业务使用同一套集群时，无法根据统计区分冷热数据，资源隔离性较差，容易出现相互影响的情况。</li><li>Slave 在集群中充当 “冷备”，不能缓解读压力，当然可以通过 SDK 的合理设计来提高 Slave 资源的利用率。</li><li>Key 批量操作限制，如使用 mset、mget 目前只支持具有相同 slot 值的 Key 执行批量操作。对于映射为不同 slot 值的 Key 由于 Keys 不支持跨 slot 查询，所以执行 mset、mget、sunion 等操作支持不友好。</li><li>Key 事务操作支持有限，只支持多 key 在同一节点上的事务操作，当多个 Key 分布于不同的节点上时无法使用事务功能。</li><li>Key 作为数据分区的最小粒度，不能将一个很大的键值对象如 hash、list 等映射到不同的节点。</li><li>不支持多数据库空间，单机下的 Redis 可以支持到 16 个数据库，集群模式下只能使用 1 个数据库空间，即 db 0。</li><li>复制结构只支持一层，从节点只能复制主节点，不支持嵌套树状复制结构。</li><li>避免产生 hot-key，导致主库节点成为系统的短板。</li><li>避免产生 big-key，导致网卡撑爆、慢查询等。</li><li>重试时间应该大于 cluster-node-time 时间。</li><li>Redis Cluster 不建议使用 pipeline 和 multi-keys 操作，减少 max redirect 产生的场景。</li></ul><h3 id="6-介绍下redis自研"><a class="anchor" href="#6-介绍下redis自研">#</a> 6. 介绍下 Redis 自研</h3><p>Redis 自研的高可用解决方案，主要体现在配置中心、故障探测和 failover 的处理机制上，通常需要根据企业业务的实际线上环境来定制化。</p><p><img data-src="http://blog-img.coolsen.cn/img/image-20210829103426922.png" alt="image-20210829103426922"></p><p><strong>优点：</strong></p><ul><li>高可靠性、高可用性；</li><li>自主可控性高；</li><li>贴切业务实际需求，可缩性好，兼容性好。</li></ul><p><strong>缺点：</strong></p><ul><li>实现复杂，开发成本高；</li><li>需要建立配套的周边设施，如监控，域名服务，存储元数据信息的数据库等；</li><li>维护成本高。</li></ul><h3 id="7-redis高可用方案具体怎么实施"><a class="anchor" href="#7-redis高可用方案具体怎么实施">#</a> 7. Redis 高可用方案具体怎么实施？</h3><p>使用官方推荐的哨兵 (sentinel) 机制就能实现，当主节点出现故障时，由 Sentinel 自动完成故障发现和转移，并通知应用方，实现高可用性。它有四个主要功能：</p><ul><li>集群监控，负责监控 Redis master 和 slave 进程是否正常工作。</li><li>消息通知，如果某个 Redis 实例有故障，那么哨兵负责发送消息作为报警通知给管理员。</li><li>故障转移，如果 master node 挂掉了，会自动转移到 slave node 上。</li><li>配置中心，如果故障转移发生了，通知 client 客户端新的 master 地址。</li></ul><h3 id="8-了解主从复制的原理吗"><a class="anchor" href="#8-了解主从复制的原理吗">#</a> 8. 了解主从复制的原理吗？</h3><p><strong>1、主从架构的核心原理</strong></p><p>当启动一个 slave node 的时候，它会发送一个 PSYNC 命令给 master node</p><p>如果这是 slave node 重新连接 master node，那么 master node 仅仅会复制给 slave 部分缺少的数据；否则如果是 slave node 第一次连接 master node，那么会触发一次 full resynchronization</p><p>开始 full resynchronization 的时候，master 会启动一个后台线程，开始生成一份 RDB 快照文件，同时还会将从客户端收到的所有写命令缓存在内存中。RDB 文件生成完毕之后，master 会将这个 RDB 发送给 slave，slave 会先写入本地磁盘，然后再从本地磁盘加载到内存中。然后 master 会将内存中缓存的写命令发送给 slave，slave 也会同步这些数据。</p><p>slave node 如果跟 master node 有网络故障，断开了连接，会自动重连。master 如果发现有多个 slave node 都来重新连接，仅仅会启动一个 rdb save 操作，用一份数据服务所有 slave node。</p><p><strong>2、主从复制的断点续传</strong></p><p>从 Redis 2.8 开始，就支持主从复制的断点续传，如果主从复制过程中，网络连接断掉了，那么可以接着上次复制的地方，继续复制下去，而不是从头开始复制一份</p><p>master node 会在内存中常见一个 backlog，master 和 slave 都会保存一个 replica offset 还有一个 master id，offset 就是保存在 backlog 中的。如果 master 和 slave 网络连接断掉了，slave 会让 master 从上次的 replica offset 开始继续复制</p><p>但是如果没有找到对应的 offset，那么就会执行一次 resynchronization</p><p><strong>3、无磁盘化复制</strong></p><p>master 在内存中直接创建 rdb，然后发送给 slave，不会在自己本地落地磁盘了</p><p>repl-diskless-sync repl-diskless-sync-delay，等待一定时长再开始复制，因为要等更多 slave 重新连接过来</p><p><strong>4、过期 key 处理</strong></p><p>slave 不会过期 key，只会等待 master 过期 key。如果 master 过期了一个 key，或者通过 LRU 淘汰了一个 key，那么会模拟一条 del 命令发送给 slave。</p><h3 id="9-由于主从延迟导致读取到过期数据怎么处理"><a class="anchor" href="#9-由于主从延迟导致读取到过期数据怎么处理">#</a> 9. 由于主从延迟导致读取到过期数据怎么处理？</h3><ol><li>通过 scan 命令扫库：当 Redis 中的 key 被 scan 的时候，相当于访问了该 key，同样也会做过期检测，充分发挥 Redis 惰性删除的策略。这个方法能大大降低了脏数据读取的概率，但缺点也比较明显，会造成一定的数据库压力，否则影响线上业务的效率。</li><li>Redis 加入了一个新特性来解决主从不一致导致读取到过期数据问题，增加了 key 是否过期以及对主从库的判断，如果 key 已过期，当前访问的 master 则返回 null；当前访问的是从库，且执行的是只读命令也返回 null。</li></ol><h3 id="10-主从复制的过程中如果因为网络原因停止复制了会怎么样"><a class="anchor" href="#10-主从复制的过程中如果因为网络原因停止复制了会怎么样">#</a> 10. 主从复制的过程中如果因为网络原因停止复制了会怎么样？</h3><p>如果出现网络故障断开连接了，会自动重连的，从 Redis 2.8 开始，就支持主从复制的断点续传，可以接着上次复制的地方，继续复制下去，而不是从头开始复制一份。</p><p>master 如果发现有多个 slave node 都来重新连接，仅仅会启动一个 rdb save 操作，用一份数据服务所有 slave node。</p><p>master node 会在内存中创建一个 <code>backlog</code> ，master 和 slave 都会保存一个 <code>replica offset</code> ，还有一个 <code>master id</code> ，offset 就是保存在 backlog 中的。如果 master 和 slave 网络连接断掉了，slave 会让 master 从上次的 replica offset 开始继续复制。</p><p>但是如果没有找到对应的 offset，那么就会执行一次 <code>resynchronization</code> 全量复制。</p><h3 id="11-redis主从架构数据会丢失吗为什么"><a class="anchor" href="#11-redis主从架构数据会丢失吗为什么">#</a> 11. Redis 主从架构数据会丢失吗，为什么？</h3><p>有两种数据丢失的情况：</p><ol><li>异步复制导致的数据丢失：因为 master -&gt; slave 的复制是异步的，所以可能有部分数据还没复制到 slave，master 就宕机了，此时这些部分数据就丢失了。</li><li>脑裂导致的数据丢失：某个 master 所在机器突然脱离了正常的网络，跟其他 slave 机器不能连接，但是实际上 master 还运行着，此时哨兵可能就会认为 master 宕机了，然后开启选举，将其他 slave 切换成了 master。这个时候，集群里就会有两个 master，也就是所谓的脑裂。此时虽然某个 slave 被切换成了 master，但是可能 client 还没来得及切换到新的 master，还继续写向旧 master 的数据可能也丢失了。因此旧 master 再次恢复的时候，会被作为一个 slave 挂到新的 master 上去，自己的数据会清空，重新从新的 master 复制数据。</li></ol><h3 id="12-如何解决主从架构数据丢失的问题"><a class="anchor" href="#12-如何解决主从架构数据丢失的问题">#</a> 12. 如何解决主从架构数据丢失的问题？</h3><p>数据丢失的问题是不可避免的，但是我们可以尽量减少。</p><p>在 Redis 的配置文件里设置参数</p><figure class="highlight text"><figcaption data-lang="text"></figcaption><table><tr><td data-num="1"></td><td><pre>min-slaves-to-write 1</pre></td></tr><tr><td data-num="2"></td><td><pre>min-slaves-max-lag 10</pre></td></tr></table></figure><p><code>min-slaves-to-write</code> 默认情况下是 0， <code>min-slaves-max-lag</code> 默认情况下是 10。</p><p>上面的配置的意思是要求至少有 1 个 slave，数据复制和同步的延迟不能超过 10 秒。如果说一旦所有的 slave，数据复制和同步的延迟都超过了 10 秒钟，那么这个时候，master 就不会再接收任何请求了。</p><p>减小 <code>min-slaves-max-lag</code> 参数的值，这样就可以避免在发生故障时大量的数据丢失，一旦发现延迟超过了该值就不会往 master 中写入数据。</p><p>那么对于 client，我们可以采取降级措施，将数据暂时写入本地缓存和磁盘中，在一段时间后重新写入 master 来保证数据不丢失；也可以将数据写入 kafka 消息队列，隔一段时间去消费 kafka 中的数据。</p><h3 id="13-redis哨兵是怎么工作的"><a class="anchor" href="#13-redis哨兵是怎么工作的">#</a> 13. Redis 哨兵是怎么工作的？</h3><ol><li>每个 Sentinel 以每秒钟一次的频率向它所知的 Master，Slave 以及其他 Sentinel 实例发送一个 PING 命令。</li><li>如果一个实例（instance）距离最后一次有效回复 PING 命令的时间超过 down-after-milliseconds 选项所指定的值， 则这个实例会被当前 Sentinel 标记为主观下线。</li><li>如果一个 Master 被标记为主观下线，则正在监视这个 Master 的所有 Sentinel 要以每秒一次的频率确认 Master 的确进入了主观下线状态。</li><li>当有足够数量的 Sentinel（大于等于配置文件指定的值）在指定的时间范围内确认 Master 的确进入了主观下线状态， 则 Master 会被标记为客观下线 。</li><li>当 Master 被 Sentinel 标记为客观下线时，Sentinel 向下线的 Master 的所有 Slave 发送 INFO 命令的频率会从 10 秒一次改为每秒一次 （在一般情况下， 每个 Sentinel 会以每 10 秒一次的频率向它已知的所有 Master，Slave 发送 INFO 命令 ）。</li><li>若没有足够数量的 Sentinel 同意 Master 已经下线， Master 的客观下线状态就会变成主观下线。若 Master 重新向 Sentinel 的 PING 命令返回有效回复， Master 的主观下线状态就会被移除。</li><li>sentinel 节点会与其他 sentinel 节点进行 “沟通”，投票选举一个 sentinel 节点进行故障处理，在从节点中选取一个主节点，其他从节点挂载到新的主节点上自动复制新主节点的数据。</li></ol><h3 id="14-故障转移时会从剩下的slave选举一个新的master被选举为master的标准是什么"><a class="anchor" href="#14-故障转移时会从剩下的slave选举一个新的master被选举为master的标准是什么">#</a> 14. 故障转移时会从剩下的 slave 选举一个新的 master，被选举为 master 的标准是什么？</h3><p>如果一个 master 被认为 odown 了，而且 majority 哨兵都允许了主备切换，那么某个哨兵就会执行主备切换操作，此时首先要选举一个 slave 来，会考虑 slave 的一些信息。</p><ul><li>跟 master 断开连接的时长。 如果一个 slave 跟 master 断开连接已经超过了 down-after-milliseconds 的 10 倍，外加 master 宕机的时长，那么 slave 就被认为不适合选举为 master.</li></ul><figure class="highlight text"><figcaption data-lang="text"></figcaption><table><tr><td data-num="1"></td><td><pre>( down-after-milliseconds * 10) + milliseconds_since_master_is_in_SDOWN_state</pre></td></tr></table></figure><ul><li>slave 优先级。 按照 slave 优先级进行排序，slave priority 越低，优先级就越高</li><li>复制 offset。 如果 slave priority 相同，那么看 replica offset，哪个 slave 复制了越多的数据，offset 越靠后，优先级就越高</li><li>run id 如果上面两个条件都相同，那么选择一个 run id 比较小的那个 slave。</li></ul><h3 id="15-同步配置的时候其他哨兵根据什么更新自己的配置呢"><a class="anchor" href="#15-同步配置的时候其他哨兵根据什么更新自己的配置呢">#</a> 15. 同步配置的时候其他哨兵根据什么更新自己的配置呢？</h3><p>执行切换的那个哨兵，会从要切换到的新 master（salve-&gt;master）那里得到一个 configuration epoch，这就是一个 version 号，每次切换的 version 号都必须是唯一的。</p><p>如果第一个选举出的哨兵切换失败了，那么其他哨兵，会等待 failover-timeout 时间，然后接替继续执行切换，此时会重新获取一个新的 configuration epoch 作为新的 version 号。</p><p>这个 version 号就很重要了，因为各种消息都是通过一个 channel 去发布和监听的，所以一个哨兵完成一次新的切换之后，新的 master 配置是跟着新的 version 号的，其他的哨兵都是根据版本号的大小来更新自己的 master 配置的。</p><h3 id="16-为什么redis哨兵集群只有2个节点无法正常工作"><a class="anchor" href="#16-为什么redis哨兵集群只有2个节点无法正常工作">#</a> 16. 为什么 Redis 哨兵集群只有 2 个节点无法正常工作？</h3><p>哨兵集群必须部署 2 个以上节点。</p><p>如果两个哨兵实例，即两个 Redis 实例，一主一从的模式。</p><p>则 Redis 的配置 quorum=1，表示一个哨兵认为 master 宕机即可认为 master 已宕机。</p><p>但是如果是机器 1 宕机了，那哨兵 1 和 master 都宕机了，虽然哨兵 2 知道 master 宕机了，但是这个时候，需要 majority，也就是大多数哨兵都是运行的，2 个哨兵的 majority 就是 2（2 的 majority=2，3 的 majority=2，5 的 majority=3，4 的 majority=2），2 个哨兵都运行着，就可以允许执行故障转移。</p><p>但此时哨兵 1 没了就只有 1 个哨兵了了，此时就没有 majority 来允许执行故障转移，所以故障转移不会执行。</p><h3 id="17-redis-cluster中是如何实现数据分布的这种方式有什么优点"><a class="anchor" href="#17-redis-cluster中是如何实现数据分布的这种方式有什么优点">#</a> 17. Redis cluster 中是如何实现数据分布的？这种方式有什么优点？</h3><p>Redis cluster 有固定的 16384 个 hash slot（哈希槽），对每个 key 计算 CRC16 值，然后对 16384 取模，可以获取 key 对应的 hash slot。</p><p>Redis cluster 中每个 master 都会持有部分 slot（槽），比如有 3 个 master，那么可能每个 master 持有 5000 多个 hash slot。</p><p>hash slot 让 node 的增加和移除很简单，增加一个 master，就将其他 master 的 hash slot 移动部分过去，减少一个 master，就将它的 hash slot 移动到其他 master 上去。每次增加或减少 master 节点都是对 16384 取模，而不是根据 master 数量，这样原本在老的 master 上的数据不会因 master 的新增或减少而找不到。并且增加或减少 master 时 Redis cluster 移动 hash slot 的成本是非常低的。</p><h3 id="18-redis-cluster节点间通信是什么机制"><a class="anchor" href="#18-redis-cluster节点间通信是什么机制">#</a> 18. Redis cluster 节点间通信是什么机制？</h3><p>Redis cluster 节点间采取 gossip 协议进行通信，所有节点都持有一份元数据，不同的节点如果出现了元数据的变更之后 U 不断地 i 将元数据发送给其他节点让其他节点进行数据变更。</p><blockquote><p>节点互相之间不断通信，保持整个集群所有节点的数据是完整的。 主要交换故障信息、节点的增加和移除、hash slot 信息等。</p></blockquote><p>这种机制的好处在于，元数据的更新比较分散，不是集中在一个地方，更新请求会陆陆续续，打到所有节点上去更新，有一定的延时，降低了压力；</p><p>缺点，元数据更新有延时，可能导致集群的一些操作会有一些滞后。</p><h2 id="分布式问题"><a class="anchor" href="#分布式问题">#</a> 分布式问题</h2><h3 id="1-什么是分布式锁为什么用分布式锁"><a class="anchor" href="#1-什么是分布式锁为什么用分布式锁">#</a> 1. 什么是分布式锁？为什么用分布式锁？</h3><p>锁在程序中的作用就是同步工具，保证共享资源在同一时刻只能被一个线程访问，Java 中的锁我们都很熟悉了，像 synchronized 、Lock 都是我们经常使用的，但是 Java 的锁只能保证单机的时候有效，分布式集群环境就无能为力了，这个时候我们就需要用到分布式锁。</p><p>分布式锁，顾名思义，就是分布式项目开发中用到的锁，可以用来控制分布式系统之间同步访问共享资源。</p><p>思路是：在整个系统提供一个<strong>全局、唯一</strong>的获取锁的 “东西”，然后每个系统在需要加锁时，都去问这个 “东西” 拿到一把锁，这样不同的系统拿到的就可以认为是同一把锁。至于这个 “东西”，可以是 Redis、Zookeeper，也可以是数据库。</p><p>一般来说，分布式锁需要满足的特性有这么几点：</p><p>1、互斥性：在任何时刻，对于同一条数据，只有一台应用可以获取到分布式锁；</p><p>2、高可用性：在分布式场景下，一小部分服务器宕机不影响正常使用，这种情况就需要将提供分布式锁的服务以集群的方式部署；</p><p>3、防止锁超时：如果客户端没有主动释放锁，服务器会在一段时间之后自动释放锁，防止客户端宕机或者网络不可达时产生死锁；</p><p>4、独占性：加锁解锁必须由同一台服务器进行，也就是锁的持有者才可以释放锁，不能出现你加的锁，别人给你解锁了。</p><h3 id="2-常见的分布式锁有哪些解决方案"><a class="anchor" href="#2-常见的分布式锁有哪些解决方案">#</a> 2. 常见的分布式锁有哪些解决方案？</h3><p>实现分布式锁目前有三种流行方案，即基于关系型数据库、Redis、ZooKeeper 的方案</p><p>1、基于关系型数据库，如 MySQL 基于关系型数据库实现分布式锁，是依赖数据库的唯一性来实现资源锁定，比如主键和唯一索引等。</p><p>缺点：</p><ul><li>这把锁强依赖数据库的可用性，数据库是一个单点，一旦数据库挂掉，会导致业务系统不可用。</li><li>这把锁没有失效时间，一旦解锁操作失败，就会导致锁记录一直在数据库中，其他线程无法再获得到锁。</li><li>这把锁只能是非阻塞的，因为数据的 insert 操作，一旦插入失败就会直接报错。没有获得锁的线程并不会进入排队队列，要想再次获得锁就要再次触发获得锁操作。</li><li>这把锁是非重入的，同一个线程在没有释放锁之前无法再次获得该锁。因为数据中数据已经存在了。</li></ul><p>2、基于 Redis 实现</p><p>优点：</p><p>Redis 锁实现简单，理解逻辑简单，性能好，可以支撑高并发的获取、释放锁操作。</p><p>缺点：</p><ul><li>Redis 容易单点故障，集群部署，并不是强一致性的，锁的不够健壮；</li><li>key 的过期时间设置多少不明确，只能根据实际情况调整；</li><li>需要自己不断去尝试获取锁，比较消耗性能。</li></ul><p>3、基于 zookeeper</p><p>优点：</p><p>zookeeper 天生设计定位就是分布式协调，强一致性，锁很健壮。如果获取不到锁，只需要添加一个监听器就可以了，不用一直轮询，性能消耗较小。</p><p>缺点：</p><p>在高请求高并发下，系统疯狂的加锁释放锁，最后 zk 承受不住这么大的压力可能会存在宕机的风险。</p><h3 id="3-redis实现分布式锁"><a class="anchor" href="#3-redis实现分布式锁">#</a> 3. Redis 实现分布式锁</h3><p><strong>分布式锁的三个核心要素</strong></p><p>1、加锁</p><p>使用 setnx 来加锁。key 是锁的唯一标识，按业务来决定命名，value 这里设置为 test。</p><figure class="highlight text"><figcaption data-lang="text"></figcaption><table><tr><td data-num="1"></td><td><pre>setx key test</pre></td></tr></table></figure><p>当一个线程执行 setnx 返回 1，说明 key 原本不存在，该线程成功得到了锁；当一个线程执行 setnx 返回 0，说明 key 已经存在，该线程抢锁失败；</p><p>2、解锁</p><p>有加锁就得有解锁。当得到的锁的线程执行完任务，需要释放锁，以便其他线程可以进入。释放锁的最简单方式就是执行 del 指令。</p><figure class="highlight text"><figcaption data-lang="text"></figcaption><table><tr><td data-num="1"></td><td><pre>del key</pre></td></tr></table></figure><p>释放锁之后，其他线程就可以继续执行 setnx 命令来获得锁。</p><p>3、锁超时</p><p>锁超时知道的是：如果一个得到锁的线程在执行任务的过程中挂掉，来不及显式地释放锁，这块资源将会永远被锁住，别的线程北向进来。</p><p>所以，setnx 的 key 必须设置一个超时时间，以保证即使没有被显式释放，这把锁也要在一段时间后自动释放。setnx 不支持超时参数，所以需要额外指令，</p><figure class="highlight text"><figcaption data-lang="text"></figcaption><table><tr><td data-num="1"></td><td><pre>expire key 30</pre></td></tr></table></figure><p><strong>上述分布式锁存在的问题</strong></p><p><strong>通过上述 <code>setnx</code> 、 <code>del</code> 和 <code>expire</code> 实现的分布式锁还是存在着一些问题。</strong></p><p>1、SETNX 和 EXPIRE 非原子性</p><p>假设一个场景中，某一个线程刚执行 setnx，成功得到了锁。此时 setnx 刚执行成功，还未来得及执行 expire 命令，节点就挂掉了。此时这把锁就没有设置过期时间，别的线程就再也无法获得该锁。</p><p><strong>解决措施:</strong></p><p>由于 <code>setnx</code> 指令本身是不支持传入超时时间的，而在 Redis2.6.12 版本上为 <code>set</code> 指令增加了可选参数，用法如下：</p><figure class="highlight text"><figcaption data-lang="text"></figcaption><table><tr><td data-num="1"></td><td><pre>SET key value [EX seconds][PX milliseconds] [NX|XX]</pre></td></tr></table></figure><ul><li>EX second: 设置键的过期时间为 second 秒；</li><li>PX millisecond：设置键的过期时间为 millisecond 毫秒；</li><li>NX：只在键不存在时，才对键进行设置操作；</li><li>XX：只在键已经存在时，才对键进行设置操作；</li><li>SET 操作完成时，返回 OK，否则返回 nil。</li></ul><p>2、锁误解除</p><p>如果线程 A 成功获取到了锁，并且设置了过期时间 30 秒，但线程 A 执行时间超过了 30 秒，锁过期自动释放，此时线程 B 获取到了锁；随后 A 执行完成，线程 A 使用 DEL 命令来释放锁，但此时线程 B 加的锁还没有执行完成，线程 A 实际释放的线程 B 加的锁。</p><p><strong>解决办法：</strong></p><p>在 del 释放锁之前加一个判断，验证当前的锁是不是自己加的锁。</p><p>具体在加锁的时候把当前线程的 id 当做 value，可生成一个 UUID 标识当前线程，在删除之前验证 key 对应的 value 是不是自己线程的 id。</p><p>还可以使用 lua 脚本做验证标识和解锁操作。</p><p>3、超时解锁导致并发</p><p>如果线程 A 成功获取锁并设置过期时间 30 秒，但线程 A 执行时间超过了 30 秒，锁过期自动释放，此时线程 B 获取到了锁，线程 A 和线程 B 并发执行。</p><p>A、B 两个线程发生并发显然是不被允许的，一般有两种方式解决该问题：</p><ul><li>将过期时间设置足够长，确保代码逻辑在锁释放之前能够执行完成。</li><li>为获取锁的线程增加守护线程，为将要过期但未释放的锁增加有效时间。</li></ul><p>4、不可重入</p><p>当线程在持有锁的情况下再次请求加锁，如果一个锁支持一个线程多次加锁，那么这个锁就是可重入的。如果一个不可重入锁被再次加锁，由于该锁已经被持有，再次加锁会失败。Redis 可通过对锁进行重入计数，加锁时加 1，解锁时减 1，当计数归 0 时释放锁。</p><p>5、无法等待锁释放</p><p>上述命令执行都是立即返回的，如果客户端可以等待锁释放就无法使用。</p><ul><li>可以通过客户端轮询的方式解决该问题，当未获取到锁时，等待一段时间重新获取锁，直到成功获取锁或等待超时。这种方式比较消耗服务器资源，当并发量比较大时，会影响服务器的效率。</li><li>另一种方式是使用 Redis 的发布订阅功能，当获取锁失败时，订阅锁释放消息，获取锁成功后释放时，发送锁释放消息。</li></ul><p>具体实现参考：<span class="exturl" data-url="aHR0cHM6Ly94aWFvbWktaW5mby5naXRodWIuaW8vMjAxOS8xMi8xNy9SZWRpcy1kaXN0cmlidXRlZC1sb2NrLw==">https://xiaomi-info.github.io/2019/12/17/Redis-distributed-lock/</span></p><h3 id="4-了解redlock吗"><a class="anchor" href="#4-了解redlock吗">#</a> 4. 了解 RedLock 吗？</h3><p>Redlock 是一种算法，Redlock 也就是 Redis Distributed Lock，可用实现多节点 Redis 的分布式锁。</p><p>RedLock 官方推荐，Redisson 完成了对 Redlock 算法封装。</p><p>此种方式具有以下特性：</p><ul><li>互斥访问：即永远只有一个 client 能拿到锁</li><li>避免死锁：最终 client 都可能拿到锁，不会出现死锁的情况，即使锁定资源的服务崩溃或者分区，仍然能释放锁。</li><li>容错性：只要大部分 Redis 节点存活（一半以上），就可以正常提供服务</li></ul><h3 id="5-redlock的原理"><a class="anchor" href="#5-redlock的原理">#</a> 5. RedLock 的原理</h3><p>假设有 5 个完全独立的 Redis 主服务器</p><ol><li>获取当前时间戳</li><li>client 尝试按照顺序使用相同的 key,value 获取所有 Redis 服务的锁，在获取锁的过程中的获取时间比锁过期时间短很多，这是为了不要过长时间等待已经关闭的 Redis 服务。并且试着获取下一个 Redis 实例。</li></ol><p>比如：TTL 为 5s, 设置获取锁最多用 1s，所以如果一秒内无法获取锁，就放弃获取这个锁，从而尝试获取下个锁</p><ol><li>client 通过获取所有能获取的锁后的时间减去第一步的时间，这个时间差要小于 TTL 时间并且至少有 3 个 Redis 实例成功获取锁，才算真正的获取锁成功</li><li>如果成功获取锁，则锁的真正有效时间是 TTL 减去第三步的时间差 的时间；比如：TTL 是 5s, 获取所有锁用了 2s, 则真正锁有效时间为 3s (其实应该再减去时钟漂移);</li><li>如果客户端由于某些原因获取锁失败，便会开始解锁所有 Redis 实例；因为可能已经获取了小于 3 个锁，必须释放，否则影响其他 client 获取锁</li></ol><p>算法示意图如下：</p><p><img data-src="http://blog-img.coolsen.cn/img/image-20210829131128229.png" alt="image-20210829131128229"></p><h2 id="其他"><a class="anchor" href="#其他">#</a> 其他</h2><h3 id="1-redis如何做内存优化"><a class="anchor" href="#1-redis如何做内存优化">#</a> 1. Redis 如何做内存优化？</h3><ul><li><strong>控制 key 的数量</strong>。当使用 Redis 存储大量数据时，通常会存在大量键，过多的键同样会消耗大量内存。Redis 本质是一个数据结构服务器，它为我们提供多种数据结构，如 hash，list，set，zset 等结构。使用 Redis 时不要进入一个误区，大量使用 get/set 这样的 API，把 Redis 当成 Memcached 使用。对于存储相同的数据内容利用 Redis 的数据结构降低外层键的数量，也可以节省大量内存。</li><li><strong>缩减键值对象</strong>，降低 Redis 内存使用最直接的方式就是缩减键（key）和值（value）的长度。<ul><li>key 长度：如在设计键时，在完整描述业务情况下，键值越短越好。</li><li>value 长度：值对象缩减比较复杂，常见需求是把业务对象序列化成二进制数组放入 Redis。首先应该在业务上精简业务对象，去掉不必要的属性避免存储无效数据。其次在序列化工具选择上，应该选择更高效的序列化工具来降低字节数组大小。</li></ul></li><li><strong>编码优化</strong>。Redis 对外提供了 string,list,hash,set,zet 等类型，但是 Redis 内部针对不同类型存在编码的概念，所谓编码就是具体使用哪种底层数据结构来实现。编码不同将直接影响数据的内存占用和读写效率。可参考文章：<span class="exturl" data-url="aHR0cHM6Ly9jbG91ZC50ZW5jZW50LmNvbS9kZXZlbG9wZXIvYXJ0aWNsZS8xMTYyMjEz">https://cloud.tencent.com/developer/article/1162213</span></li></ul><h3 id="2-如果现在有个读超高并发的系统用redis来抗住大部分读请求你会怎么设计"><a class="anchor" href="#2-如果现在有个读超高并发的系统用redis来抗住大部分读请求你会怎么设计">#</a> 2. 如果现在有个读超高并发的系统，用 Redis 来抗住大部分读请求，你会怎么设计？</h3><p>如果是读高并发的话，先看读并发的数量级是多少，因为 Redis 单机的读 QPS 在万级，每秒几万没问题，使用一主多从 + 哨兵集群的缓存架构来承载每秒 10W + 的读并发，主从复制，读写分离。</p><p>使用哨兵集群主要是提高缓存架构的可用性，解决单点故障问题。主库负责写，多个从库负责读，支持水平扩容，根据读请求的 QPS 来决定加多少个 Redis 从实例。如果读并发继续增加的话，只需要增加 Redis 从实例就行了。</p><p>如果需要缓存 1T + 的数据，选择 Redis cluster 模式，每个主节点存一部分数据，假设一个 master 存 32G，那只需要 n*32G&gt;=1T，n 个这样的 master 节点就可以支持 1T + 的海量数据的存储了。</p><blockquote><p>Redis 单主的瓶颈不在于读写的并发，而在于内存容量，即使是一主多从也是不能解决该问题，因为一主多从架构下，多个 slave 的数据和 master 的完全一样。假如 master 是 10G 那 slave 也只能存 10G 数据。所以数据量受单主的影响。 而这个时候又需要缓存海量数据，那就必须得有多主了，并且多个主保存的数据还不能一样。Redis 官方给出的 Redis cluster 模式完美的解决了这个问题。</p></blockquote><div class="tags"><a href="/tags/Redis/" rel="tag"><i class="ic i-tag"></i>Redis</a></div></div><footer><div class="meta"><span class="icon"><i class="ic i-eye"></i></span><span>此文章已被阅读次数:</span><span class="waline-pageview-count" id="twikoo_visitors" data-path="2023/10/22/database/no-sql/redis/Java面试题-07-Redis/">正在加载...</span><span class="item"><span class="icon"><i class="ic i-calendar-check"></i></span><span class="text">更新于</span><time title="修改时间：2023-10-30 10:42:30" itemprop="dateModified" datetime="2023-10-30T10:42:30+08:00">2023-10-30</time></span></div><div class="reward"><button><i class="ic i-heartbeat"></i>赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/assets/wechatpay.png" alt="biya 微信支付"><p>微信支付</p></div><div><img data-src="/assets/alipay.png" alt="biya 支付宝"><p>支付宝</p></div><div><img data-src="/assets/paypal.png" alt="biya 贝宝"><p>贝宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者：</strong>biya<i class="ic i-at"><em>@</em></i>夢のない賢魚です</li><li class="link"><strong>本文链接：</strong><a href="https://sbysg.github.io/2023/10/22/database/no-sql/redis/Java%E9%9D%A2%E8%AF%95%E9%A2%98-07-Redis/" title="redis">https://sbysg.github.io/2023/10/22/database/no-sql/redis/Java面试题-07-Redis/</a></li><li class="license"><strong>版权声明：</strong>本站所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2023/10/22/database/sql/mysql/Java%E9%9D%A2%E8%AF%95%E9%A2%98-06-Mysql%E7%AF%87/" rel="prev" itemprop="url" data-background-image="https:&#x2F;&#x2F;tva4.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1giclfb3vzhj20zk0m8wny.jpg" title="mysql"><span class="type">上一篇</span><span class="category"><i class="ic i-flag"></i>数据库</span><h3>mysql</h3></a></div><div class="item right"><a href="/2023/10/22/third-apis/minio/%E4%B8%8A%E9%97%A8%E5%85%BB%E8%80%81-%E6%B3%A8%E5%86%8C%E5%8A%9F%E8%83%BD-%E7%9F%AD%E4%BF%A1/" rel="next" itemprop="url" data-background-image="https:&#x2F;&#x2F;tva4.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1gipeybxm1pj20zk0m8niv.jpg" title="sms"><span class="type">下一篇</span><span class="category"><i class="ic i-flag"></i>第三方api</span><h3>sms</h3></a></div></div><div class="wrap" id="wcomments"></div><script type="module" data-pjax="data-pjax">import { init } from 'https://unpkg.com/@waline/client@v2/dist/waline.mjs';

setTimeout(function () {
    init({
        el: '#wcomments',
        serverURL: 'waline-biya.vercel.app',
        lang: 'zh-CN',
        locale: {},
        emoji: ["https://unpkg.com/@waline/emojis@1.0.1/weibo","https://unpkg.com/@waline/emojis@1.0.1/alus","https://unpkg.com/@waline/emojis@1.0.1/bilibili","https://unpkg.com/@waline/emojis@1.0.1/qq","https://unpkg.com/@waline/emojis@1.0.1/tieba","https://unpkg.com/@waline/emojis@1.0.1/tw-emoji"],
        meta: ["nick","mail","link"],
        requiredMeta: ["nick","mail"],
        wordLimit: 0,
        pageSize: 10,
        pageview: true,
        path: window.location.pathname,
        dark: 'html[data-theme="dark"]'
    });
}, 1000)</script></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#java%E9%9D%A2%E8%AF%95%E9%A2%98-redis"><span class="toc-number">1.</span> <span class="toc-text">Java 面试题 - Redis</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#redis"><span class="toc-number">1.1.</span> <span class="toc-text">Redis</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-redis%E6%98%AF%E4%BB%80%E4%B9%88%E7%AE%80%E8%BF%B0%E5%AE%83%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">1.1.1.</span> <span class="toc-text">1. Redis 是什么？简述它的优缺点？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-redis%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%BF%AB"><span class="toc-number">1.1.2.</span> <span class="toc-text">2. Redis 为什么这么快？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-redis%E7%9B%B8%E6%AF%94memcached%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BC%98%E5%8A%BF"><span class="toc-number">1.1.3.</span> <span class="toc-text">3. Redis 相比 Memcached 有哪些优势？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8-redis-%E5%81%9A%E7%BC%93%E5%AD%98"><span class="toc-number">1.1.4.</span> <span class="toc-text">4. 为什么要用 Redis 做缓存？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8-redis-%E8%80%8C%E4%B8%8D%E7%94%A8-mapguava-%E5%81%9A%E7%BC%93%E5%AD%98"><span class="toc-number">1.1.5.</span> <span class="toc-text">5. 为什么要用 Redis 而不用 map&#x2F;guava 做缓存？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-redis%E7%9A%84%E5%B8%B8%E7%94%A8%E5%9C%BA%E6%99%AF%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">1.1.6.</span> <span class="toc-text">6. Redis 的常用场景有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-redis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">1.1.7.</span> <span class="toc-text">7. Redis 的数据类型有哪些？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">1.2.</span> <span class="toc-text">持久化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-redis%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6"><span class="toc-number">1.2.1.</span> <span class="toc-text">1. Redis 持久化机制？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96%E6%96%B9%E5%BC%8F"><span class="toc-number">1.2.2.</span> <span class="toc-text">2. 如何选择合适的持久化方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-redis%E6%8C%81%E4%B9%85%E5%8C%96%E6%95%B0%E6%8D%AE%E5%92%8C%E7%BC%93%E5%AD%98%E6%80%8E%E4%B9%88%E5%81%9A%E6%89%A9%E5%AE%B9"><span class="toc-number">1.2.3.</span> <span class="toc-text">3. Redis 持久化数据和缓存怎么做扩容？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%87%E6%9C%9F%E9%94%AE%E7%9A%84%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5-%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5"><span class="toc-number">1.3.</span> <span class="toc-text">过期键的删除策略、淘汰策略</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-redis%E8%BF%87%E6%9C%9F%E9%94%AE%E7%9A%84%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5"><span class="toc-number">1.3.1.</span> <span class="toc-text">1. Redis 过期键的删除策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-redis-key%E7%9A%84%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4%E5%92%8C%E6%B0%B8%E4%B9%85%E6%9C%89%E6%95%88%E5%88%86%E5%88%AB%E6%80%8E%E4%B9%88%E8%AE%BE%E7%BD%AE"><span class="toc-number">1.3.2.</span> <span class="toc-text">2. Redis key 的过期时间和永久有效分别怎么设置？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-redis%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5"><span class="toc-number">1.3.3.</span> <span class="toc-text">3. Redis 内存淘汰策略</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E5%BC%82%E5%B8%B8"><span class="toc-number">1.4.</span> <span class="toc-text">缓存异常</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E7%BC%93%E5%AD%98%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8F%8C%E5%86%99%E6%97%B6%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-number">1.4.1.</span> <span class="toc-text">1. 如何保证缓存与数据库双写时的数据一致性？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%85%88%E5%88%A0%E9%99%A4%E7%BC%93%E5%AD%98%E5%90%8E%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">1.4.2.</span> <span class="toc-text">2. 先删除缓存，后更新数据库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%85%88%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E5%BA%93%E5%90%8E%E5%88%A0%E9%99%A4%E7%BC%93%E5%AD%98"><span class="toc-number">1.4.3.</span> <span class="toc-text">3. 先更新数据库，后删除缓存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF"><span class="toc-number">1.4.4.</span> <span class="toc-text">4. 什么是缓存击穿？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="toc-number">1.4.5.</span> <span class="toc-text">5. 什么是缓存穿透？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="toc-number">1.4.6.</span> <span class="toc-text">6. 什么是缓存雪崩？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%AD%98%E9%A2%84%E7%83%AD"><span class="toc-number">1.4.7.</span> <span class="toc-text">7. 什么是缓存预热？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%AD%98%E9%99%8D%E7%BA%A7"><span class="toc-number">1.4.8.</span> <span class="toc-text">8. 什么是缓存降级？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.5.</span> <span class="toc-text">线程模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-redis%E4%B8%BA%E4%BD%95%E9%80%89%E6%8B%A9%E5%8D%95%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.5.1.</span> <span class="toc-text">1. Redis 为何选择单线程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-redis%E7%9C%9F%E7%9A%84%E6%98%AF%E5%8D%95%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.5.2.</span> <span class="toc-text">2. Redis 真的是单线程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-redis-60%E4%B8%BA%E4%BD%95%E5%BC%95%E5%85%A5%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.5.3.</span> <span class="toc-text">3. Redis 6.0 为何引入多线程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-redis-60-%E9%87%87%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%90%8E%E6%80%A7%E8%83%BD%E7%9A%84%E6%8F%90%E5%8D%87%E6%95%88%E6%9E%9C%E5%A6%82%E4%BD%95"><span class="toc-number">1.5.4.</span> <span class="toc-text">4. Redis 6.0 采用多线程后，性能的提升效果如何？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E4%BB%8B%E7%BB%8D%E4%B8%8Bredis%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.5.5.</span> <span class="toc-text">5. 介绍下 Redis 的线程模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-redis-60-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6"><span class="toc-number">1.5.6.</span> <span class="toc-text">6. Redis 6.0 多线程的实现机制？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-redis-60%E5%BC%80%E5%90%AF%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%90%8E%E6%98%AF%E5%90%A6%E4%BC%9A%E5%AD%98%E5%9C%A8%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="toc-number">1.5.7.</span> <span class="toc-text">7. Redis 6.0 开启多线程后，是否会存在线程并发安全问题？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-redis-60-%E4%B8%8E-memcached-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">1.5.8.</span> <span class="toc-text">8. Redis 6.0 与 Memcached 多线程模型的对比</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1"><span class="toc-number">1.6.</span> <span class="toc-text">事务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-redis%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">1.6.1.</span> <span class="toc-text">1. Redis 事务的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-redis%E4%BA%8B%E5%8A%A1%E7%9A%84%E4%B8%89%E4%B8%AA%E9%98%B6%E6%AE%B5"><span class="toc-number">1.6.2.</span> <span class="toc-text">2. Redis 事务的三个阶段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-redis%E4%BA%8B%E5%8A%A1%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4"><span class="toc-number">1.6.3.</span> <span class="toc-text">3. Redis 事务相关命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-redis%E4%BA%8B%E5%8A%A1%E6%94%AF%E6%8C%81%E9%9A%94%E7%A6%BB%E6%80%A7%E5%90%97"><span class="toc-number">1.6.4.</span> <span class="toc-text">4. Redis 事务支持隔离性吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-redis%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%94%AF%E6%8C%81%E4%BA%8B%E5%8A%A1%E5%9B%9E%E6%BB%9A"><span class="toc-number">1.6.5.</span> <span class="toc-text">5. Redis 为什么不支持事务回滚？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-redis%E4%BA%8B%E5%8A%A1%E5%85%B6%E4%BB%96%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.6.6.</span> <span class="toc-text">6. Redis 事务其他实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E-%E5%93%A8%E5%85%B5-%E9%9B%86%E7%BE%A4"><span class="toc-number">1.7.</span> <span class="toc-text">主从、哨兵、集群</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-redis%E5%B8%B8%E8%A7%81%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">1.7.1.</span> <span class="toc-text">1. Redis 常见使用方式有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BB%8B%E7%BB%8D%E4%B8%8Bredis%E5%8D%95%E5%89%AF%E6%9C%AC"><span class="toc-number">1.7.2.</span> <span class="toc-text">2. 介绍下 Redis 单副本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%BB%8B%E7%BB%8D%E4%B8%8Bredis%E5%A4%9A%E5%89%AF%E6%9C%AC%E4%B8%BB%E4%BB%8E"><span class="toc-number">1.7.3.</span> <span class="toc-text">3. 介绍下 Redis 多副本（主从）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%BB%8B%E7%BB%8D%E4%B8%8Bredis-sentinel%E5%93%A8%E5%85%B5"><span class="toc-number">1.7.4.</span> <span class="toc-text">4. 介绍下 Redis Sentinel（哨兵）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E4%BB%8B%E7%BB%8D%E4%B8%8Bredis-cluster"><span class="toc-number">1.7.5.</span> <span class="toc-text">5. 介绍下 Redis Cluster</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E4%BB%8B%E7%BB%8D%E4%B8%8Bredis%E8%87%AA%E7%A0%94"><span class="toc-number">1.7.6.</span> <span class="toc-text">6. 介绍下 Redis 自研</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-redis%E9%AB%98%E5%8F%AF%E7%94%A8%E6%96%B9%E6%A1%88%E5%85%B7%E4%BD%93%E6%80%8E%E4%B9%88%E5%AE%9E%E6%96%BD"><span class="toc-number">1.7.7.</span> <span class="toc-text">7. Redis 高可用方案具体怎么实施？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E4%BA%86%E8%A7%A3%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%9A%84%E5%8E%9F%E7%90%86%E5%90%97"><span class="toc-number">1.7.8.</span> <span class="toc-text">8. 了解主从复制的原理吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E7%94%B1%E4%BA%8E%E4%B8%BB%E4%BB%8E%E5%BB%B6%E8%BF%9F%E5%AF%BC%E8%87%B4%E8%AF%BB%E5%8F%96%E5%88%B0%E8%BF%87%E6%9C%9F%E6%95%B0%E6%8D%AE%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86"><span class="toc-number">1.7.9.</span> <span class="toc-text">9. 由于主从延迟导致读取到过期数据怎么处理？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%9A%84%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%A6%82%E6%9E%9C%E5%9B%A0%E4%B8%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E5%9B%A0%E5%81%9C%E6%AD%A2%E5%A4%8D%E5%88%B6%E4%BA%86%E4%BC%9A%E6%80%8E%E4%B9%88%E6%A0%B7"><span class="toc-number">1.7.10.</span> <span class="toc-text">10. 主从复制的过程中如果因为网络原因停止复制了会怎么样？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-redis%E4%B8%BB%E4%BB%8E%E6%9E%B6%E6%9E%84%E6%95%B0%E6%8D%AE%E4%BC%9A%E4%B8%A2%E5%A4%B1%E5%90%97%E4%B8%BA%E4%BB%80%E4%B9%88"><span class="toc-number">1.7.11.</span> <span class="toc-text">11. Redis 主从架构数据会丢失吗，为什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E4%B8%BB%E4%BB%8E%E6%9E%B6%E6%9E%84%E6%95%B0%E6%8D%AE%E4%B8%A2%E5%A4%B1%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">1.7.12.</span> <span class="toc-text">12. 如何解决主从架构数据丢失的问题？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-redis%E5%93%A8%E5%85%B5%E6%98%AF%E6%80%8E%E4%B9%88%E5%B7%A5%E4%BD%9C%E7%9A%84"><span class="toc-number">1.7.13.</span> <span class="toc-text">13. Redis 哨兵是怎么工作的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB%E6%97%B6%E4%BC%9A%E4%BB%8E%E5%89%A9%E4%B8%8B%E7%9A%84slave%E9%80%89%E4%B8%BE%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84master%E8%A2%AB%E9%80%89%E4%B8%BE%E4%B8%BAmaster%E7%9A%84%E6%A0%87%E5%87%86%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.7.14.</span> <span class="toc-text">14. 故障转移时会从剩下的 slave 选举一个新的 master，被选举为 master 的标准是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-%E5%90%8C%E6%AD%A5%E9%85%8D%E7%BD%AE%E7%9A%84%E6%97%B6%E5%80%99%E5%85%B6%E4%BB%96%E5%93%A8%E5%85%B5%E6%A0%B9%E6%8D%AE%E4%BB%80%E4%B9%88%E6%9B%B4%E6%96%B0%E8%87%AA%E5%B7%B1%E7%9A%84%E9%85%8D%E7%BD%AE%E5%91%A2"><span class="toc-number">1.7.15.</span> <span class="toc-text">15. 同步配置的时候其他哨兵根据什么更新自己的配置呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-%E4%B8%BA%E4%BB%80%E4%B9%88redis%E5%93%A8%E5%85%B5%E9%9B%86%E7%BE%A4%E5%8F%AA%E6%9C%892%E4%B8%AA%E8%8A%82%E7%82%B9%E6%97%A0%E6%B3%95%E6%AD%A3%E5%B8%B8%E5%B7%A5%E4%BD%9C"><span class="toc-number">1.7.16.</span> <span class="toc-text">16. 为什么 Redis 哨兵集群只有 2 个节点无法正常工作？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-redis-cluster%E4%B8%AD%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E5%88%86%E5%B8%83%E7%9A%84%E8%BF%99%E7%A7%8D%E6%96%B9%E5%BC%8F%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E7%82%B9"><span class="toc-number">1.7.17.</span> <span class="toc-text">17. Redis cluster 中是如何实现数据分布的？这种方式有什么优点？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-redis-cluster%E8%8A%82%E7%82%B9%E9%97%B4%E9%80%9A%E4%BF%A1%E6%98%AF%E4%BB%80%E4%B9%88%E6%9C%BA%E5%88%B6"><span class="toc-number">1.7.18.</span> <span class="toc-text">18. Redis cluster 节点间通信是什么机制？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%97%AE%E9%A2%98"><span class="toc-number">1.8.</span> <span class="toc-text">分布式问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">1.8.1.</span> <span class="toc-text">1. 什么是分布式锁？为什么用分布式锁？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%B8%B8%E8%A7%81%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E6%9C%89%E5%93%AA%E4%BA%9B%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">1.8.2.</span> <span class="toc-text">2. 常见的分布式锁有哪些解决方案？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-redis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">1.8.3.</span> <span class="toc-text">3. Redis 实现分布式锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%BA%86%E8%A7%A3redlock%E5%90%97"><span class="toc-number">1.8.4.</span> <span class="toc-text">4. 了解 RedLock 吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-redlock%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">1.8.5.</span> <span class="toc-text">5. RedLock 的原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96"><span class="toc-number">1.9.</span> <span class="toc-text">其他</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-redis%E5%A6%82%E4%BD%95%E5%81%9A%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96"><span class="toc-number">1.9.1.</span> <span class="toc-text">1. Redis 如何做内存优化？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%A6%82%E6%9E%9C%E7%8E%B0%E5%9C%A8%E6%9C%89%E4%B8%AA%E8%AF%BB%E8%B6%85%E9%AB%98%E5%B9%B6%E5%8F%91%E7%9A%84%E7%B3%BB%E7%BB%9F%E7%94%A8redis%E6%9D%A5%E6%8A%97%E4%BD%8F%E5%A4%A7%E9%83%A8%E5%88%86%E8%AF%BB%E8%AF%B7%E6%B1%82%E4%BD%A0%E4%BC%9A%E6%80%8E%E4%B9%88%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.9.2.</span> <span class="toc-text">2. 如果现在有个读超高并发的系统，用 Redis 来抗住大部分读请求，你会怎么设计？</span></a></li></ol></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li class="active"><a href="/2023/10/22/database/no-sql/redis/Java%E9%9D%A2%E8%AF%95%E9%A2%98-07-Redis/" rel="bookmark" title="redis">redis</a></li><li><a href="/2023/10/22/database/sql/mysql/Java%E9%9D%A2%E8%AF%95%E9%A2%98-06-Mysql%E7%AF%87/" rel="bookmark" title="mysql">mysql</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="biya" data-src="/assets/avatar.jpg"><p class="name" itemprop="name">biya</p><div class="description" itemprop="description">摸鱼之道，就在其中</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">13</span><span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">12</span><span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">12</span><span class="name">标签</span></a></div></nav><div class="social"><a href="https://github.com/sbysg" class="item github" rel="noopener" title="https:&#x2F;&#x2F;github.com&#x2F;sbysg" target="_blank"><i class="ic i-github"></i></a><a href="https://www.zhihu.com/people/xin-han-91-91" class="item zhihu" rel="noopener" title="https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;xin-han-91-91" target="_blank"><i class="ic i-zhihu"></i></a><a href="https://music.163.com/#/user/home?id=1657896798" class="item music" rel="noopener" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;1657896798" target="_blank"><i class="ic i-cloud-music"></i></a><a href="https://weibo.com/u/6667154460" class="item weibo" rel="noopener" title="https:&#x2F;&#x2F;weibo.com&#x2F;u&#x2F;6667154460" target="_blank"><i class="ic i-weibo"></i></a><a href="https://about.me/biyahan" class="item about" rel="noopener" title="https:&#x2F;&#x2F;about.me&#x2F;biyahan" target="_blank"><i class="ic i-address-card"></i></a><a href="https://t.me/kill_biya" class="item telegram" rel="noopener" title="https:&#x2F;&#x2F;t.me&#x2F;kill_biya" target="_blank"><i class="ic i-paper-plane"></i></a><a href="https://stackoverflow.com/users/22783860/kill-biya/" class="item stackoverflow" rel="noopener" title="https:&#x2F;&#x2F;stackoverflow.com&#x2F;users&#x2F;22783860&#x2F;kill-biya&#x2F;" target="_blank"><i class="ic i-stack-overflow"></i></a></div><div class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-user"></i>关于</a><ul class="submenu"><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于本站</a></li><li class="item"><a href="/admiration/" rel="section"><i class="ic i-coffee"></i>赞赏博主</a></li></ul></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>友達</a></li></div></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2023/10/22/third-apis/minio/%E4%B8%8A%E9%97%A8%E5%85%BB%E8%80%81-%E6%B3%A8%E5%86%8C%E5%8A%9F%E8%83%BD-%E7%9F%AD%E4%BF%A1/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2023/10/22/database/sql/mysql/Java%E9%9D%A2%E8%AF%95%E9%A2%98-06-Mysql%E7%AF%87/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/backend/" title="分类于Java后端">Java后端</a><i class="ic i-angle-right"></i><a href="/categories/backend/java/" title="分类于Java">Java</a><i class="ic i-angle-right"></i><a href="/categories/backend/java/base/" title="分类于Java基础">Java基础</a></div><span><a href="/2023/10/22/backend/java/base/%E7%88%AA%E5%93%87%E5%A7%A8%E5%A7%A8/">爪哇基础</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/backend/" title="分类于Java后端">Java后端</a><i class="ic i-angle-right"></i><a href="/categories/backend/java/" title="分类于Java">Java</a><i class="ic i-angle-right"></i><a href="/categories/backend/java/base/" title="分类于Java基础">Java基础</a></div><span><a href="/2023/10/22/backend/java/base/first/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/">hi biya</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/springframe/" title="分类于Java框架">Java框架</a><i class="ic i-angle-right"></i><a href="/categories/springframe/spring/" title="分类于Spring全家桶">Spring全家桶</a><i class="ic i-angle-right"></i><a href="/categories/springframe/spring/mybatis/" title="分类于Mybatis">Mybatis</a></div><span><a href="/2023/10/22/springframe/spring/mybatis/mybatis-plus/3-02Mybatis-plus/">mybatis-plus</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/third-apis/" title="分类于第三方api">第三方api</a></div><span><a href="/2023/10/22/third-apis/minio/%E4%B8%8A%E9%97%A8%E5%85%BB%E8%80%81-%E6%B3%A8%E5%86%8C%E5%8A%9F%E8%83%BD-%E7%9F%AD%E4%BF%A1/">sms</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/linux/" title="分类于Linux">Linux</a><i class="ic i-angle-right"></i><a href="/categories/linux/docker/" title="分类于Docker">Docker</a></div><span><a href="/2023/10/22/linux/docker/rabbitMQ/RabbitMQ/">rabbitMQ</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/springframe/" title="分类于Java框架">Java框架</a><i class="ic i-angle-right"></i><a href="/categories/springframe/spring/" title="分类于Spring全家桶">Spring全家桶</a></div><span><a href="/2023/10/22/springframe/spring/springcloud/SpringCloud/">springcloud</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/frontend/" title="分类于前端">前端</a><i class="ic i-angle-right"></i><a href="/categories/frontend/vue/" title="分类于Vue">Vue</a></div><span><a href="/2023/10/22/frontend/vue/vue3/Vue3%E9%80%9F%E6%88%90/">vue3</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/springframe/" title="分类于Java框架">Java框架</a><i class="ic i-angle-right"></i><a href="/categories/springframe/spring/" title="分类于Spring全家桶">Spring全家桶</a></div><span><a href="/2023/10/22/springframe/spring/springboot/springboot-01-class/">springboot</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/database/" title="分类于数据库">数据库</a></div><span><a href="/2023/10/22/database/no-sql/redis/Java%E9%9D%A2%E8%AF%95%E9%A2%98-07-Redis/">redis</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/database/" title="分类于数据库">数据库</a></div><span><a href="/2023/10/22/database/sql/mysql/Java%E9%9D%A2%E8%AF%95%E9%A2%98-06-Mysql%E7%AF%87/">mysql</a></span></li></ul></div><div class="rpost pjax"><h2>最新评论</h2><ul class="leancloud-recent-comment" id="new-comment"><li class="item" v-for="com in coms"><a v-bind:href="root + com.href" data-pjax-state="data-pjax-state"><span class="breadcrumb">{{com.nick}} @ {{com.time}}</span><span>{{com.text}}<br></span></a></li></ul></div></div><div class="status"><div class="copyright"><span itemprop="copyrightYear">2023</span><span class="with-love"><i class="ic i-sakura rotate"></i></span><span class="author" itemprop="copyrightHolder">biya @ Ya Hallo</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i></span><span title="站点总字数">448k 字</span><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="ic i-coffee"></i></span><span title="站点阅读时长">6:47</span></div><div class="powered-by">基于 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & Theme.<a href="https://github.com/theme-shoka-x/hexo-theme-shokaX/" rel="noopener" target="_blank">ShokaX</a></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2023/10/22/database/no-sql/redis/Java面试题-07-Redis/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,chart:!1,copy_tex:!1,katex:!1,mermaid:!1,audio:void 0,fancybox:!0,nocopy:!1,outime:!0,template:'<div class="note warning"><p><span class="label warning">文章时效性提示</span><br>这是一篇发布于 {{publish}} 天前，最后一次更新在 {{updated}} 天前的文章，部分信息可能已经发生改变，请注意甄别。</p></div>',quiz:{choice:"单选题",multiple:"多选题",true_false:"判断题",essay:"问答题",gap_fill:"填空题",mistake:"错题备注"},ignores:[a=>a.includes("#"),a=>new RegExp(LOCAL.path+"$").test(a),[]]}</script><script src="https://polyfill.io/v3/polyfill.min.js?features=default,fetch"></script><script src="https://lf9-cdn-tos.bytecdntp.com/cdn/expire-6-M/pace/1.0.2/pace.min.js"></script><script src="https://lf9-cdn-tos.bytecdntp.com/cdn/expire-6-M/algoliasearch/4.12.1/algoliasearch-lite.umd.min.js"></script><script src="https://lf9-cdn-tos.bytecdntp.com/cdn/expire-6-M/instantsearch.js/4.39.0/instantsearch.production.min.js"></script><script src="https://lf9-cdn-tos.bytecdntp.com/cdn/expire-6-M/quicklink/2.2.0/quicklink.umd.min.js"></script><script src="https://lf9-cdn-tos.bytecdntp.com/cdn/expire-6-M/??jquery/3.5.1/jquery.min.js,fancybox/3.5.7/jquery.fancybox.min.js,justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js" async></script><script src="https://lf9-cdn-tos.bytecdntp.com/cdn/expire-6-M/KaTeX/0.15.2/contrib/copy-tex.min.js" async></script><script src="/js/app.js?v=0.3.6"></script><script data-pjax="data-pjax">var _hmt=_hmt||[];!function(){var e=document.createElement("script"),t=(e.src="https://hm.baidu.com/hm.js?true",e.async=!0,document.getElementsByTagName("script")[0]);t.parentNode.insertBefore(e,t)}()</script><script>!function(t,e,n,c,r,a){t[n]=t[n]||function(){(t[n].q=t[n].q||[]).push(arguments)},(r=e.createElement(c)).async=1,r.src="https://www.clarity.ms/tag/true",(a=e.getElementsByTagName(c)[0]).parentNode.insertBefore(r,a)}(window,document,"clarity","script")</script><script async src="https://www.googletagmanager.com/gtag/js?id=true"></script><script data-pjax="data-pjax">function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","true")</script><script type="module" data-pjax>let items = []
        import { RecentComments } from 'https://unpkg.com/@waline/client@v2/dist/waline.mjs'
        RecentComments({
          serverURL: 'waline-biya.vercel.app',
          count: 10,
        }).then(({ comments }) => {
          comments.forEach(function (item) {
              let cText = (item.orig.length > 50) ? item.orig.substring(0,50)+'...' : item.orig
              item.url = item.url !== '/' ?  '/' + item.url : item.url;
              const siteLink = item.url + "#" + item.objectId
              items.push({
                  href: siteLink,
                  nick: item.nick,
                  time: item.insertedAt.split('T').shift(),
                  text: cText
              })
          })
          Vue.createApp({
            data() {
                return {
                    coms: items,
                    root: ''
                }
            }
          }).mount('#new-comment')
        }).catch(function (err) {
          console.error(err)
        })</script></body></html><!-- rebuild by hexo-renderer-multi-next-markdown-it -->