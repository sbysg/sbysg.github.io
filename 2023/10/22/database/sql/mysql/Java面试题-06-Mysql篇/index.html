<!-- build time: Sat Nov 04 2023 21:49:44 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta http-equiv="X-UA-COMPATIBLE" content="IE=edge,chrome=1"><meta name="renderer" content="webkit"><link rel="icon" type="image/ico" sizes="32x32" href="/assets/favicon.ico"><link rel="apple-touch-icon" sizes="180x180" href="/assets/apple-touch-icon.png"><meta name="msvalidate.01" content="1234"><link rel="alternate" href="/rss.xml" title="夢のない賢魚です" type="application/rss+xml"><link rel="alternate" href="/atom.xml" title="夢のない賢魚です" type="application/atom+xml"><link rel="alternate" type="application/json" title="夢のない賢魚です" href="https://sbysg.github.io/feed.json"><link rel="preconnect" href="https://lf9-cdn-tos.bytecdntp.com"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://unpkg.com"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.3.6"><script src="https://cdn.staticfile.org/vue/3.2.45/vue.global.prod.js"></script><meta name="keywords" content="mysql"><link rel="canonical" href="https://sbysg.github.io/2023/10/22/database/sql/mysql/Java%E9%9D%A2%E8%AF%95%E9%A2%98-06-Mysql%E7%AF%87/"><title>mysql</title><meta name="generator" content="Hexo 6.3.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">mysql</h1><div class="meta"><span class="item" title="创建时间：2023-10-22 00:09:40"><span class="icon"><i class="ic i-calendar"></i></span><span class="text">发表于</span><time itemprop="dateCreated datePublished" datetime="2023-10-22T00:09:40+08:00">2023-10-22</time></span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i></span><span class="text">本文字数</span><span>22k</span><span class="text">字</span></span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i></span><span class="text">阅读时长</span><span>20 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span><span class="line"></span><span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Ya Hallo</a></li></ul><ul class="right" id="rightNav"><li class="item theme" @click="changeThemeByBtn"><i class="ic" :class="{'i-sun': !themeStatus,'i-moon': themeStatus}"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div class="pjax" id="imgs"><ul><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1gicljgocqbj20zk0m8e81.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1gicis3attqj20zk0m8k7l.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1giclx29mstj20zk0m8hdt.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1giciuja1j1j20zk0m8kjl.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1giph4lm9i7j20zk0m84qp.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1gipeu7txpzj20zk0m81kx.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"></path></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"></use><use xlink:href="#gentle-wave" x="48" y="3"></use><use xlink:href="#gentle-wave" x="48" y="5"></use><use xlink:href="#gentle-wave" x="48" y="7"></use></g></svg></div><main><div class="inner"><div class="pjax" id="main"><div class="article wrap"><div class="breadcrumb" itemlistelement itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i><span><a href="/">首页</a></span><i class="ic i-angle-right"></i><span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/database/" itemprop="item" rel="index" title="分类于数据库"><span itemprop="name">数据库<meta itemprop="position" content="0"></span></a></span></div><article class="post block" itemscope itemtype="http://schema.org/Article" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://sbysg.github.io/2023/10/22/database/sql/mysql/Java%E9%9D%A2%E8%AF%95%E9%A2%98-06-Mysql%E7%AF%87/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/assets/avatar.jpg"><meta itemprop="name" content="biya"><meta itemprop="description" content="biya, 摸鱼之道，就在其中"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="夢のない賢魚です"></span><div class="body md" itemprop="articleBody"><h1 id="java面试题-mysql篇"><a class="anchor" href="#java面试题-mysql篇">#</a> Java 面试题 - Mysql 篇</h1><h2 id="mysql常见"><a class="anchor" href="#mysql常见">#</a> Mysql 常见</h2><h3 id="1-mysql中myisam与innodb的区别"><a class="anchor" href="#1-mysql中myisam与innodb的区别">#</a> 1. MySQL 中 myisam 与 innodb 的区别？</h3><ul><li>InnoDB 支持事物，而 MyISAM 不支持事物</li><li>InnoDB 支持行级锁，而 MyISAM 支持表级锁</li><li>InnoDB 支持 MVCC, 而 MyISAM 不支持</li><li>InnoDB 支持外键，而 MyISAM 不支持</li><li>InnoDB 不支持全文索引，而 MyISAM 支持。</li></ul><h3 id="2-事务的特性"><a class="anchor" href="#2-事务的特性">#</a> 2. 事务的特性</h3><ul><li>原子性：是指事务包含所有操作要么全部成功，要么全部失败回滚。</li><li>一致性：指事务必须使数据库从一个一致性状态变换成另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。 拿转账来说，假设用户 A 和用户 B 两者的钱加起来一共是 5000，那么不管 A 和 B 之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是 5000，这就是事务的一致性。</li><li>隔离性：是当多个用户并发访问数据库时，比如操作同一张表时，数据表为每个用户开启的事务，不能被其他事务所干扰，多个并发事务之间要相互隔离。</li><li>持久性：持久性是指一个事务一旦被提交，那么对数据库中的数据的改变就是永久的，即便是在数据库系统遇到故障的性况下也不会丢失提交事务的操作。</li></ul><h3 id="3-并发操作问题"><a class="anchor" href="#3-并发操作问题">#</a> 3. 并发操作问题</h3><ul><li>脏读：脏读是指在一个事务处理过程中读取到了另外一个未提交事务中的数据。</li><li>不可重复读：不可重复读是指在对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，被另一个事务修改并提交了。</li><li>虚读 (幻读)：幻读发生在当两个完全相同的查询执行时，第二次查询所返回的结果集跟第一个查询不相同。 比如两个事务操作，A 事务查询状态为 1 的记录时，这时 B 事务插入了一条状态为 1 的记录，A 事务再次查询返回的结果不一样。</li></ul><h3 id="4-事务的隔离级别"><a class="anchor" href="#4-事务的隔离级别">#</a> 4. 事务的隔离级别</h3><ul><li>Serializable (串行化)：可避免脏读、不可重复读、幻读。（就是串行化读数据）</li><li>Repeatable read (可重复读)：可避免脏读、不可重复读的发生。</li><li>Read committed (读已提交)：可避免脏读的发生。</li><li>Read uncommitted (读未提交)：最低级别，任何情况都无法保证。</li></ul><p>在 MySQL 数据库中，支持上面四种隔离级别，默认的为 Repeatable read (可重复读)；而在 Oracle 数据库中，只支持 Serializable (串行化) 级别和 Read committed (读已提交) 这两种级别，其中默认的为 Read committed 级别。##</p><h3 id="5-索引是什么"><a class="anchor" href="#5-索引是什么">#</a> 5. 索引是什么？</h3><p>索引是表的目录，在查找内容之前可以先在目录中查找索引位置，以此快速定位查询数据。对于索引，会保存在额外的文件中。</p><p>索引是帮助 MySQL 高效获取数据的数据结构。</p><h3 id="6-索引能干什么有什么好处"><a class="anchor" href="#6-索引能干什么有什么好处">#</a> 6. 索引能干什么？有什么好处？</h3><p>当表中的数据量越来越大时，索引对于性能的影响愈发重要。索引能够轻易将查询性能提高好几个数量级，总的来说就是可以明显的提高查询效率。</p><h3 id="7-索引的种类有哪些"><a class="anchor" href="#7-索引的种类有哪些">#</a> 7. 索引的种类有哪些？</h3><p>1、从存储结构上来划分：BTree 索引（B-Tree 或 B+Tree 索引），Hash 索引，full-index 全文索引，R-Tree 索引。这里所描述的是索引存储时保存的形式，</p><p>2、从应用层次来分：普通索引，唯一索引，复合索引</p><p>3、根据中数据的物理顺序与键值的逻辑（索引）顺序关系：聚集索引，非聚集索引。</p><p>平时讲的索引类型一般是指在应用层次的划分。</p><ul><li>普通索引：即一个索引只包含单个列，一个表可以有多个单列索引</li><li>复合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并</li><li>唯一索引：索引列的值必须唯一，但允许有空值</li></ul><h3 id="8-为什么-mysql-的索引要使用-b树而不是其它树形结构比如-b-树"><a class="anchor" href="#8-为什么-mysql-的索引要使用-b树而不是其它树形结构比如-b-树">#</a> 8. 为什么 MySQL 的索引要使用 B + 树而不是其它树形结构？比如 B 树？</h3><p>B-tree：因为 B 树不管叶子节点还是非叶子节点，都会保存数据，这样导致在非叶子节点中能保存的指针数量变少（有些资料也称为扇出），指针少的情况下要保存大量数据，只能增加树的高度，导致 IO 操作变多，查询性能变低；</p><p>Hash：虽然可以快速定位，但是没有顺序，IO 复杂度高。</p><p>二叉树：树的高度不均匀，不能自平衡，查找效率跟数据有关（树的高度），并且 IO 代价高。</p><p>红黑树：树的高度随着数据量增加而增加，IO 代价高。</p><p><strong>不使用平衡二叉树的原因如下</strong>：</p><p>最大原因：深度太大 (因为一个节点最多只有 2 个子节点)，一次查询需要的 I/O 复杂度为 O (lgN), 而 b+tree 只需要 O (log_mN), 而其出度 m 非常大，其深度一般不会超过 4 平衡二叉树逻辑上很近的父子节点，物理上可能很远，无法充分发挥磁盘顺序读和预读的高效特性。</p><h3 id="9-myisam和innodb实现btree索引方式的区别"><a class="anchor" href="#9-myisam和innodb实现btree索引方式的区别">#</a> 9. MyISAM 和 InnoDB 实现 BTree 索引方式的区别</h3><p><strong>MyISAM</strong></p><p>B+Tree 叶节点的 data 域存放的是数据记录的地址。在索引检索的时候，首先按照 B+Tree 搜索算法搜索索引，如果指定的 Key 存在，则取出其 data 域的值，然后以 data 域的值为地址读取相应的数据记录。这被称为 “非聚簇索引”。 索引文件和数据文件是分离的</p><p><strong>InnoDB</strong></p><ul><li>InnoDB 的 B+Tree 索引分为主索引（聚集索引）和辅助索引 (非聚集索引)。一张表一定包含一个聚集索引构成的 B+ 树以及若干辅助索引的构成的 B+ 树。</li><li>辅助索引的存在并不会影响聚集索引，因为聚集索引构成的 B+ 树是数据实际存储的形式，而辅助索引只用于加速数据的查找，所以一张表上往往有多个辅助索引以此来提升数据库的性能。</li><li>就很容易明白为什么不建议使用过长的字段作为主键，因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大。再例如，用非单调的字段作为主键在 InnoDB 中不是个好主意，因为 InnoDB 数据文件本身是一颗 B+Tree，非单调的主键会造成在插入新记录时数据文件为了维持 B+Tree 的特性而频繁的分裂调整，十分低效，而使用自增字段作为主键则是一个很好的选择。</li></ul><h3 id="10-什么是最左匹配原则"><a class="anchor" href="#10-什么是最左匹配原则">#</a> 10. 什么是最左匹配原则？</h3><p>最左优先，以最左边的为起点任何连续的索引都能匹配上。同时遇到范围查询 (&gt;、&lt;、between、like) 就会停止匹配。 例如：b = 2 如果建立 (a,b) 顺序的索引，是匹配不到 (a,b) 索引的；但是如果查询条件是 a = 1 and b = 2, 就可以，因为<strong>优化器会自动调整 a,b 的顺序</strong>。再比如 a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立 (a,b,c,d) 顺序的索引，d 是用不到索引的，因为 c 字段是一个范围查询，它之后的字段会停止匹配。</p><p><strong>最左匹配原则的原理</strong></p><p>MySQL 中的索引可以以一定顺序引用多列，这种索引叫作联合索引。最左匹配原则都是针对联合索引来说的</p><ul><li>我们都知道索引的底层是一颗 B + 树，那么联合索引当然还是一颗 B + 树，只不过联合索引的健值数量不是一个，而是多个。构建一颗 B + 树只能根据一个值来构建，因此数据库依据联合索引最左的字段来构建 B + 树。 例子：假如创建一个（a,b) 的联合索引，那么它的索引树是这样的可以看到 a 的值是有顺序的，1，1，2，2，3，3，而 b 的值是没有顺序的 1，2，1，4，1，2。所以 b = 2 这种查询条件没有办法利用索引，因为联合索引首先是按 a 排序的，b 是无序的。</li></ul><p>同时我们还可以发现在 a 值相等的情况下，b 值又是按顺序排列的，但是这种顺序是相对的。所以最左匹配原则遇上范围查询就会停止，剩下的字段都无法使用索引。例如 a = 1 and b = 2 a,b 字段都可以使用索引，因为在 a 值确定的情况下 b 是相对有序的，而 a&gt;1and b=2，a 字段可以匹配上索引，但 b 值不可以，因为 a 的值是一个范围，在这个范围中 b 是无序的。</p><p>优点：最左前缀原则的利用也可以显著提高查询效率，是常见的 MySQL 性能优化手段。</p><h3 id="11-哪些列上适合创建索引创建索引有哪些开销"><a class="anchor" href="#11-哪些列上适合创建索引创建索引有哪些开销">#</a> 11. 哪些列上适合创建索引？创建索引有哪些开销？</h3><p>经常需要作为条件查询的列上适合创建索引，并且该列上也必须有一定的区分度。创建索引需要维护，在插入数据的时候会重新维护各个索引树（数据页的分裂与合并），对性能造成影响</p><h3 id="12-索引这么多优点为什么不对表中的每一个列创建一个索引呢"><a class="anchor" href="#12-索引这么多优点为什么不对表中的每一个列创建一个索引呢">#</a> 12. 索引这么多优点，为什么不对表中的每一个列创建一个索引呢？</h3><ol><li>当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。</li><li>索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。</li><li>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。</li></ol><h3 id="13-mysql建表的约束条件有哪些"><a class="anchor" href="#13-mysql建表的约束条件有哪些">#</a> 13. <strong>MySQL 建表的约束条件有哪些</strong>？</h3><ul><li>主键约束（Primay Key Coustraint） 唯一性，非空性</li><li>唯一约束 （Unique Counstraint）唯一性，可以空，但只能有一个</li><li>检查约束 (Check Counstraint) 对该列数据的范围、格式的限制</li><li>默认约束 (Default Counstraint) 该数据的默认值</li><li>外键约束 (Foreign Key Counstraint) 需要建立两表间的关系并引用主表的列</li></ul><h3 id="14-mysql执行查询的过程"><a class="anchor" href="#14-mysql执行查询的过程">#</a> 14. MySQL 执行查询的过程？</h3><ol><li>客户端通过 TCP 连接发送连接请求到 mysql 连接器，连接器会对该请求进行权限验证及连接资源分配</li><li>查缓存。（当判断缓存是否命中时，MySQL 不会进行解析查询语句，而是直接使用 SQL 语句和客户端发送过来的其他原始信息。所以，任何字符上的不同，例如空格、注解等都会导致缓存的不命中。）</li><li>语法分析（SQL 语法是否写错了）。 如何把语句给到预处理器，检查数据表和数据列是否存在，解析别名看是否存在歧义。</li><li>优化。是否使用索引，生成执行计划。</li><li>交给执行器，将数据保存到结果集中，同时会逐步将数据缓存到查询缓存中，最终将结果集返回给客户端。</li></ol><p><img data-src="http://blog-img.coolsen.cn/img/image-20210220120155334.png" alt="img"></p><h3 id="15-mysql的binlog有有几种录入格式分别有什么区别"><a class="anchor" href="#15-mysql的binlog有有几种录入格式分别有什么区别">#</a> 15. MySQL 的 binlog 有有几种录入格式？分别有什么区别？</h3><p>有三种格式，statement,row 和 mixed.</p><ul><li>statement 模式下，记录单元为语句。即每一个 sql 造成的影响会记录。由于 sql 的执行是有上下文的，因此在保存的时候需要保存相关的信息，同时还有一些使用了函数之类的语句无法被记录复制.</li><li>row 级别下，记录单元为每一行的改动，基本是可以全部记下来但是由于很多操作，会导致大量行的改动 (比如 alter table), 因此这种模式的文件保存的信息太多，日志量太大。</li><li>mixed. 一种折中的方案，普通操作使用 statement 记录，当无法使用 statement 的时候使用 row. 此外，新版的 MySQL 中对 row 级别也做了一些优化，当表结构发生变化的时候，会记录语句而不是逐行记录.</li></ul><div class="note info"><p><img data-src="http://blog-img.coolsen.cn/img/image-20210822210317322.png" alt="image-20210822210317322"></p><h3 id="16-数据库的三范式是什么"><a class="anchor" href="#16-数据库的三范式是什么">#</a> 16. 数据库的三范式是什么？</h3><ul><li>第一范式：强调的是列的原子性，即数据库表的每一列都是不可分割的原子数据项。</li><li>第二范式：要求实体的属性完全依赖于主关键字。所谓完全 依赖是指不能存在仅依赖主关键字一部分的属性。</li><li>第三范式：任何非主属性不依赖于其它非主属性。</li></ul><h3 id="17-mysql-支持哪些存储引擎"><a class="anchor" href="#17-mysql-支持哪些存储引擎">#</a> 17. MySQL 支持哪些存储引擎？</h3><p>MySQL 支持多种存储引擎，比如 InnoDB,MyISAM,Memory,Archive 等等。在大多数的情况下，直接选择使用 InnoDB 引擎都是最合适的，InnoDB 也是 MySQL 的默认存储引擎。</p><p>MyISAM 和 InnoDB 的区别有哪些：</p><ul><li>InnoDB 支持事务，MyISAM 不支持</li><li>InnoDB 支持外键，而 MyISAM 不支持</li><li>InnoDB 是聚集索引，数据文件是和索引绑在一起的，必须要有主键，通过主键索引效率很高；MyISAM 是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针，主键索引和辅助索引是独立的。</li><li>Innodb 不支持全文索引，而 MyISAM 支持全文索引，查询效率上 MyISAM 要高；</li><li>InnoDB 不保存表的具体行数，MyISAM 用一个变量保存了整个表的行数。</li><li>MyISAM 采用表级锁 (table-level locking)；InnoDB 支持行级锁 (row-level locking) 和表级锁，默认为行级锁。</li></ul><h3 id="18-超键-候选键-主键-外键分别是什么"><a class="anchor" href="#18-超键-候选键-主键-外键分别是什么">#</a> 18. 超键、候选键、主键、外键分别是什么？</h3><ul><li>超键：在关系中能唯一标识元组的属性集称为关系模式的超键。一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。</li><li>候选键：是最小超键，即没有冗余元素的超键。</li><li>主键：数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（Null）。</li><li>外键：在一个表中存在的另一个表的主键称此表的外键。</li></ul><h3 id="19-sql-约束有哪几种"><a class="anchor" href="#19-sql-约束有哪几种">#</a> 19. SQL 约束有哪几种？</h3><ul><li>NOT NULL: 用于控制字段的内容一定不能为空（NULL）。</li><li>UNIQUE: 控件字段内容不能重复，一个表允许有多个 Unique 约束。</li><li>PRIMARY KEY: 也是用于控件字段内容不能重复，但它在一个表只允许出现一个。</li><li>FOREIGN KEY: 用于预防破坏表之间连接的动作，也能防止非法数据插入外键列，因为它必须是它指向的那个表中的值之一。</li><li>CHECK: 用于控制字段的值范围。</li></ul><h3 id="20-mysql-中的-varchar-和-char-有什么区别"><a class="anchor" href="#20-mysql-中的-varchar-和-char-有什么区别">#</a> 20. MySQL 中的 varchar 和 char 有什么区别？</h3><p>char 是一个定长字段，假如申请了 <code>char(10)</code> 的空间，那么无论实际存储多少内容。该字段都占用 10 个字符，而 varchar 是变长的，也就是说申请的只是最大长度，占用的空间为实际字符长度 + 1, 最后一个字符存储使用了多长的空间.</p><p>在检索效率上来讲，char &gt; varchar, 因此在使用中，如果确定某个字段的值的长度，可以使用 char, 否则应该尽量使用 varchar. 例如存储用户 MD5 加密后的密码，则应该使用 char。</p><h3 id="21-mysql中-in-和-exists-区别"><a class="anchor" href="#21-mysql中-in-和-exists-区别">#</a> 21. MySQL 中 in 和 exists 区别</h3><p>MySQL 中的 in 语句是把外表和内表作 hash 连接，而 exists 语句是对外表作 loop 循环，每次 loop 循环再对内表进行查询。一直大家都认为 exists 比 in 语句的效率要高，这种说法其实是不准确的。这个是要区分环境的。</p><p>如果查询的两个表大小相当，那么用 in 和 exists 差别不大。 如果两个表中一个较小，一个是大表，则子查询表大的用 exists，子查询表小的用 in。 not in 和 not exists：如果查询语句使用了 not in，那么内外表都进行全表扫描，没有用到索引；而 not extsts 的子查询依然能用到表上的索引。所以无论那个表大，用 not exists 都比 not in 要快。</p><h3 id="22-drop-delete与truncate的区别"><a class="anchor" href="#22-drop-delete与truncate的区别">#</a> 22. drop、delete 与 truncate 的区别</h3><p>三者都表示删除，但是三者有一些差别：</p><p><img data-src="http://blog-img.coolsen.cn/img/image-20210822203927822.png" alt="image-20210822203927822"></p><h3 id="23-什么是存储过程有哪些优缺点"><a class="anchor" href="#23-什么是存储过程有哪些优缺点">#</a> 23. 什么是存储过程？有哪些优缺点？</h3><p>存储过程是一些预编译的 SQL 语句。</p><p>1、更加直白的理解：存储过程可以说是一个记录集，它是由一些 T-SQL 语句组成的代码块，这些 T-SQL 语句代码像一个方法一样实现一些功能（对单表或多表的增删改查），然后再给这个代码块取一个名字，在用到这个功能的时候调用他就行了。</p><p>2、存储过程是一个预编译的代码块，执行效率比较高，一个存储过程替代大量 T_SQL 语句 ，可以降低网络通信量，提高通信速率，可以一定程度上确保数据安全</p><p>但是，在互联网项目中，其实是不太推荐存储过程的，比较出名的就是阿里的《Java 开发手册》中禁止使用存储过程，我个人的理解是，在互联网项目中，迭代太快，项目的生命周期也比较短，人员流动相比于传统的项目也更加频繁，在这样的情况下，存储过程的管理确实是没有那么方便，同时，复用性也没有写在服务层那么好。</p><h2 id="事务"><a class="anchor" href="#事务">#</a> 事务</h2><h3 id="1-什么是数据库事务"><a class="anchor" href="#1-什么是数据库事务">#</a> 1. 什么是数据库事务？</h3><p>事务是一个不可分割的数据库操作序列，也是数据库并发控制的基本单位，其执行的结果必须使数据库从一种一致性状态变到另一种一致性状态。事务是逻辑上的一组操作，要么都执行，要么都不执行。</p><p>事务最经典也经常被拿出来说例子就是转账了。</p><p>假如小明要给小红转账 1000 元，这个转账会涉及到两个关键操作就是：将小明的余额减少 1000 元，将小红的余额增加 1000 元。万一在这两个操作之间突然出现错误比如银行系统崩溃，导致小明余额减少而小红的余额没有增加，这样就不对了。事务就是保证这两个关键操作要么都成功，要么都要失败。</p><h3 id="2-介绍一下事务具有的四个特征"><a class="anchor" href="#2-介绍一下事务具有的四个特征">#</a> 2. 介绍一下事务具有的四个特征</h3><p>事务就是一组原子性的操作，这些操作要么全部发生，要么全部不发生。事务把数据库从一种一致性状态转换成另一种一致性状态。</p><ul><li>原子性。事务是数据库的逻辑工作单位，事务中包含的各操作要么都做，要么都不做</li><li>一致性。事 务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。因此当数据库只包含成功事务提交的结果时，就说数据库处于一致性状态。如果数据库系统 运行中发生故障，有些事务尚未完成就被迫中断，这些未完成事务对数据库所做的修改有一部分已写入物理数据库，这时数据库就处于一种不正确的状态，或者说是 不一致的状态。</li><li>隔离性。一个事务的执行不能其它事务干扰。即一个事务内部的 // 操作及使用的数据对其它并发事务是隔离的，并发执行的各个事务之间不能互相干扰。</li><li>持续性。也称永久性，指一个事务一旦提交，它对数据库中的数据的改变就应该是永久性的。接下来的其它操作或故障不应该对其执行结果有任何影响。</li></ul><h3 id="3-说一下mysql-的四种隔离级别"><a class="anchor" href="#3-说一下mysql-的四种隔离级别">#</a> 3. 说一下 MySQL 的四种隔离级别</h3><ul><li>Read Uncommitted（读取未提交内容）</li></ul><p>在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。读取未提交的数据，也被称之为脏读（Dirty Read）。</p><ul><li>Read Committed（读取提交内容）</li></ul><p>这是大多数数据库系统的默认隔离级别（但不是 MySQL 默认的）。它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这种隔离级别 也支持所谓 的 不可重复读（Nonrepeatable Read），因为同一事务的其他实例在该实例处理其间可能会有新的 commit，所以同一 select 可能返回不同结果。</p><ul><li>Repeatable Read（可重读）</li></ul><p>这是 MySQL 的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。不过理论上，这会导致另一个棘手的问题：幻读 （Phantom Read）。</p><ul><li>Serializable（可串行化）</li></ul><p>通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。</p><p><img data-src="http://blog-img.coolsen.cn/img/image-20210822180308501.png" alt="image-20210822180308501"></p><p>MySQL 默认采用的 REPEATABLE_READ 隔离级别 Oracle 默认采用的 READ_COMMITTED 隔离级别</p><p>事务隔离机制的实现基于锁机制和并发调度。其中并发调度使用的是 MVVC（多版本并发控制），通过保存修改的旧版本信息来支持并发一致性读和回滚等特性。</p><p>因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是 READ-COMMITTED (读取提交内容):，但是你要知道的是 InnoDB 存储引擎默认使用 **REPEATABLE-READ（可重读）** 并不会有任何性能损失。</p><p>InnoDB 存储引擎在 分布式事务 的情况下一般会用到 **SERIALIZABLE (可串行化)** 隔离级别。</p><h3 id="4-什么是脏读幻读不可重复读"><a class="anchor" href="#4-什么是脏读幻读不可重复读">#</a> 4. 什么是脏读？幻读？不可重复读？</h3><p>1、脏读：事务 A 读取了事务 B 更新的数据，然后 B 回滚操作，那么 A 读取到的数据是脏数据</p><p>2、不可重复读：事务 A 多次读取同一数据，事务 B 在事务 A 多次读取的过程中，对数据作了更新并提交，导致事务 A 多次读取同一数据时，结果 不一致。</p><p>3、幻读：系统管理员 A 将数据库中所有学生的成绩从具体分数改为 ABCDE 等级，但是系统管理员 B 就在这个时候插入了一条具体分数的记录，当系统管理员 A 改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。</p><p>不可重复读侧重于修改，幻读侧重于新增或删除（多了或少量行），脏读是一个事务回滚影响另外一个事务。</p><h3 id="5-事务的实现原理"><a class="anchor" href="#5-事务的实现原理">#</a> 5. 事务的实现原理</h3><p>事务是基于重做日志文件 (redo log) 和回滚日志 (undo log) 实现的。</p><p>每提交一个事务必须先将该事务的所有日志写入到重做日志文件进行持久化，数据库就可以通过重做日志来保证事务的原子性和持久性。</p><p>每当有修改事务时，还会产生 undo log，如果需要回滚，则根据 undo log 的反向语句进行逻辑操作，比如 insert 一条记录就 delete 一条记录。undo log 主要实现数据库的一致性。</p><h3 id="6-mysql事务日志介绍下"><a class="anchor" href="#6-mysql事务日志介绍下">#</a> 6. MySQL 事务日志介绍下？</h3><p>innodb 事务日志包括 redo log 和 undo log。</p><p>undo log 指事务开始之前，在操作任何数据之前，首先将需操作的数据备份到一个地方。redo log 指事务中操作的任何数据，将最新的数据备份到一个地方。</p><p>事务日志的目的：实例或者介质失败，事务日志文件就能派上用场。</p><p><strong>redo log</strong></p><p>redo log 不是随着事务的提交才写入的，而是在事务的执行过程中，便开始写入 redo 中。具体的落盘策略可以进行配置 。防止在发生故障的时间点，尚有脏页未写入磁盘，在重启 MySQL 服务的时候，根据 redo log 进行重做，从而达到事务的未入磁盘数据进行持久化这一特性。RedoLog 是为了实现事务的持久性而出现的产物。</p><p><img data-src="http://blog-img.coolsen.cn/img/image-20210822181340692.png" alt="image-20210822181340692"></p><p><strong>undo log</strong></p><p>undo log 用来回滚行记录到某个版本。事务未提交之前，Undo 保存了未提交之前的版本数据，Undo 中的数据可作为数据旧版本快照供其他并发事务进行快照读。是为了实现事务的原子性而出现的产物，在 MySQL innodb 存储引擎中用来实现多版本并发控制。</p><p><img data-src="http://blog-img.coolsen.cn/img/image-20210822181416382.png" alt="image-20210822181416382"></p><h3 id="7-什么是mysql的-binlog"><a class="anchor" href="#7-什么是mysql的-binlog">#</a> 7. 什么是 MySQL 的 binlog？</h3><p>MySQL 的 binlog 是记录所有数据库表结构变更（例如 CREATE、ALTER TABLE）以及表数据修改（INSERT、UPDATE、DELETE）的二进制日志。binlog 不会记录 SELECT 和 SHOW 这类操作，因为这类操作对数据本身并没有修改，但你可以通过查询通用日志来查看 MySQL 执行过的所有语句。</p><p>MySQL binlog 以事件形式记录，还包含语句所执行的消耗的时间，MySQL 的二进制日志是事务安全型的。binlog 的主要目的是复制和恢复。</p><p>binlog 有三种格式，各有优缺点：</p><ul><li><strong>statement：</strong> 基于 SQL 语句的模式，某些语句和函数如 UUID, LOAD DATA INFILE 等在复制过程可能导致数据不一致甚至出错。</li><li><strong>row：</strong> 基于行的模式，记录的是行的变化，很安全。但是 binlog 会比其他两种模式大很多，在一些大表中清除大量数据时在 binlog 中会生成很多条语句，可能导致从库延迟变大。</li><li><strong>mixed：</strong> 混合模式，根据语句来选用是 statement 还是 row 模式。</li></ul><h3 id="8-在事务中可以混合使用存储引擎吗"><a class="anchor" href="#8-在事务中可以混合使用存储引擎吗">#</a> <strong>8. 在事务中可以混合使用存储引擎吗？</strong></h3><p>尽量不要在同一个事务中使用多种存储引擎，MySQL 服务器层不管理事务，事务是由下层的存储引擎实现的。</p><p>如果在事务中混合使用了事务型和非事务型的表（例如 InnoDB 和 MyISAM 表）, 在正常提交的情况下不会有什么问题。</p><p>但如果该事务需要回滚，非事务型的表上的变更就无法撤销，这会导致数据库处于不一致的状态，这种情况很难修复，事务的最终结果将无法确定。所以，为每张表选择合适的存储引擎非常重要。</p><h3 id="9-mysql中是如何实现事务隔离的"><a class="anchor" href="#9-mysql中是如何实现事务隔离的">#</a> 9. MySQL 中是如何实现事务隔离的？</h3><p>读未提交和串行化基本上是不需要考虑的隔离级别，前者不加锁限制，后者相当于单线程执行，效率太差。</p><p>MySQL 在可重复读级别解决了幻读问题，是通过行锁和间隙锁的组合 Next-Key 锁实现的。</p><p>详细原理看这篇文章：<span class="exturl" data-url="aHR0cHM6Ly9oYWljb2Rlci5uZXQvbm90ZS9NeVNRTC1pbnRlcnZpZXcvTXlTUUwtaW50ZXJ2aWV3LU15U1FMLXRyYW5zLWxldmVsLmh0bWw=">https://haicoder.net/note/MySQL-interview/MySQL-interview-MySQL-trans-level.html</span></p><h3 id="10-什么是-mvcc"><a class="anchor" href="#10-什么是-mvcc">#</a> 10. 什么是 MVCC？</h3><p>MVCC， 即多版本并发控制。MVCC 的实现，是通过保存数据在某个时间点的快照来实现的。根据事务开始的时间不同，每个事务对同一张表，同一时刻看到的数据可能是不一样的。</p><h3 id="11-mvcc-的实现原理"><a class="anchor" href="#11-mvcc-的实现原理">#</a> 11. MVCC 的实现原理</h3><p>对于 InnoDB ，聚簇索引记录中包含 3 个隐藏的列：</p><ul><li>ROW ID：隐藏的自增 ID，如果表没有主键，InnoDB 会自动按 ROW ID 产生一个聚集索引树。</li><li>事务 ID：记录最后一次修改该记录的事务 ID。</li><li>回滚指针：指向这条记录的上一个版本。</li></ul><p>我们拿上面的例子，对应解释下 MVCC 的实现原理，如下图：</p><p><img data-src="http://blog-img.coolsen.cn/img/modb_95751916-225c-11eb-b0bb-5254001c05fe.png" alt="img"></p><p>如图，首先 insert 语句向表 t1 中插入了一条数据，a 字段为 1，b 字段为 1， ROW ID 也为 1 ，事务 ID 假设为 1，回滚指针假设为 null。当执行 update t1 set b=666 where a=1 时，大致步骤如下：</p><ul><li>数据库会先对满足 a=1 的行加排他锁；</li><li>然后将原记录复制到 undo 表空间中；</li><li>修改 b 字段的值为 666，修改事务 ID 为 2；</li><li>并通过隐藏的回滚指针指向 undo log 中的历史记录；</li><li>事务提交，释放前面对满足 a=1 的行所加的排他锁。</li></ul><p>在前面实验的第 6 步中，session2 查询的结果是 session1 修改之前的记录，这个记录就是<strong>来自 undolog</strong> 中。</p><p>因此可以总结出 MVCC 实现的原理大致是：</p><p>InnoDB 每一行数据都有一个隐藏的回滚指针，用于指向该行修改前的最后一个历史版本，这个历史版本存放在 undo log 中。如果要执行更新操作，会将原记录放入 undo log 中，并通过隐藏的回滚指针指向 undo log 中的原记录。其它事务此时需要查询时，就是查询 undo log 中这行数据的最后一个历史版本。</p><p>MVCC 最大的好处是读不加锁，读写不冲突，极大地增加了 MySQL 的并发性。通过 MVCC，保证了事务 ACID 中的 I（隔离性）特性。</p><h2 id="锁"><a class="anchor" href="#锁">#</a> 锁</h2><h3 id="1-为什么要加锁"><a class="anchor" href="#1-为什么要加锁">#</a> 1. 为什么要加锁？</h3><p>当多个用户并发地存取数据时，在数据库 (opens new window) 中就会产生多个事务同时存取同一数据的情况。若对并发操作不加控制就可能会读取和存储不正确的数据，破坏数据库的一致性。</p><p>保证多用户环境下保证数据库完整性和一致性。</p><h3 id="2-按照锁的粒度分数据库锁有哪些"><a class="anchor" href="#2-按照锁的粒度分数据库锁有哪些">#</a> 2. 按照锁的粒度分数据库锁有哪些？</h3><p>在关系型数据库中，可以<strong>按照锁的粒度把数据库锁分</strong>为行级锁 (INNODB 引擎)、表级锁 (MYISAM 引擎) 和页级锁 (BDB 引擎 )。</p><p>行级锁</p><ul><li>行级锁是 MySQL (opens new window) 中锁定粒度最细的一种锁，表示只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，但加锁的开销也最大。行级锁分为共享锁 和 排他锁。</li><li>开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。</li></ul><p>表级锁</p><ul><li>表级锁是 MySQL 中锁定粒度最大的一种锁，表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分 MySQL 引擎支持。最常使用的 MYISAM 与 INNODB 都支持表级锁定。表级锁定分为表共享读锁（共享锁）与表独占写锁（排他锁）。</li><li>开销小，加锁快；不会出现死锁；锁定粒度大，发出锁冲突的概率最高，并发度最低。</li></ul><p>页级锁</p><ul><li>页级锁是 MySQL 中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。BDB 支持页级锁</li><li>开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般</li></ul><p><strong>MyISAM 和 InnoDB 存储引擎使用的锁：</strong></p><ul><li>MyISAM 采用表级锁 (table-level locking)。</li><li>InnoDB 支持行级锁 (row-level locking) 和表级锁，默认为行级锁</li></ul><h3 id="3-从锁的类别上分mysql都有哪些锁呢"><a class="anchor" href="#3-从锁的类别上分mysql都有哪些锁呢">#</a> 3. 从锁的类别上分 MySQL 都有哪些锁呢？</h3><p>从锁的类别上来讲，有共享锁和排他锁。</p><ul><li>共享锁：又叫做读锁。 当用户要进行数据的读取时，对数据加上共享锁。共享锁可以同时加上多个。</li><li>排他锁：又叫做写锁。 当用户要进行数据的写入时，对数据加上排他锁。排他锁只可以加一个，他和其他的排他锁，共享锁都相斥。</li></ul><p>用上面的例子来说就是用户的行为有两种，一种是来看房，多个用户一起看房是可以接受的。 一种是真正的入住一晚，在这期间，无论是想入住的还是想看房的都不可以。</p><p>锁的粒度取决于具体的存储引擎，InnoDB 实现了行级锁，页级锁，表级锁。</p><p>他们的加锁开销从大到小，并发能力也是从大到小。</p><h3 id="4-数据库的乐观锁和悲观锁是什么怎么实现的"><a class="anchor" href="#4-数据库的乐观锁和悲观锁是什么怎么实现的">#</a> 4. 数据库的乐观锁和悲观锁是什么？怎么实现的？</h3><p>数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。乐观并发控制（乐观锁）和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。</p><ul><li>悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。在查询完数据的时候就把事务锁起来，直到提交事务。实现方式：使用数据库中的锁机制</li><li>乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。在修改数据的时候把事务锁起来，通过 version 的方式来进行锁定。实现方式：乐一般会使用版本号机制或 CAS 算法实现。</li></ul><p><strong>两种锁的使用场景</strong></p><p>从上面对两种锁的介绍，我们知道两种锁各有优缺点，不可认为一种好于另一种，像乐观锁适用于写比较少的情况下（多读场景），即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。</p><p>但如果是多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行 retry，这样反倒是降低了性能，所以一般多写的场景下用悲观锁就比较合适。</p><h3 id="5-innodb引擎的行锁是怎么实现的"><a class="anchor" href="#5-innodb引擎的行锁是怎么实现的">#</a> 5. InnoDB 引擎的行锁是怎么实现的？</h3><p>InnoDB 是基于索引来完成行锁</p><p>例: select * from tab_with_index where id = 1 for update;</p><p>for update 可以根据条件来完成行锁锁定，并且 id 是有索引键的列，如果 id 不是索引键那么 InnoDB 将完成表锁，并发将无从谈起</p><h3 id="6-什么是死锁怎么解决"><a class="anchor" href="#6-什么是死锁怎么解决">#</a> 6. 什么是死锁？怎么解决？</h3><p>死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方的资源，从而导致恶性循环的现象。</p><p>常见的解决死锁的方法</p><p>1、如果不同程序会并发存取多个表，尽量约定以相同的顺序访问表，可以大大降低死锁机会。</p><p>2、在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率；</p><p>3、对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率；</p><p>如果业务处理不好可以用分布式事务锁或者使用乐观锁</p><h3 id="7-隔离级别与锁的关系"><a class="anchor" href="#7-隔离级别与锁的关系">#</a> 7. 隔离级别与锁的关系</h3><p>在 Read Uncommitted 级别下，读取数据不需要加共享锁，这样就不会跟被修改的数据上的排他锁冲突</p><p>在 Read Committed 级别下，读操作需要加共享锁，但是在语句执行完以后释放共享锁；</p><p>在 Repeatable Read 级别下，读操作需要加共享锁，但是在事务提交之前并不释放共享锁，也就是必须等待事务执行完毕以后才释放共享锁。</p><p>SERIALIZABLE 是限制性最强的隔离级别，因为该级别锁定整个范围的键，并一直持有锁，直到事务完成。</p><h3 id="8-优化锁方面的意见"><a class="anchor" href="#8-优化锁方面的意见">#</a> 8. 优化锁方面的意见？</h3><ul><li>使用较低的隔离级别</li><li>设计索引，尽量使用索引去访问数据，加锁更加精确，从而减少锁冲突</li><li>选择合理的事务大小，给记录显示加锁时，最好一次性请求足够级别的锁。列如，修改数据的话，最好申请排他锁，而不是先申请共享锁，修改时在申请排他锁，这样会导致死锁</li><li>不同的程序访问一组表的时候，应尽量约定一个相同的顺序访问各表，对于一个表而言，尽可能的固定顺序的获取表中的行。这样大大的减少死锁的机会。</li><li>尽量使用相等条件访问数据，这样可以避免间隙锁对并发插入的影响</li><li>不要申请超过实际需要的锁级别</li><li>数据查询的时候不是必要，不要使用加锁。MySQL 的 MVCC 可以实现事务中的查询不用加锁，优化事务性能：MVCC 只在 committed read（读提交）和 repeatable read （可重复读）两种隔离级别</li><li>对于特定的事务，可以使用表锁来提高处理速度活着减少死锁的可能。</li></ul><h2 id="分库分表"><a class="anchor" href="#分库分表">#</a> 分库分表</h2><h3 id="1-为什么要分库分表"><a class="anchor" href="#1-为什么要分库分表">#</a> 1. 为什么要分库分表？</h3><p><strong>分表</strong></p><p>比如你单表都几千万数据了，你确定你能扛住么？绝对不行，单表数据量太大，会极大影响你的 sql 执行的性能，到了后面你的 sql 可能就跑的很慢了。一般来说，就以我的经验来看，单表到几百万的时候，性能就会相对差一些了，你就得分表了。</p><p>分表就是把一个表的数据放到多个表中，然后查询的时候你就查一个表。比如按照用户 id 来分表，将一个用户的数据就放在一个表中。然后操作的时候你对一个用户就操作那个表就好了。这样可以控制每个表的数据量在可控的范围内，比如每个表就固定在 200 万以内。</p><p><strong>分库</strong></p><p>分库就是你一个库一般我们经验而言，最多支撑到并发 2000，一定要扩容了，而且一个健康的单库并发值你最好保持在每秒 1000 左右，不要太大。那么你可以将一个库的数据拆分到多个库中，访问的时候就访问一个库好了。</p><p>这就是所谓的分库分表。</p><p><img data-src="https://upload-images.jianshu.io/upload_images/14266602-ae74054f45f44e3d?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><h3 id="2-用过哪些分库分表中间件不同的分库分表中间件都有什么优点和缺点"><a class="anchor" href="#2-用过哪些分库分表中间件不同的分库分表中间件都有什么优点和缺点">#</a> 2. 用过哪些分库分表中间件？不同的分库分表中间件都有什么优点和缺点？</h3><p>这个其实就是看看你了解哪些分库分表的中间件，各个中间件的优缺点是啥？然后你用过哪些分库分表的中间件。</p><p>比较常见的包括：</p><ul><li>cobar</li><li>TDDL</li><li>atlas</li><li>sharding-jdbc</li><li>mycat</li></ul><p><strong>cobar</strong></p><p>阿里 b2b 团队开发和开源的，属于 proxy 层方案。早些年还可以用，但是最近几年都没更新了，基本没啥人用，差不多算是被抛弃的状态吧。而且不支持读写分离、存储过程、跨库 join 和分页等操作。</p><p><strong>TDDL</strong></p><p>淘宝团队开发的，属于 client 层方案。支持基本的 crud 语法和读写分离，但不支持 join、多表查询等语法。目前使用的也不多，因为还依赖淘宝的 diamond 配置管理系统。</p><p><strong>atlas</strong></p><p>360 开源的，属于 proxy 层方案，以前是有一些公司在用的，但是确实有一个很大的问题就是社区最新的维护都在 5 年前了。所以，现在用的公司基本也很少了。</p><p><strong>sharding-jdbc</strong></p><p>当当开源的，属于 client 层方案。确实之前用的还比较多一些，因为 SQL 语法支持也比较多，没有太多限制，而且目前推出到了 2.0 版本，支持分库分表、读写分离、分布式 id 生成、柔性事务（最大努力送达型事务、TCC 事务）。而且确实之前使用的公司会比较多一些（这个在官网有登记使用的公司，可以看到从 2017 年一直到现在，是有不少公司在用的），目前社区也还一直在开发和维护，还算是比较活跃，个人认为算是一个现在也<strong>可以选择的方案</strong>。</p><p><strong>mycat</strong></p><p>基于 cobar 改造的，属于 proxy 层方案，支持的功能非常完善，而且目前应该是非常火的而且不断流行的数据库中间件，社区很活跃，也有一些公司开始在用了。但是确实相比于 sharding jdbc 来说，年轻一些，经历的锤炼少一些。</p><h3 id="3-如何对数据库如何进行垂直拆分或水平拆分的"><a class="anchor" href="#3-如何对数据库如何进行垂直拆分或水平拆分的">#</a> 3. 如何对数据库如何进行垂直拆分或水平拆分的？</h3><p><strong>水平拆分</strong>的意思，就是把一个表的数据给弄到多个库的多个表里去，但是每个库的表结构都一样，只不过每个库表放的数据是不同的，所有库表的数据加起来就是全部数据。水平拆分的意义，就是将数据均匀放更多的库里，然后用多个库来抗更高的并发，还有就是用多个库的存储容量来进行扩容。</p><p><img data-src="https://upload-images.jianshu.io/upload_images/10089464-0e01dfe246b5c7ac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/474/format/webp" alt="img"></p><p><strong>垂直拆分</strong>的意思，就是<strong>把一个有很多字段的表给拆分成多个表</strong>，<strong>或者是多个库上去</strong>。每个库表的结构都不一样，每个库表都包含部分字段。一般来说，会<strong>将较少的访问频率很高的字段放到一个表里去</strong>，然后<strong>将较多的访问频率很低的字段放到另外一个表里去</strong>。因为数据库是有缓存的，你访问频率高的行字段越少，就可以在缓存里缓存更多的行，性能就越好。这个一般在表层面做的较多一些。</p><p><img data-src="https://upload-images.jianshu.io/upload_images/10089464-ab3069913c0f097c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/320/format/webp" alt="img"></p><p>两种<strong>分库分表的方式</strong>：</p><ul><li>一种是按照 range 来分，就是每个库一段连续的数据，这个一般是按比如<strong>时间范围</strong>来的，但是这种一般较少用，因为很容易产生热点问题，大量的流量都打在最新的数据上了。</li><li>或者是按照某个字段 hash 一下均匀分散，这个较为常用。</li></ul><p>range 来分，好处在于说，扩容的时候很简单，因为你只要预备好，给每个月都准备一个库就可以了，到了一个新的月份的时候，自然而然，就会写新的库了；缺点，但是大部分的请求，都是访问最新的数据。实际生产用 range，要看场景。</p><p>hash 分发，好处在于说，可以平均分配每个库的数据量和请求压力；坏处在于说扩容起来比较麻烦，会有一个数据迁移的过程，之前的数据需要重新计算 hash 值重新分配到不同的库或表</p><h2 id="读写分离-主从同步"><a class="anchor" href="#读写分离-主从同步">#</a> 读写分离、主从同步</h2><h3 id="1-什么是mysql主从同步"><a class="anchor" href="#1-什么是mysql主从同步">#</a> 1. 什么是 MySQL 主从同步？</h3><p>主从同步使得数据可以从一个数据库服务器复制到其他服务器上，在复制数据时，一个服务器充当主服务器（master），其余的服务器充当从服务器（slave）。</p><p>因为复制是异步进行的，所以从服务器不需要一直连接着主服务器，从服务器甚至可以通过拨号断断续续地连接主服务器。通过配置文件，可以指定复制所有的数据库，某个数据库，甚至是某个数据库上的某个表。</p><h3 id="2-mysql主从同步的目的为什么要做主从同步"><a class="anchor" href="#2-mysql主从同步的目的为什么要做主从同步">#</a> 2. MySQL 主从同步的目的？为什么要做主从同步？</h3><ol><li>通过增加从服务器来提高数据库的性能，在主服务器上执行写入和更新，在从服务器上向外提供读功能，可以动态地调整从服务器的数量，从而调整整个数据库的性能。</li><li>提高数据安全 - 因为数据已复制到从服务器，从服务器可以终止复制进程，所以，可以在从服务器上备份而不破坏主服务器相应数据</li><li>在主服务器上生成实时数据，而在从服务器上分析这些数据，从而提高主服务器的性能</li><li>数据备份。一般我们都会做数据备份，可能是写定时任务，一些特殊行业可能还需要手动备份，有些行业要求备份和原数据不能在同一个地方，所以主从就能很好的解决这个问题，不仅备份及时，而且还可以多地备份，保证数据的安全</li></ol><h3 id="3-如何实现mysql的读写分离"><a class="anchor" href="#3-如何实现mysql的读写分离">#</a> 3. 如何实现 MySQL 的读写分离？</h3><p>其实很简单，就是基于主从复制架构，简单来说，就搞一个主库，挂多个从库，然后我们就单单只是写主库，然后主库会自动把数据给同步到从库上去。</p><h3 id="4-mysql主从复制流程和原理"><a class="anchor" href="#4-mysql主从复制流程和原理">#</a> 4. MySQL 主从复制流程和原理？</h3><p>基本原理流程，是 3 个线程以及之间的关联</p><p>主：binlog 线程 —— 记录下所有改变了数据库数据的语句，放进 master 上的 binlog 中；</p><p>从：io 线程 —— 在使用 start slave 之后，负责从 master 上拉取 binlog 内容，放进自己的 relay log 中；</p><p>从：sql 执行线程 —— 执行 relay log 中的语句；</p><p><strong>复制过程如下</strong>：</p><p><img data-src="http://blog-img.coolsen.cn/img/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC85LzIxLzE2NWZiNjgzMjIyMDViMmU" alt="img"></p><p>Binary log：主数据库的二进制日志</p><p>Relay log：从服务器的中继日志</p><p>第一步：master 在每个事务更新数据完成之前，将该操作记录串行地写入到 binlog 文件中。</p><p>第二步：salve 开启一个 I/O Thread，该线程在 master 打开一个普通连接，主要工作是 binlog dump process。如果读取的进度已经跟上了 master，就进入睡眠状态并等待 master 产生新的事件。I/O 线程最终的目的是将这些事件写入到中继日志中。</p><p>第三步：SQL Thread 会读取中继日志，并顺序执行该日志中的 SQL 事件，从而与主数据库中的数据保持一致。</p><h3 id="5-mysql主从同步延时问题如何解决"><a class="anchor" href="#5-mysql主从同步延时问题如何解决">#</a> 5. MySQL 主从同步延时问题如何解决？</h3><p>MySQL 实际上在有两个同步机制，一个是半同步复制，用来 解决主库数据丢失问题；一个是并行复制，用来 解决主从同步延时问题。</p><ul><li>半同步复制，也叫 semi-sync 复制，指的就是主库写入 binlog 日志之后，就会将强制此时立即将数据同步到从库，从库将日志写入自己本地的 relay log 之后，接着会返回一个 ack 给主库，主库接收到至少一个从库的 ack 之后才会认为写操作完成了。</li><li>并行复制，指的是从库开启多个线程，并行读取 relay log 中不同库的日志，然后并行重放不同库的日志，这是库级别的并行。</li></ul><h2 id="mysql优化"><a class="anchor" href="#mysql优化">#</a> MySQL 优化</h2><h3 id="1-如何定位及优化sql语句的性能问题"><a class="anchor" href="#1-如何定位及优化sql语句的性能问题">#</a> 1. 如何定位及优化 SQL 语句的性能问题？</h3><p>对于低性能的 SQL 语句的定位，最重要也是最有效的方法就是使用执行计划，MySQL 提供了 explain 命令来查看语句的执行计划。 我们知道，不管是哪种数据库，或者是哪种数据库引擎，在对一条 SQL 语句进行执行的过程中都会做很多相关的优化，对于查询语句，最重要的优化方式就是使用索引。</p><p>而执行计划，就是显示数据库引擎对于 SQL 语句的执行的详细情况，其中包含了是否使用索引，使用什么索引，使用的索引的相关信息等。 <img data-src="http://blog-img.coolsen.cn/img/image-20210822204026552.png" alt="image-20210822204026552"></p><h3 id="2-大表数据查询怎么优化"><a class="anchor" href="#2-大表数据查询怎么优化">#</a> 2. 大表数据查询，怎么优化</h3><ul><li>优化 shema、sql 语句 + 索引；</li><li>第二加缓存，memcached, redis；</li><li>主从复制，读写分离；</li><li>垂直拆分，根据你模块的耦合度，将一个大的系统分为多个小的系统，也就是分布式系统；</li><li>水平切分，针对数据量大的表，这一步最麻烦，最能考验技术水平，要选择一个合理的 sharding key, 为了有好的查询效率，表结构也要改动，做一定的冗余，应用也要改，sql 中尽量带 sharding key，将数据定位到限定的表上去查，而不是扫描全部的表；</li></ul><h3 id="3-超大分页怎么处理"><a class="anchor" href="#3-超大分页怎么处理">#</a> 3. 超大分页怎么处理？</h3><p>数据库层面，这也是我们主要集中关注的 (虽然收效没那么大), 类似于 <code>select * from table where age &gt; 20 limit 1000000</code> ,10 这种查询其实也是有可以优化的余地的。这条语句需要 load1000000 数据然后基本上全部丢弃，只取 10 条当然比较慢。当时我们可以修改为 <code>select * from table where id in (select id from table where age &gt; 20 limit 1000000,10)</code> . 这样虽然也 load 了一百万的数据，但是由于索引覆盖，要查询的所有字段都在索引中，所以速度会很快。</p><p>解决超大分页，其实主要是靠缓存，可预测性的提前查到内容，缓存至 redis 等 k-V 数据库中，直接返回即可.</p><p>在阿里巴巴《Java 开发手册》中，对超大分页的解决办法是类似于上面提到的第一种.</p><blockquote><p>【推荐】利用延迟关联或者子查询优化超多分页场景。</p><p>说明：MySQL 并不是跳过 offset 行，而是取 offset+N 行，然后返回放弃前 offset 行，返回 N 行，那当 offset 特别大的时候，效率就非常的低下，要么控制返回的总页数，要么对超过特定阈值的页数进行 SQL 改写。</p><p>正例：先快速定位需要获取的 id 段，然后再关联：</p><p>SELECT a.* FROM 表 1 a, (select id from 表 1 where 条件 LIMIT 100000,20) b where <span class="exturl" data-url="aHR0cDovL2EuaWQ9Yi5pZA==">a.id=b.id</span></p></blockquote><h3 id="4-统计过慢查询吗对慢查询都怎么优化过"><a class="anchor" href="#4-统计过慢查询吗对慢查询都怎么优化过">#</a> 4. 统计过慢查询吗？对慢查询都怎么优化过？</h3><p>在业务系统中，除了使用主键进行的查询，其他的我都会在测试库上测试其耗时，慢查询的统计主要由运维在做，会定期将业务中的慢查询反馈给我们。</p><p>慢查询的优化首先要搞明白慢的原因是什么？ 是查询条件没有命中索引？是 load 了不需要的数据列？还是数据量太大？</p><p>所以优化也是针对这三个方向来的，</p><ul><li>首先分析语句，看看是否 load 了额外的数据，可能是查询了多余的行并且抛弃掉了，可能是加载了许多结果中并不需要的列，对语句进行分析以及重写。</li><li>分析语句的执行计划，然后获得其使用索引的情况，之后修改语句或者修改索引，使得语句可以尽可能的命中索引。</li><li>如果对语句的优化已经无法进行，可以考虑表中的数据量是否太大，如果是的话可以进行横向或者纵向的分表。</li></ul><h3 id="5-如何优化查询过程中的数据访问"><a class="anchor" href="#5-如何优化查询过程中的数据访问">#</a> 5. 如何优化查询过程中的数据访问</h3><ul><li>访问数据太多导致查询性能下降</li><li>确定应用程序是否在检索大量超过需要的数据，可能是太多行或列</li><li>确认 MySQL 服务器是否在分析大量不必要的数据行</li><li>查询不需要的数据。解决办法：使用 limit 解决</li><li>多表关联返回全部列。解决办法：指定列名</li><li>总是返回全部列。解决办法：避免使用 SELECT *</li><li>重复查询相同的数据。解决办法：可以缓存数据，下次直接读取缓存</li><li>是否在扫描额外的记录。解决办法： 使用 explain 进行分析，如果发现查询需要扫描大量的数据，但只返回少数的行，可以通过如下技巧去优化： 使用索引覆盖扫描，把所有的列都放到索引中，这样存储引擎不需要回表获取对应行就可以返回结果。</li><li>改变数据库和表的结构，修改数据表范式</li><li>重写 SQL 语句，让优化器可以以更优的方式执行查询。</li></ul><h3 id="6-如何优化关联查询"><a class="anchor" href="#6-如何优化关联查询">#</a> 6. 如何优化关联查询</h3><ul><li>确定 ON 或者 USING 子句中是否有索引。</li><li>确保 GROUP BY 和 ORDER BY 只有一个表中的列，这样 MySQL 才有可能使用索引。</li></ul><h3 id="7-数据库结构优化"><a class="anchor" href="#7-数据库结构优化">#</a> 7. 数据库结构优化</h3><p>一个好的数据库设计方案对于数据库的性能往往会起到事半功倍的效果。</p><p>需要考虑数据冗余、查询和更新的速度、字段的数据类型是否合理等多方面的内容。</p><ol><li><strong>将字段很多的表分解成多个表</strong></li></ol><p>对于字段较多的表，如果有些字段的使用频率很低，可以将这些字段分离出来形成新表。</p><p>因为当一个表的数据量很大时，会由于使用频率低的字段的存在而变慢。</p><ol><li><strong>增加中间表</strong></li></ol><p>对于需要经常联合查询的表，可以建立中间表以提高查询效率。</p><p>通过建立中间表，将需要通过联合查询的数据插入到中间表中，然后将原来的联合查询改为对中间表的查询。</p><ol><li><strong>增加冗余字段</strong></li></ol><p>设计数据表时应尽量遵循范式理论的规约，尽可能的减少冗余字段，让数据库设计看起来精致、优雅。但是，合理的加入冗余字段可以提高查询速度。</p><p>表的规范化程度越高，表和表之间的关系越多，需要连接查询的情况也就越多，性能也就越差。</p><p>注意：</p><p>冗余字段的值在一个表中修改了，就要想办法在其他表中更新，否则就会导致数据不一致的问题。</p><h3 id="8-mysql数据库cpu飙升到500的话他怎么处理"><a class="anchor" href="#8-mysql数据库cpu飙升到500的话他怎么处理">#</a> 8. MySQL 数据库 cpu 飙升到 500% 的话他怎么处理？</h3><p>当 cpu 飙升到 500% 时，先用操作系统命令 top 命令观察是不是 MySQLd 占用导致的，如果不是，找出占用高的进程，并进行相关处理。</p><p>如果是 MySQLd 造成的， show processlist，看看里面跑的 session 情况，是不是有消耗资源的 sql 在运行。找出消耗高的 sql，看看执行计划是否准确， index 是否缺失，或者实在是数据量太大造成。</p><p>一般来说，肯定要 kill 掉这些线程 (同时观察 cpu 使用率是否下降)，等进行相应的调整 (比如说加索引、改 sql、改内存参数) 之后，再重新跑这些 SQL。</p><p>也有可能是每个 sql 消耗资源并不多，但是突然之间，有大量的 session 连进来导致 cpu 飙升，这种情况就需要跟应用一起来分析为何连接数会激增，再做出相应的调整，比如说限制连接数等。</p><h3 id="9-大表怎么优化"><a class="anchor" href="#9-大表怎么优化">#</a> 9. 大表怎么优化？</h3><p>类似的问题：某个表有近千万数据，CRUD 比较慢，如何优化？分库分表了是怎么做的？分表分库了有什么问题？有用到中间件么？他们的原理知道么？</p><p>当 MySQL 单表记录数过大时，数据库的 CRUD 性能会明显下降，一些常见的优化措施如下：</p><ul><li>限定数据的范围： 务必禁止不带任何限制数据范围条件的查询语句。比如：我们当用户在查询订单历史的时候，我们可以控制在一个月的范围内；</li><li>读 / 写分离： 经典的数据库拆分方案，主库负责写，从库负责读；</li><li>缓存： 使用 MySQL 的缓存，另外对重量级、更新少的数据可以考虑；</li><li>通过分库分表的方式进行优化，主要有垂直分表和水平分表。</li></ul></div><div class="tags"><a href="/tags/mysql/" rel="tag"><i class="ic i-tag"></i>mysql</a></div></div><footer><div class="meta"><span class="icon"><i class="ic i-eye"></i></span><span>此文章已被阅读次数:</span><span class="waline-pageview-count" id="twikoo_visitors" data-path="2023/10/22/database/sql/mysql/Java面试题-06-Mysql篇/">正在加载...</span><span class="item"><span class="icon"><i class="ic i-calendar-check"></i></span><span class="text">更新于</span><time title="修改时间：2023-10-30 10:37:15" itemprop="dateModified" datetime="2023-10-30T10:37:15+08:00">2023-10-30</time></span><script type="module" data-pjax="data-pjax">import { pageviewCount } from 'https://unpkg.com/@waline/client/dist/pageview.mjs';

const path = document.getElementById("twikoo_visitors").getAttribute("data-path");
pageviewCount({
    serverURL: 'waline-biya.vercel.app',
    path: path,
});</script></div><div class="reward"><button><i class="ic i-heartbeat"></i>赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/assets/wechatpay.png" alt="biya 微信支付"><p>微信支付</p></div><div><img data-src="/assets/alipay.png" alt="biya 支付宝"><p>支付宝</p></div><div><img data-src="/assets/paypal.png" alt="biya 贝宝"><p>贝宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者：</strong>biya<i class="ic i-at"><em>@</em></i>夢のない賢魚です</li><li class="link"><strong>本文链接：</strong><a href="https://sbysg.github.io/2023/10/22/database/sql/mysql/Java%E9%9D%A2%E8%AF%95%E9%A2%98-06-Mysql%E7%AF%87/" title="mysql">https://sbysg.github.io/2023/10/22/database/sql/mysql/Java面试题-06-Mysql篇/</a></li><li class="license"><strong>版权声明：</strong>本站所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2023/10/22/linux/docker/docker/Docker/" rel="prev" itemprop="url" data-background-image="https:&#x2F;&#x2F;tva3.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1gipevgoki5j20zk0m84qp.jpg" title="docker"><span class="type">上一篇</span><span class="category"><i class="ic i-flag"></i>Docker</span><h3>docker</h3></a></div><div class="item right"><a href="/2023/10/22/database/no-sql/redis/Java%E9%9D%A2%E8%AF%95%E9%A2%98-07-Redis/" rel="next" itemprop="url" data-background-image="https:&#x2F;&#x2F;tva3.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1gipeuv80yoj20zk0m8kjl.jpg" title="redis"><span class="type">下一篇</span><span class="category"><i class="ic i-flag"></i>数据库</span><h3>redis</h3></a></div></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#java%E9%9D%A2%E8%AF%95%E9%A2%98-mysql%E7%AF%87"><span class="toc-number">1.</span> <span class="toc-text">Java 面试题 - Mysql 篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#mysql%E5%B8%B8%E8%A7%81"><span class="toc-number">1.1.</span> <span class="toc-text">Mysql 常见</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-mysql%E4%B8%ADmyisam%E4%B8%8Einnodb%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.1.1.</span> <span class="toc-text">1. MySQL 中 myisam 与 innodb 的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BA%8B%E5%8A%A1%E7%9A%84%E7%89%B9%E6%80%A7"><span class="toc-number">1.1.2.</span> <span class="toc-text">2. 事务的特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%B9%B6%E5%8F%91%E6%93%8D%E4%BD%9C%E9%97%AE%E9%A2%98"><span class="toc-number">1.1.3.</span> <span class="toc-text">3. 并发操作问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-number">1.1.4.</span> <span class="toc-text">4. 事务的隔离级别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E7%B4%A2%E5%BC%95%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.1.5.</span> <span class="toc-text">5. 索引是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E7%B4%A2%E5%BC%95%E8%83%BD%E5%B9%B2%E4%BB%80%E4%B9%88%E6%9C%89%E4%BB%80%E4%B9%88%E5%A5%BD%E5%A4%84"><span class="toc-number">1.1.6.</span> <span class="toc-text">6. 索引能干什么？有什么好处？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E7%B4%A2%E5%BC%95%E7%9A%84%E7%A7%8D%E7%B1%BB%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">1.1.7.</span> <span class="toc-text">7. 索引的种类有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E4%B8%BA%E4%BB%80%E4%B9%88-mysql-%E7%9A%84%E7%B4%A2%E5%BC%95%E8%A6%81%E4%BD%BF%E7%94%A8-b%E6%A0%91%E8%80%8C%E4%B8%8D%E6%98%AF%E5%85%B6%E5%AE%83%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84%E6%AF%94%E5%A6%82-b-%E6%A0%91"><span class="toc-number">1.1.8.</span> <span class="toc-text">8. 为什么 MySQL 的索引要使用 B + 树而不是其它树形结构？比如 B 树？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-myisam%E5%92%8Cinnodb%E5%AE%9E%E7%8E%B0btree%E7%B4%A2%E5%BC%95%E6%96%B9%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.1.9.</span> <span class="toc-text">9. MyISAM 和 InnoDB 实现 BTree 索引方式的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%80%E5%B7%A6%E5%8C%B9%E9%85%8D%E5%8E%9F%E5%88%99"><span class="toc-number">1.1.10.</span> <span class="toc-text">10. 什么是最左匹配原则？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E5%93%AA%E4%BA%9B%E5%88%97%E4%B8%8A%E9%80%82%E5%90%88%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95%E6%9C%89%E5%93%AA%E4%BA%9B%E5%BC%80%E9%94%80"><span class="toc-number">1.1.11.</span> <span class="toc-text">11. 哪些列上适合创建索引？创建索引有哪些开销？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-%E7%B4%A2%E5%BC%95%E8%BF%99%E4%B9%88%E5%A4%9A%E4%BC%98%E7%82%B9%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%AF%B9%E8%A1%A8%E4%B8%AD%E7%9A%84%E6%AF%8F%E4%B8%80%E4%B8%AA%E5%88%97%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%B4%A2%E5%BC%95%E5%91%A2"><span class="toc-number">1.1.12.</span> <span class="toc-text">12. 索引这么多优点，为什么不对表中的每一个列创建一个索引呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-mysql%E5%BB%BA%E8%A1%A8%E7%9A%84%E7%BA%A6%E6%9D%9F%E6%9D%A1%E4%BB%B6%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">1.1.13.</span> <span class="toc-text">13. MySQL 建表的约束条件有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-mysql%E6%89%A7%E8%A1%8C%E6%9F%A5%E8%AF%A2%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">1.1.14.</span> <span class="toc-text">14. MySQL 执行查询的过程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-mysql%E7%9A%84binlog%E6%9C%89%E6%9C%89%E5%87%A0%E7%A7%8D%E5%BD%95%E5%85%A5%E6%A0%BC%E5%BC%8F%E5%88%86%E5%88%AB%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">1.1.15.</span> <span class="toc-text">15. MySQL 的 binlog 有有几种录入格式？分别有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%89%E8%8C%83%E5%BC%8F%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.1.16.</span> <span class="toc-text">16. 数据库的三范式是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-mysql-%E6%94%AF%E6%8C%81%E5%93%AA%E4%BA%9B%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="toc-number">1.1.17.</span> <span class="toc-text">17. MySQL 支持哪些存储引擎？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-%E8%B6%85%E9%94%AE-%E5%80%99%E9%80%89%E9%94%AE-%E4%B8%BB%E9%94%AE-%E5%A4%96%E9%94%AE%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.1.18.</span> <span class="toc-text">18. 超键、候选键、主键、外键分别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-sql-%E7%BA%A6%E6%9D%9F%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D"><span class="toc-number">1.1.19.</span> <span class="toc-text">19. SQL 约束有哪几种？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-mysql-%E4%B8%AD%E7%9A%84-varchar-%E5%92%8C-char-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">1.1.20.</span> <span class="toc-text">20. MySQL 中的 varchar 和 char 有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-mysql%E4%B8%AD-in-%E5%92%8C-exists-%E5%8C%BA%E5%88%AB"><span class="toc-number">1.1.21.</span> <span class="toc-text">21. MySQL 中 in 和 exists 区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-drop-delete%E4%B8%8Etruncate%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.1.22.</span> <span class="toc-text">22. drop、delete 与 truncate 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-%E4%BB%80%E4%B9%88%E6%98%AF%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">1.1.23.</span> <span class="toc-text">23. 什么是存储过程？有哪些优缺点？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1"><span class="toc-number">1.2.</span> <span class="toc-text">事务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1"><span class="toc-number">1.2.1.</span> <span class="toc-text">1. 什么是数据库事务？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E4%BA%8B%E5%8A%A1%E5%85%B7%E6%9C%89%E7%9A%84%E5%9B%9B%E4%B8%AA%E7%89%B9%E5%BE%81"><span class="toc-number">1.2.2.</span> <span class="toc-text">2. 介绍一下事务具有的四个特征</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%AF%B4%E4%B8%80%E4%B8%8Bmysql-%E7%9A%84%E5%9B%9B%E7%A7%8D%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-number">1.2.3.</span> <span class="toc-text">3. 说一下 MySQL 的四种隔离级别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%BB%80%E4%B9%88%E6%98%AF%E8%84%8F%E8%AF%BB%E5%B9%BB%E8%AF%BB%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB"><span class="toc-number">1.2.4.</span> <span class="toc-text">4. 什么是脏读？幻读？不可重复读？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">1.2.5.</span> <span class="toc-text">5. 事务的实现原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-mysql%E4%BA%8B%E5%8A%A1%E6%97%A5%E5%BF%97%E4%BB%8B%E7%BB%8D%E4%B8%8B"><span class="toc-number">1.2.6.</span> <span class="toc-text">6. MySQL 事务日志介绍下？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E4%BB%80%E4%B9%88%E6%98%AFmysql%E7%9A%84-binlog"><span class="toc-number">1.2.7.</span> <span class="toc-text">7. 什么是 MySQL 的 binlog？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E5%9C%A8%E4%BA%8B%E5%8A%A1%E4%B8%AD%E5%8F%AF%E4%BB%A5%E6%B7%B7%E5%90%88%E4%BD%BF%E7%94%A8%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E5%90%97"><span class="toc-number">1.2.8.</span> <span class="toc-text">8. 在事务中可以混合使用存储引擎吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-mysql%E4%B8%AD%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%9A%84"><span class="toc-number">1.2.9.</span> <span class="toc-text">9. MySQL 中是如何实现事务隔离的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E4%BB%80%E4%B9%88%E6%98%AF-mvcc"><span class="toc-number">1.2.10.</span> <span class="toc-text">10. 什么是 MVCC？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-mvcc-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">1.2.11.</span> <span class="toc-text">11. MVCC 的实现原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%81"><span class="toc-number">1.3.</span> <span class="toc-text">锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%8A%A0%E9%94%81"><span class="toc-number">1.3.1.</span> <span class="toc-text">1. 为什么要加锁？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%8C%89%E7%85%A7%E9%94%81%E7%9A%84%E7%B2%92%E5%BA%A6%E5%88%86%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">1.3.2.</span> <span class="toc-text">2. 按照锁的粒度分数据库锁有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%BB%8E%E9%94%81%E7%9A%84%E7%B1%BB%E5%88%AB%E4%B8%8A%E5%88%86mysql%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E9%94%81%E5%91%A2"><span class="toc-number">1.3.3.</span> <span class="toc-text">3. 从锁的类别上分 MySQL 都有哪些锁呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81%E6%98%AF%E4%BB%80%E4%B9%88%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="toc-number">1.3.4.</span> <span class="toc-text">4. 数据库的乐观锁和悲观锁是什么？怎么实现的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-innodb%E5%BC%95%E6%93%8E%E7%9A%84%E8%A1%8C%E9%94%81%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="toc-number">1.3.5.</span> <span class="toc-text">5. InnoDB 引擎的行锁是怎么实现的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E4%BB%80%E4%B9%88%E6%98%AF%E6%AD%BB%E9%94%81%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3"><span class="toc-number">1.3.6.</span> <span class="toc-text">6. 什么是死锁？怎么解决？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%B8%8E%E9%94%81%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">1.3.7.</span> <span class="toc-text">7. 隔离级别与锁的关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E4%BC%98%E5%8C%96%E9%94%81%E6%96%B9%E9%9D%A2%E7%9A%84%E6%84%8F%E8%A7%81"><span class="toc-number">1.3.8.</span> <span class="toc-text">8. 优化锁方面的意见？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8"><span class="toc-number">1.4.</span> <span class="toc-text">分库分表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8"><span class="toc-number">1.4.1.</span> <span class="toc-text">1. 为什么要分库分表？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%94%A8%E8%BF%87%E5%93%AA%E4%BA%9B%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B8%8D%E5%90%8C%E7%9A%84%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%83%BD%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E7%82%B9%E5%92%8C%E7%BC%BA%E7%82%B9"><span class="toc-number">1.4.2.</span> <span class="toc-text">2. 用过哪些分库分表中间件？不同的分库分表中间件都有什么优点和缺点？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%A6%82%E4%BD%95%E5%AF%B9%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E5%9E%82%E7%9B%B4%E6%8B%86%E5%88%86%E6%88%96%E6%B0%B4%E5%B9%B3%E6%8B%86%E5%88%86%E7%9A%84"><span class="toc-number">1.4.3.</span> <span class="toc-text">3. 如何对数据库如何进行垂直拆分或水平拆分的？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB-%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5"><span class="toc-number">1.5.</span> <span class="toc-text">读写分离、主从同步</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AFmysql%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5"><span class="toc-number">1.5.1.</span> <span class="toc-text">1. 什么是 MySQL 主从同步？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-mysql%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E7%9A%84%E7%9B%AE%E7%9A%84%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%81%9A%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5"><span class="toc-number">1.5.2.</span> <span class="toc-text">2. MySQL 主从同步的目的？为什么要做主从同步？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0mysql%E7%9A%84%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB"><span class="toc-number">1.5.3.</span> <span class="toc-text">3. 如何实现 MySQL 的读写分离？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E6%B5%81%E7%A8%8B%E5%92%8C%E5%8E%9F%E7%90%86"><span class="toc-number">1.5.4.</span> <span class="toc-text">4. MySQL 主从复制流程和原理？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-mysql%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E5%BB%B6%E6%97%B6%E9%97%AE%E9%A2%98%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3"><span class="toc-number">1.5.5.</span> <span class="toc-text">5. MySQL 主从同步延时问题如何解决？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mysql%E4%BC%98%E5%8C%96"><span class="toc-number">1.6.</span> <span class="toc-text">MySQL 优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%A6%82%E4%BD%95%E5%AE%9A%E4%BD%8D%E5%8F%8A%E4%BC%98%E5%8C%96sql%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98"><span class="toc-number">1.6.1.</span> <span class="toc-text">1. 如何定位及优化 SQL 语句的性能问题？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%A4%A7%E8%A1%A8%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2%E6%80%8E%E4%B9%88%E4%BC%98%E5%8C%96"><span class="toc-number">1.6.2.</span> <span class="toc-text">2. 大表数据查询，怎么优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%B6%85%E5%A4%A7%E5%88%86%E9%A1%B5%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86"><span class="toc-number">1.6.3.</span> <span class="toc-text">3. 超大分页怎么处理？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%BB%9F%E8%AE%A1%E8%BF%87%E6%85%A2%E6%9F%A5%E8%AF%A2%E5%90%97%E5%AF%B9%E6%85%A2%E6%9F%A5%E8%AF%A2%E9%83%BD%E6%80%8E%E4%B9%88%E4%BC%98%E5%8C%96%E8%BF%87"><span class="toc-number">1.6.4.</span> <span class="toc-text">4. 统计过慢查询吗？对慢查询都怎么优化过？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%E6%9F%A5%E8%AF%A2%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE"><span class="toc-number">1.6.5.</span> <span class="toc-text">5. 如何优化查询过程中的数据访问</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%E5%85%B3%E8%81%94%E6%9F%A5%E8%AF%A2"><span class="toc-number">1.6.6.</span> <span class="toc-text">6. 如何优化关联查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BB%93%E6%9E%84%E4%BC%98%E5%8C%96"><span class="toc-number">1.6.7.</span> <span class="toc-text">7. 数据库结构优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-mysql%E6%95%B0%E6%8D%AE%E5%BA%93cpu%E9%A3%99%E5%8D%87%E5%88%B0500%E7%9A%84%E8%AF%9D%E4%BB%96%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86"><span class="toc-number">1.6.8.</span> <span class="toc-text">8. MySQL 数据库 cpu 飙升到 500% 的话他怎么处理？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E5%A4%A7%E8%A1%A8%E6%80%8E%E4%B9%88%E4%BC%98%E5%8C%96"><span class="toc-number">1.6.9.</span> <span class="toc-text">9. 大表怎么优化？</span></a></li></ol></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/2023/10/22/database/no-sql/redis/Java%E9%9D%A2%E8%AF%95%E9%A2%98-07-Redis/" rel="bookmark" title="redis">redis</a></li><li class="active"><a href="/2023/10/22/database/sql/mysql/Java%E9%9D%A2%E8%AF%95%E9%A2%98-06-Mysql%E7%AF%87/" rel="bookmark" title="mysql">mysql</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="biya" data-src="/assets/avatar.jpg"><p class="name" itemprop="name">biya</p><div class="description" itemprop="description">摸鱼之道，就在其中</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">13</span><span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">12</span><span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">12</span><span class="name">标签</span></a></div></nav><div class="social"><a href="https://github.com/sbysg" class="item github" rel="noopener" title="https:&#x2F;&#x2F;github.com&#x2F;sbysg" target="_blank"><i class="ic i-github"></i></a><a href="https://www.zhihu.com/people/xin-han-91-91" class="item zhihu" rel="noopener" title="https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;xin-han-91-91" target="_blank"><i class="ic i-zhihu"></i></a><a href="https://music.163.com/#/user/home?id=1657896798" class="item music" rel="noopener" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;1657896798" target="_blank"><i class="ic i-cloud-music"></i></a><a href="https://weibo.com/u/6667154460" class="item weibo" rel="noopener" title="https:&#x2F;&#x2F;weibo.com&#x2F;u&#x2F;6667154460" target="_blank"><i class="ic i-weibo"></i></a><a href="https://about.me/biyahan" class="item about" rel="noopener" title="https:&#x2F;&#x2F;about.me&#x2F;biyahan" target="_blank"><i class="ic i-address-card"></i></a><a href="https://t.me/kill_biya" class="item telegram" rel="noopener" title="https:&#x2F;&#x2F;t.me&#x2F;kill_biya" target="_blank"><i class="ic i-paper-plane"></i></a><a href="https://stackoverflow.com/users/22783860/kill-biya/" class="item stackoverflow" rel="noopener" title="https:&#x2F;&#x2F;stackoverflow.com&#x2F;users&#x2F;22783860&#x2F;kill-biya&#x2F;" target="_blank"><i class="ic i-stack-overflow"></i></a></div><div class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-user"></i>关于</a><ul class="submenu"><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于本站</a></li><li class="item"><a href="/admiration/" rel="section"><i class="ic i-coffee"></i>赞赏博主</a></li></ul></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>友達</a></li></div></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2023/10/22/database/no-sql/redis/Java%E9%9D%A2%E8%AF%95%E9%A2%98-07-Redis/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2023/10/22/linux/docker/docker/Docker/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/springframe/" title="分类于Java框架">Java框架</a><i class="ic i-angle-right"></i><a href="/categories/springframe/spring/" title="分类于Spring全家桶">Spring全家桶</a></div><span><a href="/2023/10/22/springframe/spring/springcloud/SpringCloud/">springcloud</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/springframe/" title="分类于Java框架">Java框架</a><i class="ic i-angle-right"></i><a href="/categories/springframe/spring/" title="分类于Spring全家桶">Spring全家桶</a><i class="ic i-angle-right"></i><a href="/categories/springframe/spring/mybatis/" title="分类于Mybatis">Mybatis</a></div><span><a href="/2023/10/22/springframe/spring/mybatis/mybatis/MyBatis/">mybatis</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/backend/" title="分类于Java后端">Java后端</a><i class="ic i-angle-right"></i><a href="/categories/backend/java/" title="分类于Java">Java</a><i class="ic i-angle-right"></i><a href="/categories/backend/java/base/" title="分类于Java基础">Java基础</a></div><span><a href="/2023/10/22/backend/java/base/first/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/">hi biya</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/springframe/" title="分类于Java框架">Java框架</a><i class="ic i-angle-right"></i><a href="/categories/springframe/spring/" title="分类于Spring全家桶">Spring全家桶</a></div><span><a href="/2023/10/22/springframe/spring/springboot/springboot-01-class/">springboot</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/linux/" title="分类于Linux">Linux</a><i class="ic i-angle-right"></i><a href="/categories/linux/docker/" title="分类于Docker">Docker</a></div><span><a href="/2023/10/22/linux/docker/rabbitMQ/RabbitMQ/">rabbitMQ</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/database/" title="分类于数据库">数据库</a></div><span><a href="/2023/10/22/database/no-sql/redis/Java%E9%9D%A2%E8%AF%95%E9%A2%98-07-Redis/">redis</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/backend/" title="分类于Java后端">Java后端</a><i class="ic i-angle-right"></i><a href="/categories/backend/java/" title="分类于Java">Java</a><i class="ic i-angle-right"></i><a href="/categories/backend/java/base/" title="分类于Java基础">Java基础</a></div><span><a href="/2023/10/22/backend/java/base/%E7%88%AA%E5%93%87%E5%A7%A8%E5%A7%A8/">爪哇基础</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/springframe/" title="分类于Java框架">Java框架</a><i class="ic i-angle-right"></i><a href="/categories/springframe/spring/" title="分类于Spring全家桶">Spring全家桶</a><i class="ic i-angle-right"></i><a href="/categories/springframe/spring/mybatis/" title="分类于Mybatis">Mybatis</a></div><span><a href="/2023/10/22/springframe/spring/mybatis/mybatis-plus/3-02Mybatis-plus/">mybatis-plus</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/backend/" title="分类于Java后端">Java后端</a><i class="ic i-angle-right"></i><a href="/categories/backend/java/" title="分类于Java">Java</a><i class="ic i-angle-right"></i><a href="/categories/backend/java/base/" title="分类于Java基础">Java基础</a></div><span><a href="/2023/10/22/backend/java/base/hello/hello-world/">Hello World</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/linux/" title="分类于Linux">Linux</a><i class="ic i-angle-right"></i><a href="/categories/linux/docker/" title="分类于Docker">Docker</a></div><span><a href="/2023/10/22/linux/docker/docker/Docker/">docker</a></span></li></ul></div><div class="rpost pjax"><h2>最新评论</h2><ul class="leancloud-recent-comment" id="new-comment"></ul></div></div><div class="status"><div class="copyright"><span itemprop="copyrightYear">2023</span><span class="with-love"><i class="ic i-sakura rotate"></i></span><span class="author" itemprop="copyrightHolder">biya @ Ya Hallo</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i></span><span title="站点总字数">448k 字</span><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="ic i-coffee"></i></span><span title="站点阅读时长">6:47</span></div><div class="powered-by">基于 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & Theme.<a href="https://github.com/theme-shoka-x/hexo-theme-shokaX/" rel="noopener" target="_blank">ShokaX</a></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2023/10/22/database/sql/mysql/Java面试题-06-Mysql篇/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,chart:!1,copy_tex:!1,katex:!1,mermaid:!1,audio:["https://music.163.com/song?id=1387098940"],fancybox:!0,nocopy:!1,outime:!0,template:'<div class="note warning"><p><span class="label warning">文章时效性提示</span><br>这是一篇发布于 {{publish}} 天前，最后一次更新在 {{updated}} 天前的文章，部分信息可能已经发生改变，请注意甄别。</p></div>',quiz:{choice:"单选题",multiple:"多选题",true_false:"判断题",essay:"问答题",gap_fill:"填空题",mistake:"错题备注"},ignores:[a=>a.includes("#"),a=>new RegExp(LOCAL.path+"$").test(a),[]]}</script><script src="https://polyfill.io/v3/polyfill.min.js?features=default,fetch"></script><script src="https://lf9-cdn-tos.bytecdntp.com/cdn/expire-6-M/pace/1.0.2/pace.min.js"></script><script src="https://lf9-cdn-tos.bytecdntp.com/cdn/expire-6-M/algoliasearch/4.12.1/algoliasearch-lite.umd.min.js"></script><script src="https://lf9-cdn-tos.bytecdntp.com/cdn/expire-6-M/instantsearch.js/4.39.0/instantsearch.production.min.js"></script><script src="https://lf9-cdn-tos.bytecdntp.com/cdn/expire-6-M/quicklink/2.2.0/quicklink.umd.min.js"></script><script src="https://lf9-cdn-tos.bytecdntp.com/cdn/expire-6-M/??jquery/3.5.1/jquery.min.js,fancybox/3.5.7/jquery.fancybox.min.js,justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js" async></script><script src="https://lf9-cdn-tos.bytecdntp.com/cdn/expire-6-M/KaTeX/0.15.2/contrib/copy-tex.min.js" async></script><script src="/js/app.js?v=0.3.6"></script><script data-pjax="data-pjax">var _hmt=_hmt||[];!function(){var e=document.createElement("script"),t=(e.src="https://hm.baidu.com/hm.js?true",e.async=!0,document.getElementsByTagName("script")[0]);t.parentNode.insertBefore(e,t)}()</script><script>!function(t,e,n,c,r,a){t[n]=t[n]||function(){(t[n].q=t[n].q||[]).push(arguments)},(r=e.createElement(c)).async=1,r.src="https://www.clarity.ms/tag/true",(a=e.getElementsByTagName(c)[0]).parentNode.insertBefore(r,a)}(window,document,"clarity","script")</script><script async src="https://www.googletagmanager.com/gtag/js?id=true"></script><script data-pjax="data-pjax">function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","true")</script></body></html><!-- rebuild by hexo-renderer-multi-next-markdown-it -->