<!-- build time: Thu Nov 02 2023 22:27:03 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta http-equiv="X-UA-COMPATIBLE" content="IE=edge,chrome=1"><meta name="renderer" content="webkit"><link rel="icon" type="image/ico" sizes="32x32" href="/assets/favicon.ico"><link rel="apple-touch-icon" sizes="180x180" href="/assets/apple-touch-icon.png"><meta name="msvalidate.01" content="1234"><link rel="alternate" href="/rss.xml" title="夢のない賢魚です" type="application/rss+xml"><link rel="alternate" href="/atom.xml" title="夢のない賢魚です" type="application/atom+xml"><link rel="alternate" type="application/json" title="夢のない賢魚です" href="https://sbysg.github.io/feed.json"><link rel="preconnect" href="https://lf9-cdn-tos.bytecdntp.com"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://unpkg.com"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.3.6"><script src="https://cdn.staticfile.org/vue/3.2.45/vue.global.prod.js"></script><meta name="keywords" content="springboot"><link rel="canonical" href="https://sbysg.github.io/2023/10/22/springframe/spring/springboot/springboot-01-class/"><title>springboot</title><meta name="generator" content="Hexo 6.3.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">springboot</h1><div class="meta"><span class="item" title="创建时间：2023-10-22 00:09:40"><span class="icon"><i class="ic i-calendar"></i></span><span class="text">发表于</span><time itemprop="dateCreated datePublished" datetime="2023-10-22T00:09:40+08:00">2023-10-22</time></span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i></span><span class="text">本文字数</span><span>126k</span><span class="text">字</span></span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i></span><span class="text">阅读时长</span><span>1:54</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span><span class="line"></span><span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Ya Hallo</a></li></ul><ul class="right" id="rightNav"><li class="item theme" @click="changeThemeByBtn"><i class="ic" :class="{'i-sun': !themeStatus,'i-moon': themeStatus}"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div class="pjax" id="imgs"><ul><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1giclxxcb6rj20zk0m8b29.jpg"></li><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1gipexoj0moj20zk0m8kgu.jpg"></li><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1gipexw3o58j20zk0m8e81.jpg"></li><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1giclfdu6exj20zk0m87hw.jpg"></li><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1giph4fomxoj20zk0m8axp.jpg"></li><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1giclgi503lj20zk0m8hdt.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"></path></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"></use><use xlink:href="#gentle-wave" x="48" y="3"></use><use xlink:href="#gentle-wave" x="48" y="5"></use><use xlink:href="#gentle-wave" x="48" y="7"></use></g></svg></div><main><div class="inner"><div class="pjax" id="main"><div class="article wrap"><div class="breadcrumb" itemlistelement itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i><span><a href="/">首页</a></span><i class="ic i-angle-right"></i><span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/springframe/" itemprop="item" rel="index" title="分类于Java框架"><span itemprop="name">Java框架<meta itemprop="position" content="0"></span></a></span><i class="ic i-angle-right"></i><span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/springframe/spring/" itemprop="item" rel="index" title="分类于Spring全家桶"><span itemprop="name">Spring全家桶<meta itemprop="position" content="1"></span></a></span></div><article class="post block" itemscope itemtype="http://schema.org/Article" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://sbysg.github.io/2023/10/22/springframe/spring/springboot/springboot-01-class/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/assets/avatar.jpg"><meta itemprop="name" content="biya"><meta itemprop="description" content="biya, 摸鱼之道，就在其中"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="夢のない賢魚です"></span><div class="body md" itemprop="articleBody"><h1 id="1spring-boot-概述"><a class="anchor" href="#1spring-boot-概述">#</a> 1.Spring Boot 概述</h1><h3 id="1什么是springboot"><a class="anchor" href="#1什么是springboot">#</a> 1. 什么是 springboot？</h3><ul><li>Spring Boot 是基于 Spring 框架开发的全新框架，其设计目的是<strong>简化新 Spring 应用的初始化搭建和开发过程</strong>。</li></ul><p>​ 原有 spring 应用开发非常麻烦，各种组装对象之间依赖关系很麻烦，</p><ul><li>Spring Boot 整合了许多框架和第三方库配置，几乎可以达到 “开箱即用”。</li></ul><p>​ springboot 与其他组件结合非常容易（引入依赖，配置 ，使用）</p><h3 id="2spring-boot-优点"><a class="anchor" href="#2spring-boot-优点">#</a> 2.Spring Boot 优点？</h3><ul><li>可快速构建独立的 Spring 应用</li><li>直接嵌入 Tomcat、Jetty 和 Undertow 服务器（无需部署 WAR 文件） 不需要本地安装 tomcat</li><li>提供依赖启动器简化构建配置</li><li>极大程度的自动化配置 Spring 和第三方库</li><li>提供生产就绪功能</li><li>极少的代码生成和 XML 配置 淘汰 xml</li></ul><h1 id="2使用springboot创建工程"><a class="anchor" href="#2使用springboot创建工程">#</a> 2. 使用 springboot 创建工程</h1><p>1. 创建工程</p><p><img data-src="springboot-01-class.assets/image-20230830154950045.png" alt="image-20230830154950045"></p><p><img data-src="springboot-01-class.assets/image-20230830155042358.png" alt="image-20230830155042358"></p><p><img data-src="springboot-01-class.assets/image-20230830155116109.png" alt="image-20230830155116109"></p><p>2. 导入依赖</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>引入父依赖<span class="token operator">--</span><span class="token operator">></span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token generics"><span class="token punctuation">&lt;</span>parent<span class="token punctuation">></span></span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token generics"><span class="token punctuation">&lt;</span>groupId<span class="token punctuation">></span></span>org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token operator">&lt;</span><span class="token operator">/</span>groupId<span class="token operator">></span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token generics"><span class="token punctuation">&lt;</span>artifactId<span class="token punctuation">></span></span>spring<span class="token operator">-</span>boot<span class="token operator">-</span>starter<span class="token operator">-</span>parent<span class="token operator">&lt;</span><span class="token operator">/</span>artifactId<span class="token operator">></span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token generics"><span class="token punctuation">&lt;</span>version<span class="token punctuation">></span></span><span class="token number">2.1</span><span class="token number">.3</span><span class="token punctuation">.</span><span class="token constant">RELEASE</span><span class="token operator">&lt;</span><span class="token operator">/</span>version<span class="token operator">></span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token operator">&lt;</span>relativePath<span class="token operator">/</span><span class="token operator">></span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token operator">&lt;</span><span class="token operator">/</span>parent<span class="token operator">></span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token generics"><span class="token punctuation">&lt;</span>dependencies<span class="token punctuation">></span></span></pre></td></tr><tr><td data-num="10"></td><td><pre></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> web相关依赖</pre></td></tr><tr><td data-num="12"></td><td><pre>              starter<span class="token operator">-</span>web  web启动器 <span class="token number">1.</span>完成web相关jar的依赖 <span class="token number">2.</span>完成bean（对象）之间的自动装配</pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token operator">--</span><span class="token operator">></span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token generics"><span class="token punctuation">&lt;</span>dependency<span class="token punctuation">></span></span></pre></td></tr><tr><td data-num="15"></td><td><pre>            <span class="token generics"><span class="token punctuation">&lt;</span>groupId<span class="token punctuation">></span></span>org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token operator">&lt;</span><span class="token operator">/</span>groupId<span class="token operator">></span></pre></td></tr><tr><td data-num="16"></td><td><pre>            <span class="token generics"><span class="token punctuation">&lt;</span>artifactId<span class="token punctuation">></span></span>spring<span class="token operator">-</span>boot<span class="token operator">-</span>starter<span class="token operator">-</span>web<span class="token operator">&lt;</span><span class="token operator">/</span>artifactId<span class="token operator">></span></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token operator">&lt;</span><span class="token operator">/</span>dependency<span class="token operator">></span></pre></td></tr><tr><td data-num="18"></td><td><pre></pre></td></tr><tr><td data-num="19"></td><td><pre>        <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span></pre></td></tr><tr><td data-num="20"></td><td><pre>        starter<span class="token operator">-</span>test  springboot单元测试启动器</pre></td></tr><tr><td data-num="21"></td><td><pre>        <span class="token operator">--</span><span class="token operator">></span></pre></td></tr><tr><td data-num="22"></td><td><pre>        <span class="token generics"><span class="token punctuation">&lt;</span>dependency<span class="token punctuation">></span></span></pre></td></tr><tr><td data-num="23"></td><td><pre>            <span class="token generics"><span class="token punctuation">&lt;</span>groupId<span class="token punctuation">></span></span>org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token operator">&lt;</span><span class="token operator">/</span>groupId<span class="token operator">></span></pre></td></tr><tr><td data-num="24"></td><td><pre>            <span class="token generics"><span class="token punctuation">&lt;</span>artifactId<span class="token punctuation">></span></span>spring<span class="token operator">-</span>boot<span class="token operator">-</span>starter<span class="token operator">-</span>test<span class="token operator">&lt;</span><span class="token operator">/</span>artifactId<span class="token operator">></span></pre></td></tr><tr><td data-num="25"></td><td><pre>        <span class="token operator">&lt;</span><span class="token operator">/</span>dependency<span class="token operator">></span></pre></td></tr><tr><td data-num="26"></td><td><pre></pre></td></tr><tr><td data-num="27"></td><td><pre>    <span class="token operator">&lt;</span><span class="token operator">/</span>dependencies<span class="token operator">></span></pre></td></tr></table></figure><p><img data-src="springboot-01-class.assets/image-20230830155426376.png" alt="image-20230830155426376"></p><p>3. 在根目录下创建一个启动类</p><p>根目录：com.qfedu</p><pre><code>package com.qfedu;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

/**
 * 启动类一般以Application
 * 一个应用只有一个启动类，相当于应用的入口
 */
@SpringBootApplication // 标记当前类是应用的启动类
public class MyApplication &#123;

    public static void main(String[] args) &#123;

        // 启动springboot 应用
        SpringApplication.run(MyApplication.class,args);
        
    &#125;
&#125;

</code></pre><p><img data-src="springboot-01-class.assets/image-20230830155842759.png" alt="image-20230830155842759"></p><p>4. 在 resources 目录中创建静态资源目录 static</p><p>静态资源：html css js img mp3</p><p>创建 static/ok.html</p><pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;h1&gt;hello springboot !!&lt;/h1&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre><p><img data-src="springboot-01-class.assets/image-20230830160058339.png" alt="image-20230830160058339"></p><p>5. 创建一个控制类</p><pre><code>package com.qfedu.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;

/**
 * 当前类是一个控制类，内部可以有很多处理器方法
 *
 */
@Controller //1.标记当前类是一个控制类，内部方法可以处理前端请求 2.将当前类创建对象加入到spring容器（map&lt;helloController,对象&gt;）
public class HelloController &#123;


    /**
     * test1方法就是一个处理器方法 相当于 写的servlet中的doGet() doPost()
     *              这样做的原因就是快速的开发，不需要创建很多的Servlet
     *
     *  url：   http://localhost:8080/test1            
     * @return
     */
    // @RequestMapping(value = &quot;/test1&quot;) 表示当前方法可以处理 /test1的请求，请求方式都支持（get post ）
    //  method = RequestMethod.GET 表示当前处理器方法只处理get请求
    @RequestMapping(value = &quot;/test1&quot;,method = RequestMethod.GET)
    public String test1()&#123;


        System.out.println(&quot;调用 test1 处理器方法&quot;);

        // 返回普通的字符串，就是返回静态资源路径 或者jsp 路径
        return &quot;ok.html&quot;;
    &#125;


    @RequestMapping(value = &quot;/test2&quot;,method = RequestMethod.GET)
    public String test2()&#123;


        System.out.println(&quot;调用 test2 处理器方法&quot;);

        // 返回普通的字符串，就是返回静态资源路径 或者jsp 路径
        return &quot;ok.html&quot;;
    &#125;

&#125;

</code></pre><p>5. 启动 应用</p><p><img data-src="springboot-01-class.assets/image-20230830161349689.png" alt="image-20230830161349689"></p><p><img data-src="springboot-01-class.assets/image-20230830161109082.png" alt="image-20230830161109082"></p><p><img data-src="springboot-01-class.assets/image-20230830161219267.png" alt="image-20230830161219267"></p><h1 id="3-spring"><a class="anchor" href="#3-spring">#</a> 3、Spring</h1><blockquote><p>介绍...balabala</p><p>spring 的核心功能</p><ul><li>IOC,DI</li><li>AOP</li></ul></blockquote><h2 id="31-iocdi重点"><a class="anchor" href="#31-iocdi重点">#</a> 3.1 IOC+DI [重点]</h2><h3 id="310-引言"><a class="anchor" href="#310-引言">#</a> 3.1.0 引言</h3><p>以前写的 [登录 + 查询全部功能]</p><p><img data-src="springboot-01-class.assets/image-20230830164021941.png" alt="image-20230830164021941"></p><p><img data-src="springboot-01-class.assets/image-20230830164046609.png" alt="image-20230830164046609"></p><h3 id="311-介绍"><a class="anchor" href="#311-介绍">#</a> 3.1.1 介绍</h3><blockquote><p>IOC 是 Spring 框架的核心功能之一，IOC (inversion of control) 控制反转</p><p>控制：控制创建对象的能力</p><p>反转：原来创建对象是自己 new, 反转就是将创建对象的能力交给 Spring 容器</p><p>​ 由 spring 容器创建对象</p></blockquote><p><code>创建对象</code> 的注解，以下注解标记在类上，如何告诉 spring 需要创建哪些对象，对象名就是类名首字母小写</p><ul><li><strong>@Controller 在控制层代码上使用</strong></li><li><strong>@Service 在业务层层代码上使用</strong></li><li><strong>@Repository 在数据持久层代码上使用</strong></li><li><strong>@Component 在其他代码上使用</strong></li></ul><p><strong>DI (dependency injection) 依赖注入，即 属性赋值</strong>，标记在属性中</p><p>属性赋值 (依赖注入的注解)</p><ul><li><strong>@Autowired</strong></li></ul><h4 id="实战重写登录小例子"><a class="anchor" href="#实战重写登录小例子">#</a> 实战（重写登录小例子）</h4><p>1. 导入依赖</p><pre><code>
        &lt;!-- mysql驱动 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-j&lt;/artifactId&gt;
            &lt;version&gt;8.1.0&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!-- DbUtils依赖 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;commons-dbutils&lt;/groupId&gt;
            &lt;artifactId&gt;commons-dbutils&lt;/artifactId&gt;
            &lt;version&gt;1.7&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;!-- druid 数据库连接池--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
            &lt;artifactId&gt;druid&lt;/artifactId&gt;
            &lt;version&gt;1.1.16&lt;/version&gt;
        &lt;/dependency&gt;

</code></pre><p>2. 拷贝以下文件</p><p><img data-src="springboot-01-class.assets/image-20230830165647481.png" alt="image-20230830165647481"></p><p>3. 修改 以下文件</p><p><img data-src="springboot-01-class.assets/image-20230830170524374.png" alt="image-20230830170524374"></p><p><img data-src="springboot-01-class.assets/image-20230830170606327.png" alt="image-20230830170606327"></p><p>4.AdminController 创建</p><pre><code>package com.qfedu.controller;


import com.qfedu.service.AdminService;
import com.qfedu.service.impl.AdminServiceImpl;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.autoconfigure.kafka.KafkaProperties;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.io.PrintWriter;
import java.sql.SQLException;

/**
 * AdminController 关于admin 表的业务 （增删改查 ） 登录
 */
@Controller // 标记当前类是控制类，内部的方法可以响应前端请求  ，告诉容器创建对应的对象（bean）
public class AdminController &#123;


    // 这种方式耦合性太强，太low 创建对象的权利交给spring容器
//    private AdminService adminService  = new AdminServiceImpl();

    @Autowired // 从容器中获取一个类型为AdminService的对象，赋值给adminService
    private AdminService adminService;


    /**
     * 登录接口
     *
     *   请求url   ： /login?username=xxxx&amp;passwrod=xxxx
     *
     *   HttpServletRequest req, HttpServletResponse resp 是内置参数可以获取请求 和相应相关
     * @return
     */
    @RequestMapping(value = &quot;/login&quot;)
    public void login(String username, String password, HttpServletRequest req, HttpServletResponse resp) throws IOException, SQLException &#123;

        // 解决form表单提交请求中文乱码
        req.setCharacterEncoding(&quot;utf-8&quot;);
        // 解决响应中文乱码 告诉浏览器解析的编码格式
        resp.setContentType(&quot;text/html;charset=utf-8&quot;);


        System.out.println(&quot;username = &quot; + username+&quot;--password==&quot;+password);

        // 使用response 响应前端，此时处理器方法返回值 是void
        PrintWriter printWriter = resp.getWriter();

        // 判断是否登录成功
        boolean result = adminService.login(username, password);
        if (result)&#123; //登录成功响应前端

            //所有的响应都通过 HttpServletResponse resp

            printWriter.println(&quot;&lt;html&gt;&quot;);
            printWriter.println(&quot;&lt;head&gt;&lt;title&gt;login&lt;/title&gt;&lt;/head&gt;&quot;);
            printWriter.println(&quot;&lt;body&gt;&quot;);
            printWriter.println(&quot;&lt;h1&gt; 登录成功 Success!!!&lt;/h1&gt;&quot;);
            //out.println(&quot;&lt;h1&gt;登录成功!!!&lt;/h1&gt;&quot;);
            printWriter.println(&quot;&lt;/body&gt;&quot;);
            printWriter.println(&quot;&lt;/html&gt;&quot;);

        &#125;else &#123; // 登录失败

            printWriter.println(&quot;&lt;html&gt;&quot;);
            printWriter.println(&quot;&lt;head&gt;&lt;title&gt;login&lt;/title&gt;&lt;/head&gt;&quot;);
            printWriter.println(&quot;&lt;body&gt;&quot;);
            printWriter.println(&quot;&lt;h1&gt; 登录失败 Fail!!!&lt;/h1&gt;&quot;);
            //out.println(&quot;&lt;h1&gt;登录成功!!!&lt;/h1&gt;&quot;);
            printWriter.println(&quot;&lt;/body&gt;&quot;);
            printWriter.println(&quot;&lt;/html&gt;&quot;);
        &#125;


    &#125;



&#125;

</code></pre><p>5. 测试</p><p><span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdDo4MDgwL2xvZ2luP3VzZXJuYW1lPWxpdSZhbXA7cGFzc3dvcmQ9MTIzNDU2">http://localhost:8080/login?username=liu&amp;password=123456</span></p><p><img data-src="springboot-01-class.assets/image-20230830170703645.png" alt="image-20230830170703645"></p><h3 id="313-演示2"><a class="anchor" href="#313-演示2">#</a> 3.1.3 演示 2</h3><blockquote><p>演示 @Component 注解创建对象</p></blockquote><p>1. 声明 Bean</p><pre><code>package com.qfedu.entity;

import org.springframework.stereotype.Component;

import java.io.Serializable;

@Component //1.表示告诉容器要创建一个该类型的对象（bean），加入容器
        // 2.默认创建bean的用法，除了controller,service,dao层之外的需要创建bean的注解都使用 @Component
public class Admin implements Serializable &#123;

    private String username = &quot;xiaoming&quot;;

    private String password = &quot;123456&quot;;

    private  String phone;

    private String address;


    public String getUsername() &#123;
        return username;
    &#125;

    public void setUsername(String username) &#123;
        this.username = username;
    &#125;

    public String getPassword() &#123;
        return password;
    &#125;

    public void setPassword(String password) &#123;
        this.password = password;
    &#125;

    public String getPhone() &#123;
        return phone;
    &#125;

    public void setPhone(String phone) &#123;
        this.phone = phone;
    &#125;

    public String getAddress() &#123;
        return address;
    &#125;

    public void setAddress(String address) &#123;
        this.address = address;
    &#125;

    @Override
    public String toString() &#123;
        return &quot;Admin&#123;&quot; +
                &quot;username='&quot; + username + '\'' +
                &quot;, password='&quot; + password + '\'' +
                &quot;, phone='&quot; + phone + '\'' +
                &quot;, address='&quot; + address + '\'' +
                '&#125;';
    &#125;
&#125;

</code></pre><p>2.AdminController 引入 Admin 属性</p><pre><code>

    @Autowired // 从容器中获取一个该类型的bean 注入到当前 属性中
               // 所有使用@Autowired 注解属性使用的前提是：当前类必须创建bean加入到容器 ，只有这样才能从容器中找bean
    private Admin admin;

    /**
     * 获取admin bean
     * @return
     */
    @RequestMapping(&quot;/getAdmin&quot;)
    public String   getAdmin()&#123;

        System.out.println(&quot;admin = &quot; + admin);

        return &quot;ok.html&quot;;
    &#125;
</code></pre><p><img data-src="springboot-01-class.assets/image-20230831100402408.png" alt="image-20230831100402408"></p><h2 id="32-aop"><a class="anchor" href="#32-aop">#</a> 3.2 AOP</h2><h3 id="321-介绍"><a class="anchor" href="#321-介绍">#</a> 3.2.1 介绍</h3><blockquote><p>Spring 中另外一个<strong>核心功能，AOP</strong></p><hr><p>AOP (Aspect Oriented Programming), 即<strong>面向切面编程</strong>.</p><blockquote><p>OOP (Object Oriented Programming), 即面向对象编程.</p></blockquote></blockquote><p>切面 就是一个个的横切面</p><p><img data-src="springboot-01-class.assets/image-20230831104009176.png" alt="image-20230831104009176"></p><p><img data-src="springboot-01-class.assets/image-20230831104433440.png" alt="image-20230831104433440"></p><p><img data-src="springboot-01-class.assets/image-20230831105338049.png" alt="image-20230831105338049"></p><p><img data-src="https://picgo-image-wgz.oss-cn-hangzhou.aliyuncs.com/picgo_image-master/image-20200525101645635.png" alt="image-20200525101645635"></p><p><img data-src="springboot-01-class.assets/image-20230831105958383.png" alt="image-20230831105958383"></p><p>总结：切面就是抽离公共的代码，可以对目标方法进行拦截 过滤 鉴权 记录日志</p><p>使用场景</p><ul><li>事务管理<ul><li>后续 spring 管理事务用的 AOP 原理</li></ul></li><li>权限校验<ul><li>后期使用 Spring Security 注解开发时，其实利用了 AOP 思想</li></ul></li><li>日志记录</li><li>性能检测（记录请求时间）</li></ul><h3 id="322-aop术语"><a class="anchor" href="#322-aop术语">#</a> 3.2.2 AOP 术语</h3><blockquote><p>连接点 (Joinpoint)：连接点是程序类中客观存在的方法，可被 Spring 拦截并切入内容。即每个方法在切入之前，都是连接点</p><p><code>切入点</code> (Pointcut)：被 Spring 切入连接点。即真正会增强的目标方法</p><p>通知、 <code>增强</code> (Advice)：可以为切入点添加额外功能，分为：前置通知、后置通知、异常通知、环绕通知等。</p><p><code>目标对象</code> (Target)：被代理的目标对象</p><p>织入 (Weaving)：把通知应用到具体的类，进而创建新的代理类的过程。</p><p><code>代理</code> (Proxy)：被 AOP 织入通知后，产生的结代理类。</p><p><code>切面</code> (Aspect)：由切点和通知组成</p></blockquote><p><img data-src="https://picgo-image-wgz.oss-cn-hangzhou.aliyuncs.com/picgo_image-master/image-20200525102238000.png" alt="image-20200525102238000"></p><h3><a class="anchor" href="#">#</a></h3><p><img data-src="springboot-01-class.assets/image-20230831110820122.png" alt="image-20230831110820122"></p><p>概念重新梳理</p><p>连接点 (Joinpoint)：连接点是程序类中客观存在的方法，可被 Spring 拦截并切入内容。即每个方法在切入之前，都是连接点</p><p>​ 连接点 ==== 普通的方法</p><p><code>切入点</code> (Pointcut)：被 Spring 切入连接点。即真正会增强的目标方法</p><p>​ ` 切入点 === 被切面切向的普通方法，需要拦截 增强的目标方法</p><p>通知、 <code>增强</code> (Advice)：可以为切入点添加额外功能，分为：前置通知、后置通知、异常通知、环绕通知等。</p><p>​ 通知 ==== 切面中的方法（抽离公共代码）</p><p><code>目标对象</code> (Target)：被代理的目标对象</p><p>​ 需要拦截的哪些方法对应的对象</p><p>织入 (Weaving)：把通知应用到具体的类，进而创建新的代理类的过程。</p><p>​ 将切面切向目标方法的过程就是织入，动作</p><p><code>代理</code> (Proxy)：被 AOP 织入通知后，产生的结代理类。</p><p>​ aop 实现的本质是使用代理模式（静态代理，动态代理）实现</p><p><code>切面</code> (Aspect)：由切点表达式和通知（抽离的公共方法）组成</p><p>​ 切面 == 一个类</p><p><img data-src="springboot-01-class.assets/image-20230831143600319.png" alt="image-20230831143600319"></p><h4 id="实例"><a class="anchor" href="#实例">#</a> 实例</h4><p>目标：就是创建一个切面，可以拦截过滤我们的 Service 实现类中的方法</p><p>1. 引入 aop 相关依赖</p><pre><code>       &lt;!-- 导入aop相关 依赖--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;
        &lt;/dependency&gt;
</code></pre><p>2. 创建一个切面</p><pre><code>package com.qfedu.aspect;

import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Pointcut;
import org.springframework.stereotype.Component;

/**
 * 当前类 就是一个切面，切面中就是抽离的公共方法（通知 ）
 */
@Component //将当前类创建bean 加入到spring容器
@Aspect // 声明当前类是一个切面类
public class MyAspect &#123;


    /**
     * 声明此方法为切点表达式
     *   value = &quot;execution( )&quot; 配置切点表达式
     *                             切点：就是要拦截的目标方法  com.qfedu.service.impl.AdminServiceImpl.login(java.lang.String, java.lang.String)
     *                             切点表达式 ：就是可以描述一系列的切点
     *
     *  切点表达式公式
     *  public boolean     com.qfedu.service.impl.AdminServiceImpl.login(java.lang.String, java.lang.String)
     *
     *  // 1.去掉 权限修饰符 public
     *  // 2.返回值类型使用 * 替代
     *  // 3.方法名 类名 包名 可以使用*替代
     *     4.参数列表使用 .. 替代
     *   *   com.qfedu.service.*.*.*(..) 切点表达式，表示service包下所有 类中的方法
     *
     */
    @Pointcut(value = &quot;execution( *   com.qfedu.service.*.*.*(..)  )&quot;)
    public void pointCut()&#123;

    &#125;

    /**
     * 环绕通知  封装抽离公共的方法 在目标方法执行前后执行
     *
     * ProceedingJoinPoint proceedingJoinPoint  封装了目标对象 及其要执行的方法 参数
     * @param proceedingJoinPoint
     * @return
     */
    @Around(value = &quot;pointCut()&quot;) // 标记当前方法为环绕通知 拦截切点表达式中对应的方法
    public Object myAround(ProceedingJoinPoint proceedingJoinPoint) throws Throwable &#123;

        // proceedingJoinPoint.getSignature().getName() 获取即将调用目标方法的名字
        System.out.println(&quot;环绕通知-调用目标方法前---目标方法：&quot;+proceedingJoinPoint.getSignature().getName() );

        // 让目标方法（service包下所有 类中的方法）执行 ，result就是对应方法返回值结果
        Object result = proceedingJoinPoint.proceed();

//        Object result = false; 如果不调用proceedingJoinPoint.proceed(); 就是拦截不调用目标对象方法

        System.out.println(&quot;目标方法执行 返回的结果 --result = &quot; + result);


        System.out.println(&quot;环绕通知-调用目标方法后---目标方法：&quot;+proceedingJoinPoint.getSignature().getName());

         return  result;
    &#125;


&#125;

</code></pre><p>3. 访问 login 测试</p><p><span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdDo4MDgwL2xvZ2luP3VzZXJuYW1lPWxpdSZhbXA7cGFzc3dvcmQ9MTIzNDU2">http://localhost:8080/login?username=liu&amp;password=123456</span></p><p><img data-src="springboot-01-class.assets/image-20230831114324272.png" alt="image-20230831114324272"></p><p><img data-src="springboot-01-class.assets/image-20230831113812195.png" alt="image-20230831113812195"></p><h3 id="324-aop开发步骤"><a class="anchor" href="#324-aop开发步骤">#</a> 3.2.4 Aop 开发步骤</h3><p>前提引入 aop 依赖</p><pre><code>   &lt;!-- 导入aop相关 依赖--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;
        &lt;/dependency&gt;
</code></pre><blockquote><p>演示各种 aop 增强方式，步骤</p><ul><li><p>创建切面类，类上加注解</p><ul><li>@Component , 加上该注解，springboot 框架就会创建该类对象</li><li>@Aspect , 加上该注解，springboot 框架内部就会知道该类是一个切面类</li></ul></li><li><p>设置切入点方法，并加注解</p><ul><li>@Pointcut , 用于定义要增强的目标方法路径</li></ul></li><li><p>设置各种增强 (或者叫通知) 方法</p><ul><li><table><thead><tr><th>注解</th><th>解释</th></tr></thead><tbody><tr><td>@Around</td><td>环绕通知</td></tr><tr><td>@Before</td><td>前置通知</td></tr><tr><td>@After</td><td>最终通知</td></tr><tr><td>@AfterReturning</td><td>后置返回通知</td></tr><tr><td>@AfterThrowing</td><td>异常通知</td></tr></tbody></table></li></ul></li></ul></blockquote><pre><code>package com.qfedu.aspect;

import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.*;
import org.springframework.stereotype.Component;

/**
 * 当前类 就是一个切面，切面中就是抽离的公共方法（通知 ）
 */
@Component //将当前类创建bean 加入到spring容器
@Aspect // 声明当前类是一个切面类
public class MyAspect &#123;


    /**
     * 声明此方法为切点表达式
     *   value = &quot;execution( )&quot; 配置切点表达式
     *                             切点：就是要拦截的目标方法  com.qfedu.service.impl.AdminServiceImpl.login(java.lang.String, java.lang.String)
     *                             切点表达式 ：就是可以描述一系列的切点
     *
     *  切点表达式公式
     *  public boolean     com.qfedu.service.impl.AdminServiceImpl.login(java.lang.String, java.lang.String)
     *
     *  // 1.去掉 权限修饰符 public
     *  // 2.返回值类型使用 * 替代
     *  // 3.方法名 类名 包名 可以使用*替代
     *     4.参数列表使用 .. 替代
     *   *   com.qfedu.service.*.*.*(..) 切点表达式，表示service包下所有 类中的方法
     *
     */
    @Pointcut(value = &quot;execution( *   com.qfedu.service.*.*.*(..)  )&quot;)
    public void pointCut()&#123;

    &#125;


    /**
     *     @Before(value = &quot;pointCut()&quot;)  前置通知 在目标方法调用前执行
     * JoinPoint 标对象 及其要执行的方法 参数  只是不能调用目标方法执行
     * @param joinPoint
     */
    @Before(value = &quot;pointCut()&quot;)
    public void myBefore(JoinPoint joinPoint)&#123;

        System.out.println(&quot;前置通知执行---方法：&quot;+joinPoint.getSignature().getName());

    &#125;


    /**
     * 环绕通知  封装抽离公共的方法 在目标方法执行前后执行
     *
     * ProceedingJoinPoint proceedingJoinPoint  封装了目标对象 及其要执行的方法 参数
     * @param proceedingJoinPoint
     * @return
     */
    @Around(value = &quot;pointCut()&quot;) // 标记当前方法为环绕通知 拦截切点表达式中对应的方法
    public Object myAround(ProceedingJoinPoint proceedingJoinPoint) throws Throwable &#123;

        // proceedingJoinPoint.getSignature().getName() 获取即将调用目标方法的名字
        System.out.println(&quot;环绕通知-调用目标方法前---目标方法：&quot;+proceedingJoinPoint.getSignature().getName() );

        // 让目标方法（service包下所有 类中的方法）执行 ，result就是对应方法返回值结果
        Object result = proceedingJoinPoint.proceed();

//        Object result = false; 如果不调用proceedingJoinPoint.proceed(); 就是拦截不调用目标对象方法

        System.out.println(&quot;目标方法执行 返回的结果 --result = &quot; + result);


        System.out.println(&quot;环绕通知-调用目标方法后---目标方法：&quot;+proceedingJoinPoint.getSignature().getName());

         return  result;
    &#125;


    /**
     *  @AfterReturning 后置返回通知  可以得到 目标对象执行的结果
     *      value = &quot;pointCut()&quot; 切点表达式
     *      returning = &quot;result&quot; 需要将目标对象方法执行返回的结果交个那个形参
     * @param joinPoint
     * @param result
     * @return
     */
    @AfterReturning(value = &quot;pointCut()&quot;,returning = &quot;result&quot;)
    public Object myAfterReturn(JoinPoint joinPoint,Object result)&#123;

        System.out.println(&quot;后置返回通知执行---方法：&quot;+joinPoint.getSignature().getName() + &quot;--result:&quot;+result);


        return result;
    &#125;


    /**
     *   @After(value = &quot;pointCut()&quot;) 后置最终通知
     *
     *          @After 无论目标方法是否正确的执行，都会回调该通知
     *          @AfterReturning  如果目标方法正确的执行，并返回结果  调用后置返回通知
     *                            如果目标方法执行发生异常，无法返回结果，此时 不会调用后置返回通知
     * @param joinPoint
     */
    @After(value = &quot;pointCut()&quot;)
    public void myAfter(JoinPoint joinPoint)&#123;

        System.out.println(&quot;后置最终通知执行---方法：&quot;+joinPoint.getSignature().getName());
    &#125;

    /**
     * @AfterThrowing 后置异常通知  只有目标方法调用有异常时才会 回调
     *       throwing = &quot;e&quot; 可以将目标方法执行抛出的异常，传递给形参 Throwable e
     *
     * @param joinPoint
     * @param e
     */
    @AfterThrowing(value = &quot;pointCut()&quot;,throwing = &quot;e&quot;)
    public void myAfterThrowing(JoinPoint joinPoint,Throwable e)&#123;

        System.out.println(&quot;后置异常通知执行---方法：&quot;+joinPoint.getSignature().getName()+&quot;异常信息：&quot;+e.getMessage());

    &#125;



&#125;

</code></pre><p><img data-src="springboot-01-class.assets/image-20230831145624249.png" alt="image-20230831145624249"></p><p><img data-src="springboot-01-class.assets/image-20230831145801922.png" alt="image-20230831145801922"></p><p><img data-src="springboot-01-class.assets/image-20230831150315302.png" alt="image-20230831150315302"></p><h2 id="51-mvc"><a class="anchor" href="#51-mvc">#</a> 5.1 MVC</h2><p>MVC 架构：根据不同的事情由不同的类去处理，内部单一职责</p><blockquote><ul><li>Model: 模型类，例如封装数据的实体类，业务模型 (Service), 数据层 (Dao)</li><li>View: 视图，展示数据的.HTML,JSP</li><li>Controller: 控制器，控制整个流程走向。决定是否能接收请求，调用哪个业务，跳转哪个页面，Servlet</li></ul></blockquote><p>MVC 架构，就是将我们项目 进行分模块开发，每隔模块都只有一小部分功能，遵循单一职责</p><p><img data-src="springboot-01-class.assets/image-20230831155310988.png" alt="image-20230831155310988"></p><h2 id="52-请求响应重点"><a class="anchor" href="#52-请求响应重点">#</a> 5.2 请求 &amp; 响应【重点】</h2><p>@RequestMapping(value = &quot;/testA&quot;,method = RequestMethod.GET)</p><p>@GetMapping(value = &quot;/testB&quot;)</p><p>@PostMapping(value = &quot;/testC&quot;)</p><pre><code>package com.qfedu.controller;


import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

@Controller // 表名当前类是控制了 可以接收请求
public class TestController &#123;


    /**
     *  @RequestMapping 默认请情况下可以 get post delete put
     *          method = RequestMethod.GET 表示当前请求方式只支持get
     * @return
     */
    @RequestMapping(value = &quot;/testA&quot;,method = RequestMethod.GET)
    public String testA()&#123;
        System.out.println(&quot;TestController-testA&quot;);
        return &quot;ok.html&quot;;

    &#125;

    /**
     *  @GetMapping 只支持Get请求方式
     *  @GetMapping(value = &quot;/testB&quot;) ==  @RequestMapping(value = &quot;/testB&quot;,method = RequestMethod.GET)
     * @return
     */
    @GetMapping(value = &quot;/testB&quot;)
    public String testB()&#123;
        System.out.println(&quot;TestController-testB&quot;);
        return &quot;ok.html&quot;;

    &#125;

    /**
     * @PostMapping(value = &quot;/testC&quot;) 表示当前处理器方法只支持post 请求
     * @return
     */
    @PostMapping(value = &quot;/testC&quot;)
    public String testC()&#123;
        System.out.println(&quot;TestController-testC&quot;);
        return &quot;ok.html&quot;;

    &#125;

    /**
     * 直接通过response 对象响应前端 处理器方法返回void类型
     *
     * @param request
     * @param response
     * @throws IOException
     */
    @GetMapping(value = &quot;/testD&quot;)
    public void testD(HttpServletRequest request, HttpServletResponse response) throws IOException &#123;
        System.out.println(&quot;TestController-testD&quot;);

        request.setCharacterEncoding(&quot;utf-8&quot;);
        response.setContentType(&quot;text/html;charset=utf-8&quot;);

        response.getWriter().println(&quot;通过response对象响应前端&quot;);

    &#125;


&#125;

</code></pre><p><img data-src="springboot-01-class.assets/image-20230831160326440.png" alt="image-20230831160326440"></p><h2 id="53-参数绑定-重点"><a class="anchor" href="#53-参数绑定-重点">#</a> 5.3 参数绑定 【重点】</h2><blockquote><p>所谓参数绑定，就是前端发请求中的数据，可以直接在 Controller 的方法参数中接收。即前端请求数据和后端方法参数绑定.</p></blockquote><h3 id="531-简单类型参数绑定重点"><a class="anchor" href="#531-简单类型参数绑定重点">#</a> 5.3.1 简单类型参数绑定 [重点]</h3><blockquote><p>简单类型指，常用的几种类型：基本类型 + String+Date</p></blockquote><p>前端界面</p><pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;h1&gt;addUser1 提交基本类型&lt;/h1&gt;

&lt;a href=&quot;/addUser1?id=100&amp;username=xiaoming&amp;score=99.5&amp;birthday=2023-08-31&quot;&gt;增加用户 &lt;/a&gt;
&lt;br&gt;
&lt;!-- 使用表单发起post 请求--&gt;
&lt;form action=&quot;/addUser1&quot; method=&quot;post&quot; enctype=&quot;application/x-www-form-urlencoded&quot;&gt;
    id:&lt;input type=&quot;number&quot; name=&quot;id&quot;&gt;&lt;br&gt;
    username:&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br&gt;
    score:&lt;input type=&quot;number&quot; name=&quot;score&quot;&gt;&lt;br&gt;
    birthday:&lt;input type=&quot;date&quot; name=&quot;birthday&quot;&gt;&lt;br&gt;

    &lt;input type=&quot;submit&quot; value=&quot;添加&quot;&gt;
&lt;/form&gt;


&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>后端接收</p><pre><code>package com.qfedu.controller;

import org.springframework.format.annotation.DateTimeFormat;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;

import java.util.Date;

/**
 * user 相关增删改查
 */
@Controller
public class UserController &#123;

    /**
     * 添加用户
     *  接收基本类型  可以直接接收也可以使用其包装类型接收
     *  接收字符串  直接使用String
     *  接收时间字符串  需要  @DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;) Date birthday
     *                 将接收的时间字符串 转化为 java.utils.Date
     *
     *  url /addUser1?id=100&amp;username=xiaoming&amp;score=99.5&amp;birthday=2023-08-31
     * @return
     */
    @RequestMapping(&quot;/addUser1&quot;)
    public String addUser1(int id, String username, float score,
                           @DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;) Date birthday)&#123;

        System.out.println(&quot;id = &quot; + id);
        System.out.println(&quot;username = &quot; + username);
        System.out.println(&quot;score = &quot; + score);
        System.out.println(&quot;birthday = &quot; + birthday);

        // 此时如果直接 return路径为jsp html ，再form表单使用post提交时报错误 405 不支持post请求
//        return &quot;ok.html&quot;;

        // 此时可以使用重定向解决  redirect:/
        return &quot;redirect:/ok.html&quot;;
    &#125;

&#125;

</code></pre><h3 id="532-对象重点"><a class="anchor" href="#532-对象重点">#</a> 5.3.2 对象 [重点]</h3><blockquote><p>场景：注册 / 添加 / 更新</p></blockquote><p>如果处理方法接受的参数非常多，此时可以使用 对象 或者 Map 封装起来</p><p>前端界面</p><pre><code>&lt;h1&gt;addUser2 提交基本类型，使用对象接收&lt;/h1&gt;
&lt;a href=&quot;/addUser2?id=100&amp;username=xiaoming&amp;score=99.5&amp;birthday=2023-08-31&quot;&gt;增加用户 &lt;/a&gt;
&lt;br&gt;
&lt;!-- 使用表单发起post 请求--&gt;
&lt;form action=&quot;/addUser2&quot; method=&quot;post&quot; enctype=&quot;application/x-www-form-urlencoded&quot;&gt;
    id:&lt;input type=&quot;number&quot; name=&quot;id&quot;&gt;&lt;br&gt;
    username:&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br&gt;
    score:&lt;input type=&quot;number&quot; name=&quot;score&quot;&gt;&lt;br&gt;
    birthday:&lt;input type=&quot;date&quot; name=&quot;birthday&quot;&gt;&lt;br&gt;

    &lt;input type=&quot;submit&quot; value=&quot;添加&quot;&gt;
&lt;/form&gt;
</code></pre><p>处理器方法接收</p><pre><code>
    /**
     * 接收对象
     * url /addUser2?id=100&amp;username=xiaoming&amp;score=99.5&amp;birthday=2023-08-31
     * 当前处理器方法 接收键值对 =====》java对象user
     * @param user
     * @return
     */
    @RequestMapping(&quot;/addUser2&quot;)
    public String addUser2(User user)&#123;

        System.out.println(&quot;user = &quot; + user);

        return &quot;redirect:/ok.html&quot;;
    &#125;
</code></pre><h3 id="535-map集合"><a class="anchor" href="#535-map集合">#</a> 5.3.5 Map 集合</h3><blockquote><p>Map 是键值对，键和值一一映射.</p><p>跟 Java 对象很类似，属性和属性值一一对应.</p><p>所以什么时候需要 / 可以使用 Map 类型来接收参数呢？</p><ul><li>凡是可以用对象接收的都可以使用 Map</li></ul><hr></blockquote><p>前端</p><pre><code>&lt;h1&gt;addUser3 提交基本类型，使用Map接收&lt;/h1&gt;
&lt;a href=&quot;/addUser3?id=100&amp;username=xiaoming&amp;score=99.5&amp;birthday=2023-08-31&quot;&gt;增加用户 &lt;/a&gt;
&lt;br&gt;
&lt;!-- 使用表单发起post 请求--&gt;
&lt;form action=&quot;/addUser3&quot; method=&quot;post&quot; enctype=&quot;application/x-www-form-urlencoded&quot;&gt;
    id:&lt;input type=&quot;number&quot; name=&quot;id&quot;&gt;&lt;br&gt;
    username:&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br&gt;
    score:&lt;input type=&quot;number&quot; name=&quot;score&quot;&gt;&lt;br&gt;
    birthday:&lt;input type=&quot;date&quot; name=&quot;birthday&quot;&gt;&lt;br&gt;

    &lt;input type=&quot;submit&quot; value=&quot;添加&quot;&gt;
&lt;/form&gt;

</code></pre><p>后端接收</p><pre><code>
    /**
     * 使用map 接收键值对
     *   如果参数非常多，但是只使用一次，没有必要创建一个对应的实体类 此时使用map
     *
     * url /addUser3?id=100&amp;username=xiaoming&amp;score=99.5&amp;birthday=2023-08-31
     *
     * Map&lt;String,Object&gt; map 如果直接接收键值对 则获取的null
     * @RequestParam Map&lt;String,Object&gt; map 此时可以将接收键值对 转化为map
     *
     * @param map
     * @return
     */
    @RequestMapping(&quot;/addUser3&quot;)
    public String addUser3(@RequestParam Map&lt;String,Object&gt; map)&#123;

        System.out.println(&quot;map = &quot; + map);

        return &quot;redirect:/ok.html&quot;;
    &#125;


    /**
     * 此时请求url  /updateUser?userid=100&amp;username=xiaoming&amp;score=99.5&amp;birthday=2023-08-31
     *   前端提交键值对对的key userid=100   而后端接收基本类型int id 此时无法映射成功
     *   此时可以 使用@RequestParam 取别名
     *    @RequestParam(name = &quot;userid&quot;) int id 需要从请求的键值对中获取userid对应的值 赋值给id
     * @param id
     * @param username
     * @param score
     * @param birthday
     * @return
     */
    @RequestMapping(&quot;/updateUser&quot;)
    public String updateUser(@RequestParam(name = &quot;userid&quot;) int id, String username, float score,
                             @DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;) Date birthday)&#123;

        System.out.println(&quot;id = &quot; + id);
        System.out.println(&quot;username = &quot; + username);
        System.out.println(&quot;score = &quot; + score);
        System.out.println(&quot;birthday = &quot; + birthday);
        return &quot;redirect:/ok.html&quot;;
    &#125;

</code></pre><h3 id="536-路径参数pathvariable"><a class="anchor" href="#536-路径参数pathvariable">#</a> 5.3.6 路径参数 @PathVariable</h3><p>从路径中获取参数 /user/100 100 就是一个参数</p><pre><code>
    /**
     *
     * url  /user/100
     *      /user/&#123;id&#125;   &#123;id&#125;占位符，后续使用 @PathVariable获取对应得知
     * @PathVariable(value = &quot;id&quot;) int id   需要从url中获取&#123;id&#125;对应位置的值，传递给int id
     * @param id
     * @return
     */
    @GetMapping(&quot;/user/&#123;id&#125;&quot;)
    public String findUserById(@PathVariable(value = &quot;id&quot;) int id)&#123;
        System.out.println(&quot;id = &quot; + id);

        return &quot;redirect:/ok.html&quot;;
    &#125;

</code></pre><p><img data-src="springboot-01-class.assets/image-20230831175236070.png" alt="image-20230831175236070"></p><p><img data-src="springboot-01-class.assets/image-20230831175616859.png" alt="image-20230831175616859"></p><h2 id="54-页面跳转熟悉"><a class="anchor" href="#54-页面跳转熟悉">#</a> 5.4 页面跳转 [熟悉]</h2><blockquote><p>回顾之前学过的 servlet 中跳转页面的功能</p><ul><li>请求转发:forward<ul><li>req.getDispatcherServlet().forward(req,resp)</li><li>请求路径不变</li><li>是服务器内部请求</li><li>一次请求</li><li>请求域的数据（请求参数，request 的属性）可以共享</li></ul></li><li>重定向:redirect<ul><li>resp.sendRedirect();</li><li>请求路径改变</li><li>是浏览器行为</li><li>两次请求</li><li>请求域的不能共享 请求参数，request 的属性丢失</li></ul></li></ul></blockquote><p><strong>请求转发</strong></p><pre><code>以  forward:/路径     
</code></pre><pre><code> /**
     * 直接通过response 对象响应前端 处理器方法返回void类型
     *
     * @param request
     * @param response
     * @throws IOException
     */
    @GetMapping(value = &quot;/testD&quot;)
    public void testD(HttpServletRequest request, HttpServletResponse response) throws IOException &#123;
        System.out.println(&quot;TestController-testD&quot;);

        request.setCharacterEncoding(&quot;utf-8&quot;);
        response.setContentType(&quot;text/html;charset=utf-8&quot;);

        String code = (String) request.getAttribute(&quot;code&quot;);

        response.getWriter().println(&quot;通过response对象响应前端---code:&quot;+code);

    &#125;


    /**
     * 转发 处理方法返回 String 类型 以forward:开头
     *
     *      一般用于：服务器内同类请求（处理器方法 转发到处理器方法）
     *
     * @return
     */
    @RequestMapping(&quot;/forwardTest&quot;)
    public String forwardTest(HttpServletRequest request)&#123;

        System.out.println(&quot;转发测试---forwardTest&quot;   );

        // 在request 设置属性，转发到的处理器方法也可以接收到属性
        request.setAttribute(&quot;code&quot;,&quot;8888&quot;);

        // 此时转发到 /testD处理器方法
        return &quot;forward:/testD&quot;;
    &#125;
</code></pre><p>重定向</p><pre><code>以   redirec:/ 开头
</code></pre><pre><code>

    /**
     * 重定向  返回String 以 redirect:/ 开头      用于控制界面跳转
     *
     *      重定向一般用于服务器内 跳转html 其他前端界面时使用  退出登录
     *                 用于跳转到外部的服务器 连接  http:/www.baidu.com
     * @return
     */
    @RequestMapping(&quot;/redirectTest&quot;)
    public String redirectTest(HttpServletRequest request)&#123;


//        return &quot;redirect:/ok.html&quot;;

        // 重定向到内部的处理器方法，此丢失request的属性 参数
        // 在request 设置属性，转发到的处理器方法也可以接收到属性
        request.setAttribute(&quot;code&quot;,&quot;8888&quot;);
        return &quot;redirect:/testD&quot;;
    &#125;

</code></pre><p><img data-src="springboot-01-class.assets/image-20230901095721255.png" alt="image-20230901095721255"></p><h2 id="55-会话重点"><a class="anchor" href="#55-会话重点">#</a> 5.5 会话 [重点]</h2><p>会话：就是 session, 同一个浏览器多个窗口请求同一个服务，多个窗口共享同一个回话 session</p><blockquote><p>如果需要在控制层中使用 session 存储会话数据，比如登录的用户信息，就可以直接在方法的参数列表中定义 HttpSession 对象即可</p></blockquote><p><strong>spring 中的处理器方法 内置参数可以有</strong> HttpServletRequest HttpServletResponse HttpSession, 只要我们在处理器方法声明 ，直接都可以使用</p><pre><code>
    /**
     * 处理器方法内置参数 可以是  HttpServletRequest request, HttpServletResponse response, HttpSession session
     *  在session存数据
     *  @param request
     * @param response
     * @param session
     */
    @RequestMapping(&quot;/testSession1&quot;)
    public void testSession1(HttpServletRequest request, HttpServletResponse response,
                             HttpSession session) throws IOException &#123;


        // 向session 中添加属性
        session.setAttribute(&quot;loginFlag&quot;,true);


        request.setCharacterEncoding(&quot;utf-8&quot;);
        response.setContentType(&quot;text/html;charset=utf-8&quot;);
        response.getWriter().println(&quot;向session中写入数据 loginFlag&quot;);

    &#125;

    /**
     * 从session中读取数据
     * @param response
     * @param session
     * @throws IOException
     */
    @RequestMapping(&quot;/testSession2&quot;)
    public void  testSession2( HttpServletResponse response,
                               HttpSession session) throws IOException &#123;

        boolean loginFlag = (boolean) session.getAttribute(&quot;loginFlag&quot;);


        response.setContentType(&quot;text/html;charset=utf-8&quot;);
        response.getWriter().println(&quot;从session中读取数据 loginFlag：&quot;+loginFlag);

    &#125;
</code></pre><p><img data-src="springboot-01-class.assets/image-20230901100610713.png" alt="image-20230901100610713"></p><p><img data-src="springboot-01-class.assets/image-20230901100647263.png" alt="image-20230901100647263"></p><h2 id="57-json处理重点"><a class="anchor" href="#57-json处理重点">#</a> 5.7 json 处理【重点】</h2><h3 id="处理器方法返回值"><a class="anchor" href="#处理器方法返回值">#</a> 处理器方法返回值</h3><p>void 使用 response 相应数据</p><p>String 返回 html,jsp 地址 转发重定向</p><p>返回 java 对象 ，对象最终转化为 json 字符串</p><ul><li>void 使用 response 相应数据</li></ul><pre><code>    @RequestMapping(&quot;/testSession1&quot;)
    public void testSession1(HttpServletRequest request, HttpServletResponse response,
                             HttpSession session) throws IOException &#123;


        // 向session 中添加属性
        session.setAttribute(&quot;loginFlag&quot;,true);


        request.setCharacterEncoding(&quot;utf-8&quot;);
        response.setContentType(&quot;text/html;charset=utf-8&quot;);
        response.getWriter().println(&quot;向session中写入数据 loginFlag&quot;);

    &#125;
</code></pre><ul><li>String 返回 html,jsp 地址 转发重定向</li></ul><pre><code>    /**
     * @PostMapping(value = &quot;/testC&quot;) 表示当前处理器方法只支持post 请求
     * @return
     */
    @PostMapping(value = &quot;/testC&quot;)
    public String testC()&#123;
        System.out.println(&quot;TestController-testC&quot;);
        return &quot;ok.html&quot;;

    &#125;
    
    /**
     * 转发 处理方法返回 String 类型 以forward:开头
     *
     *      一般用于：服务器内同类请求（处理器方法 转发到处理器方法）
     *
     * @return
     */
    @RequestMapping(&quot;/forwardTest&quot;)
    public String forwardTest(HttpServletRequest request)&#123;

        System.out.println(&quot;转发测试---forwardTest&quot;   );

        // 在request 设置属性，转发到的处理器方法也可以接收到属性
        request.setAttribute(&quot;code&quot;,&quot;8888&quot;);

        // 此时转发到 /testD处理器方法
        return &quot;forward:/testD&quot;;
    &#125;


    /**
     * 重定向  返回String 以 redirect:/ 开头      用于控制界面跳转
     *
     *      重定向一般用于服务器内 跳转html 其他前端界面时使用  退出登录
     *                 用于跳转到外部的服务器 连接  http:/www.baidu.com
     * @return
     */
    @RequestMapping(&quot;/redirectTest&quot;)
    public String redirectTest(HttpServletRequest request)&#123;


//        return &quot;redirect:/ok.html&quot;;

        // 重定向到内部的处理器方法，此丢失request的属性 参数
        // 在request 设置属性，转发到的处理器方法也可以接收到属性
        request.setAttribute(&quot;code&quot;,&quot;8888&quot;);
        return &quot;redirect:/testD&quot;;
    &#125;
    
</code></pre><ul><li>返回 java 对象 ，对象最终转化为 json 字符串</li></ul><h3 id="处理器方法接收参数"><a class="anchor" href="#处理器方法接收参数">#</a> 处理器方法接收参数</h3><ul><li><p>内置参数： HttpServletRequest HttpServletResponse HttpSession</p></li><li><p>前端提交键值对，使用一下方式接收</p></li></ul><pre><code>基本类型+String+Date

接收对象

接收map
</code></pre><ul><li>前端提交 json 字符串，后端使用 java 对象接收</li></ul><h3 id="json"><a class="anchor" href="#json">#</a> json</h3><p>json 就是一种特殊的，具有特定语法的字符串，简单，易读，通常作为，前后端交互的中间数据</p><p><img data-src="springboot-01-class.assets/image-20230901110309234.png" alt="image-20230901110309234"></p><h5 id="json对象"><a class="anchor" href="#json对象">#</a> json 对象</h5><p>json 对象都是键值对，</p><pre><code>有&#123;&#125; 包裹，

内部是键值对  ，键值对之间使用,分割

key使用引号标记，value 字符串值使用引号，数值和布尔直接写

类似于js 
</code></pre><pre><code>&#123;
	&quot;id&quot;: 100,
	&quot;username&quot;: &quot;xiaoming&quot;,
	&quot;score&quot;: 99,
	&quot;birthday&quot;: &quot;2023-09-01&quot;
&#125;

&#123;&quot;id&quot;:100,&quot;username&quot;:&quot;xiaoming&quot;,&quot;score&quot;:99,&quot;birthday&quot;:&quot;2023-09-01&quot;&#125;
</code></pre><p><img data-src="springboot-01-class.assets/image-20230901110816736.png" alt="image-20230901110816736"></p><p>json 数组内部就是多个 json 对象</p><pre><code>使用中括号包裹
</code></pre><pre><code>[&#123;
	&quot;id&quot;: 100,
	&quot;username&quot;: &quot;xiaoming&quot;,
	&quot;score&quot;: 99,
	&quot;birthday&quot;: &quot;2023-09-01&quot;
&#125;, &#123;
	&quot;id&quot;: 101,
	&quot;username&quot;: &quot;xiaohong&quot;,
	&quot;score&quot;: 99,
	&quot;birthday&quot;: &quot;2023-09-01&quot;
&#125;, &#123;
	&quot;id&quot;: 102,
	&quot;username&quot;: &quot;lisi&quot;,
	&quot;score&quot;: 99,
	&quot;birthday&quot;: &quot;2023-09-01&quot;
&#125;]

[&#123;&quot;id&quot;:100,&quot;username&quot;:&quot;xiaoming&quot;,&quot;score&quot;:99,&quot;birthday&quot;:&quot;2023-09-01&quot;&#125;,&#123;&quot;id&quot;:101,&quot;username&quot;:&quot;xiaohong&quot;,&quot;score&quot;:99,&quot;birthday&quot;:&quot;2023-09-01&quot;&#125;,&#123;&quot;id&quot;:102,&quot;username&quot;:&quot;lisi&quot;,&quot;score&quot;:99,&quot;birthday&quot;:&quot;2023-09-01&quot;&#125;]
</code></pre><p><img data-src="springboot-01-class.assets/image-20230901111047585.png" alt="image-20230901111047585"></p><p>json 对象嵌套数组</p><pre><code>&#123;
	&quot;msg&quot;: &quot;ok&quot;,
	&quot;status&quot;: 1,
	&quot;data&quot;: [&#123;
		&quot;id&quot;: 100,
		&quot;username&quot;: &quot;xiaoming&quot;,
		&quot;score&quot;: 99,
		&quot;birthday&quot;: &quot;2023-09-01&quot;
	&#125;, &#123;
		&quot;id&quot;: 101,
		&quot;username&quot;: &quot;xiaohong&quot;,
		&quot;score&quot;: 99,
		&quot;birthday&quot;: &quot;2023-09-01&quot;
	&#125;, &#123;
		&quot;id&quot;: 102,
		&quot;username&quot;: &quot;lisi&quot;,
		&quot;score&quot;: 99,
		&quot;birthday&quot;: &quot;2023-09-01&quot;
	&#125;]

&#125;
</code></pre><p>json 对象也可以嵌套对象</p><pre><code>&#123;
	&quot;msg&quot;: &quot;ok&quot;,
	&quot;status&quot;: 1,
	&quot;data&quot;: &#123;
		&quot;id&quot;: 100,
		&quot;username&quot;: &quot;xiaoming&quot;,
		&quot;score&quot;: 99,
		&quot;birthday&quot;: &quot;2023-09-01&quot;
	&#125;

&#125;
</code></pre><h3 id="处理器方法返回对象转json-responsebody标记在处理器方法上"><a class="anchor" href="#处理器方法返回对象转json-responsebody标记在处理器方法上">#</a> 处理器方法返回对象转 json @ResponseBody，标记在处理器方法上</h3><p>User 实体修改</p><pre><code>public class User implements Serializable &#123;

    private int id;

    private String username;

    private float score;

    // timezone = &quot;GMT+8&quot; 配置时区
    @JsonFormat(pattern = &quot;yyyy-MM-dd&quot;,timezone = &quot;GMT+8&quot;) //响应 1.当处理器方法返回对象时，将java.utils.Date 转化为对应的字符串 2023-08-31
                                                           //接收   2.如果前端提交的json字符串 使用java对象接收    字符串2023-08-31 转化为java.utils.Date类型
    @DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;) // 将前端提交的键值对的时间字符串2023-08-31 转化为java.utils.Date类型
    private Date birthday;
    
    。。。。。。。
    &#125;
</code></pre><pre><code>
    /**
     * url /testJson1?id=100
     * 根据id 查找user
     *
     * 如果处理器方法返回的是 普通的java对象，此时必须在处理器方法加注解@ResponseBody ，
     *                              将返回的对象转化为json 字符串
     * @param id
     * @return
     */
    @ResponseBody // 标记返回的对象 转化为json字符串
    @RequestMapping(&quot;/testJson1&quot;)
    public User testJson1(int id)&#123;

        // 假装去查找user
        User user = new User();
        user.setId(id);
        user.setUsername(&quot;xxxx&quot;);
        user.setScore(89f);
        user.setBirthday(new Date());

        return user;
    &#125;


    /**
     * 处理器返回map（对象） 转json
     *
     * @return
     */
    @ResponseBody
    @RequestMapping(&quot;/testJson2&quot;)
    public Map&lt;String,Object&gt; testJson2()&#123;

        HashMap&lt;String ,Object&gt; map = new HashMap&lt;&gt;();
        map.put(&quot;id&quot;,100);
        map.put(&quot;username&quot;,&quot;xiaoming&quot;);

        return map;
    &#125;

    /**
     * 处理方法返回 List集合（对象） 转json
     * @return
     */
    @ResponseBody
    @RequestMapping(&quot;/testJson3&quot;)
    public List&lt;User&gt;  testJson3()&#123;

        List&lt;User&gt; userList = new ArrayList&lt;&gt;();

        User user1 = new User();
        user1.setId(100);
        user1.setUsername(&quot;小明&quot;);
        user1.setScore(89f);
        user1.setBirthday(new Date());

        User user2 = new User();
        user2.setId(101);
        user2.setUsername(&quot;小红&quot;);
        user2.setScore(89f);
        user2.setBirthday(new Date());

        userList.add(user1);
        userList.add(user2);

        return userList;
    &#125;

</code></pre><h3 id="处理器方法接收json-转java-对象-使用requesbody标记在对象参数上"><a class="anchor" href="#处理器方法接收json-转java-对象-使用requesbody标记在对象参数上">#</a> 处理器方法接收 json 转 java 对象 使用 @RequesBody，标记在对象参数上</h3><p><strong>注意！！！！！：只有 post put 请求 可以提交 json 数据，get 请求不可以，因为 get 没有 body 体，无法携带 json 数据</strong></p><pre><code>
    /**
     * 当前处理器方法 接收post 请求提交的json数据，转化为user对象
     *
     * &#123;
     * 	&quot;id&quot;: 100,
     * 	&quot;username&quot;: &quot;小明&quot;,
     * 	&quot;score&quot;: 89.0,
     * 	&quot;birthday&quot;: &quot;2023-09-01&quot;
     * &#125;
     *
     *  @RequestBody User user将提交的json 数据转化为User对象
     * @param user
     * @return
     */
    @RequestMapping(&quot;/testJson4&quot;)
    @ResponseBody // 响应前端json
    public User testJson4( @RequestBody User user)&#123;


        System.out.println(&quot;user = &quot; + user);

        user.setUsername(user.getUsername() +&quot;testJson4 修改 &quot;);

        return user;
    &#125;

</code></pre><p><img data-src="springboot-01-class.assets/image-20230901115207809.png" alt="image-20230901115207809"></p><h2 id="56-拦截器"><a class="anchor" href="#56-拦截器">#</a> 5.6 拦截器</h2><p>拦截器 interceptor 是 spring 框架中的拦截，更为常用</p><p>过滤器 Filter 是 Servlet 中的拦截器，更底层一些</p><p>以上两个功能一致</p><blockquote><p>使用步骤，与 Servlet 中的过滤器思路基本一致</p><ul><li><p>编写自定义拦截器类</p></li><li><p>实现接口</p></li><li><p>重写拦截方法</p></li><li><p>配置拦截器</p><ul><li>这个不一样，以前是配置在 web.xml 中或者加上注解 @WebFilter</li><li>现在 SpringBoot 推荐使用 java 类的方式配置</li></ul></li></ul></blockquote><h4 id="实战"><a class="anchor" href="#实战">#</a> 实战</h4><p>1. 创建拦截器</p><pre><code>package com.qfedu.interceptor;

import org.springframework.stereotype.Component;
import org.springframework.web.servlet.HandlerInterceptor;
import org.springframework.web.servlet.ModelAndView;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

/**
 * 拦截器定义步骤
 *    1.实现HandlerInterceptor接口
 *      重写preHandle方法
 *    2.将当前拦截器加入到容器   @Component
 *
 *    3.需要向springboot声明拦截器
 */
@Component
public class MyInterceptor  implements HandlerInterceptor &#123;


    @Override  // 在请求调用处理器方法之前调用
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;

        // request 得到所有请求数据
        // response 可以响应前端

        System.out.println(&quot;MyInterceptor ---- preHandle&quot;);

        // true表示放行 不拦截
        // false 表示拦截，需要使用response 响应数据
        return true;
    &#125;

    @Override // 在请求调用处理器方法之后调用
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;

        System.out.println(&quot;MyInterceptor ---- postHandle&quot;);
    &#125;

    @Override// 在请求完成响应以后 前端调用
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;
        System.out.println(&quot;MyInterceptor ---- afterCompletion&quot;);
    &#125;
&#125;

</code></pre><p>2. 声明拦截器</p><pre><code>package com.qfedu.interceptor;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration // 表名当前类是一个配置类，而且也会加入到容器中
public class MyConfig  implements WebMvcConfigurer &#123;

    @Autowired // 从容器中获取拦截器
    private MyInterceptor myInterceptor;

    @Override // 通过此方法向spring 声明拦截器
    public void addInterceptors(InterceptorRegistry registry) &#123;

        // 加入拦截器
        registry.addInterceptor(myInterceptor)
                .addPathPatterns(&quot;/**&quot;) //拦截所有的路径
                .excludePathPatterns(&quot;/testA&quot;); // 表示不拦截/testA路径
    &#125;
&#125;

</code></pre><p><img data-src="springboot-01-class.assets/image-20230901143559426.png" alt="image-20230901143559426"></p><p>3. 测试</p><pre><code>http://localhost:8080/testD     # 访问的url 不要转发重定向 
</code></pre><p><img data-src="springboot-01-class.assets/image-20230901145519524.png" alt="image-20230901145519524"></p><p><img data-src="springboot-01-class.assets/image-20230901145557201.png" alt="image-20230901145557201"></p><h2 id="59-全局异常处理"><a class="anchor" href="#59-全局异常处理">#</a> 5.9 全局异常处理</h2><blockquote><p>SpringBoot 中有一个 ControllerAdvice 的注解，使用该注解表示开启了全局异常的捕获，我们只需在自定义一个方法使用 ExceptionHandler 注解然后定义捕获异常的类型即可对这些捕获的异常进行统一的处理。</p></blockquote><p><img data-src="springboot-01-class.assets/image-20230901153753159.png" alt="image-20230901153753159"></p><h4 id="实战-2"><a class="anchor" href="#实战-2">#</a> 实战</h4><p>1. 声明异常处理器</p><pre><code>package com.qfedu.exception;


import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.ResponseBody;

import java.util.HashMap;
import java.util.Map;

@ControllerAdvice  // 表明名当前类就是一个异常处理器类，可以处理所有请求的异常
public class MyExceptionHandler &#123;

     // 异常处理器
    // @ExceptionHandler(value = Exception.class) 只要异常是Exception异常的子类都可以处理
    @ExceptionHandler(value = Exception.class) // 表明当前方法是一个异常处理器方法
    @ResponseBody // 将Map转化为json 响应前端
    public Map&lt;String,Object&gt; exceptionHandler1(Exception e)&#123;

        e.printStackTrace();
        Map&lt;String,Object&gt;  result = new HashMap();

        result.put(&quot;code&quot;,500);
        result.put(&quot;msg&quot;,&quot;exceptionHandler1-服务器出错了&quot;+e.getMessage());

        return result;
    &#125;

    // @ExceptionHandler 配置的异常处理器越精确，优先级越高
    @ExceptionHandler(value = &#123;ArithmeticException.class&#125;)// 表示当前处理器只处理ArithmeticException.class 算数异常
    @ResponseBody
    public Map&lt;String,Object&gt; exceptionHandler2(Exception e)&#123;

        e.printStackTrace();
        Map&lt;String,Object&gt;  result = new HashMap();

        result.put(&quot;code&quot;,500);
        result.put(&quot;msg&quot;,&quot;exceptionHandler2-服务器出错了&quot;+e.getMessage());

        return result;
    &#125;
&#125;

</code></pre><p>2. 制造异常</p><pre><code>    /**
     *  @RequestMapping 默认请情况下可以 get post delete put
     *          method = RequestMethod.GET 表示当前请求方式只支持get
     * @return
     */
    @RequestMapping(value = &quot;/testA&quot;,method = RequestMethod.GET)
    public String testA()&#123;
        System.out.println(&quot;TestController-testA&quot;);

        int i = 1/0; // 我们处理器方法 难免会有报错，所有报错都是Exception子类

        return &quot;ok.html&quot;;

    &#125;
</code></pre><p>3. 测试</p><p><img data-src="springboot-01-class.assets/image-20230901154544422.png" alt="image-20230901154544422"></p><h1 id="六-mybatis"><a class="anchor" href="#六-mybatis">#</a> 六、Mybatis</h1><h2 id="61-之前的jdbc的使用缺点"><a class="anchor" href="#61-之前的jdbc的使用缺点">#</a> 6.1 之前的 JDBC 的使用缺点？</h2><ul><li>大量的代码重复</li><li>手动加载驱动，创建连接 (Connection), 关流</li><li>封装数据麻烦 (ORM)</li><li>效率不高 (没有缓存)</li></ul><h2 id="62-mybatis的介绍"><a class="anchor" href="#62-mybatis的介绍">#</a> 6.2 Mybatis 的介绍</h2><p>官网: <span class="exturl" data-url="aHR0cHM6Ly9teWJhdGlzLm9yZy9teWJhdGlzLTMv">mybatis – MyBatis 3 | Introduction</span></p><p><img data-src="https://qiushiju-tuchuang.oss-cn-hangzhou.aliyuncs.com/image/image-20221214102653736.png" alt="image-20221214102653736"></p><h3 id="什么是-mybatis"><a class="anchor" href="#什么是-mybatis">#</a> 什么是 MyBatis？</h3><p>MyBatis 是一款优秀的持久层框架，它支持自定义 SQL、存储过程以及高级映射。MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。</p><p>Mybatis 是一个 <code>半ORM框架</code> ，可以消除 JDBC 的代码和步骤，让开发者 <code>只关注SQL</code> 本身（便于开发者优化 sql）。</p><p>ORM 是对象关系映射，是指数据库表和 java 实体类一一对应.</p><p><img data-src="springboot-01-class.assets/image-20230901161135907.png" alt="image-20230901161135907"></p><p>半 ORM 框架：还是需要写 SQL, 由框架帮你完成映射</p><p>完全 ORM 框架：连 SQL 都不需要写，只需要遵循 ORM 的要求，就会自动生成 SQL 完成映射 (Hibernate,JPA 等)</p><p>注意：Hibernate 基本被淘汰，因为太强大，不需要写 sql，造成 sql 判断过多，效率低下</p><h2 id="63实战"><a class="anchor" href="#63实战">#</a> 6.3 实战</h2><h4 id="1创建工程"><a class="anchor" href="#1创建工程">#</a> 1. 创建工程</h4><p><img data-src="springboot-01-class.assets/image-20230901161545532.png" alt="image-20230901161545532"></p><h4 id="2导入依赖"><a class="anchor" href="#2导入依赖">#</a> 2. 导入依赖</h4><pre><code>&lt;!--引入父依赖--&gt;
&lt;parent&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
    &lt;version&gt;2.1.3.RELEASE&lt;/version&gt;
    &lt;relativePath/&gt;
&lt;/parent&gt;

&lt;dependencies&gt;

    &lt;!-- web相关依赖
        starter-web  web启动器 1.完成web相关jar的依赖 2.完成bean（对象）之间的自动装配
  --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
    &lt;/dependency&gt;

    &lt;!--
    starter-test  springboot单元测试启动器
    --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
    &lt;/dependency&gt;


        &lt;!-- 以下都是mybatis相关依赖--&gt;
    &lt;!-- 小辣椒 懒人神器--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
        &lt;artifactId&gt;lombok&lt;/artifactId&gt;
        &lt;optional&gt;true&lt;/optional&gt;
    &lt;/dependency&gt;
    &lt;!-- 阿里巴巴的Druid数据源依赖启动器 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
        &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;
        &lt;version&gt;1.1.10&lt;/version&gt;
    &lt;/dependency&gt;

    &lt;!-- MyBatis依赖启动器 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;
        &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;
        &lt;version&gt;2.0.0&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;!-- MySQL数据库连接驱动

       &lt;dependency&gt;
        &lt;groupId&gt;com.mysql&lt;/groupId&gt;
        &lt;artifactId&gt;mysql-connector-j&lt;/artifactId&gt;
        &lt;version&gt;8.1.0&lt;/version&gt;
    &lt;/dependency&gt;
    --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;mysql&lt;/groupId&gt;
        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
    &lt;/dependency&gt;



&lt;/dependencies&gt;
</code></pre><h4 id="3lombok"><a class="anchor" href="#3lombok">#</a> 3.lombok</h4><p>lombok 懒人神器，作用帮助我们自动生成 set get toSring 构造方法</p><p>lombok 在 idea 中需要安装插件，idea2021 以后都自带了 lombok，无需安装</p><p><img data-src="springboot-01-class.assets/image-20230901162149389.png" alt="image-20230901162149389"></p><pre><code>package com.qfedu.entity;

import com.fasterxml.jackson.annotation.JsonFormat;
import lombok.*;
import org.springframework.format.annotation.DateTimeFormat;

import java.io.Serializable;
import java.util.Date;

/**
 * @Setter
 * @Getter
 * @ToString
 * 以上三个等价于@Data
 */
@Data  //自动生成 set get toString方法
@AllArgsConstructor// 所有参数构造方法
@NoArgsConstructor // 无惨构造
public class Student  implements Serializable &#123;

    private int id;

    private String name;

    private int  age;

    private String sex;

    private float height;

    //只要遇到时间都加时间转换注解
    @JsonFormat(pattern = &quot;yyyy-MM-dd&quot;,timezone = &quot;GMT+8&quot;) //响应 1.当处理器方法返回对象时，将java.utils.Date 转化为对应的字符串 2023-08-31
    //接收   2.如果前端提交的json字符串 使用java对象接收    字符串2023-08-31 转化为java.utils.Date类型
    @DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;) // 将前端提交的键值对的时间字符串2023-08-31 转化为java.utils.Date类型
    private Date birthday;



&#125;

</code></pre><p>测试</p><pre><code>package com.qfedu.test;

import com.qfedu.entity.Student;

public class LombokTest &#123;
    public static void main(String[] args) &#123;


        Student student = new Student();

        student.setId(100);
        student.setName(&quot;xiaoming&quot;);

        System.out.println(&quot;student = &quot; + student);

    &#125;
&#125;

</code></pre><h4 id="4创建dao接口"><a class="anchor" href="#4创建dao接口">#</a> 4. 创建 Dao 接口</h4><pre><code>package com.qfedu.dao;

import com.qfedu.entity.Student;

import java.util.List;

/**
 * student_tb 相关增删改查
 */
public interface StudentDao &#123;

    /**
     * 查询所有学生
     * @return
     */
    List&lt;Student&gt; findAllStudent();
    
&#125;

</code></pre><p>5. 在 resource 创建 mapper/StudentDao.xml 映射文件</p><p>StudentDao.xml 作用：就是告诉 mybatis findAllStudent 方法应该执行什么 sql，返回结果封装什么类型对象（映射）</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;!--
  namespace 称为命名空间，一般是dao的类全限定名
            用于二级缓存隔离数据
  --&gt;
&lt;mapper namespace=&quot;com.qfedu.dao.StudentDao&quot;&gt;

    &lt;!--
        &lt;select标签 表示内部sql用于查询 
             id=&quot;findAllStudent&quot; 表示该查询对应哪个方法
              resultType=&quot;com.qfedu.entity.Student&quot; 配置的类型是将查询结果的每一行 转化为那种类型的对象
             
    --&gt;
    &lt;select id=&quot;findAllStudent&quot; resultType=&quot;com.qfedu.entity.Student&quot;&gt;
        SELECT id,name,age,sex,height,birthday from student_tb
    &lt;/select&gt;
    
&lt;/mapper&gt;
</code></pre><p><img data-src="springboot-01-class.assets/image-20230901163921883.png" alt="image-20230901163921883"></p><h4 id="6在resources-创建配置文件-applicationproperties"><a class="anchor" href="#6在resources-创建配置文件-applicationproperties">#</a> 6. 在 resources 创建配置文件 application.properties</h4><pre><code>
# 表示注释
# server.port 配置当前应用端口
server.port=8080

#druid相关配置  修改为自己的
spring.datasource.url=jdbc:mysql://localhost:3306/java2310_1?serverTimezone=Asia/Shanghai&amp;useSSL=false
spring.datasource.username=root
spring.datasource.password=123456

#配置spring-mybatis数据源为druid
spring.datasource.type=com.alibaba.druid.pool.DruidDataSource
#初始化连接池
spring.datasource.druid.initial-size=5
#最大链接数
spring.datasource.druid.max-active=10
#最小链接数
spring.datasource.druid.min-idle=3


#开启驼峰写法
#mybatis.configuration.map-underscore-to-camel-case=true

#如果配置文件  和 类名对应包名可以省略，否则 需要声明位置
mybatis.mapper-locations=classpath:mapper/*.xml

#配置别名
mybatis.type-aliases-package=com.qfedu.entity

#显示mybatis 日志 可以查看mybatis 的日志
logging.level.com.qfedu.dao=debug

</code></pre><p><img data-src="springboot-01-class.assets/image-20230901164539403.png" alt="image-20230901164539403"></p><h4 id="5创建启动类"><a class="anchor" href="#5创建启动类">#</a> 5 创建启动类</h4><pre><code>package com.qfedu;

import org.mybatis.spring.annotation.MapperScan;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@MapperScan(value = &quot;com.qfedu.dao&quot;) //配置mybatis的包扫描器
@SpringBootApplication
public class MyApplication &#123;

    public static void main(String[] args) &#123;

        SpringApplication.run(MyApplication.class,args);

    &#125;

&#125;

</code></pre><h4 id="6springboot单元测试"><a class="anchor" href="#6springboot单元测试">#</a> 6.springboot 单元测试</h4><pre><code>package com.qfedu;

import com.qfedu.dao.StudentDao;
import com.qfedu.entity.Student;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.junit4.SpringRunner;

import java.util.List;

/**
 * 创建springboot 单元测试类 所在的包必须是springboot启动类所在包，或者子包
 */

@RunWith(SpringRunner.class)
@SpringBootTest   //组合注解，表名当前类是springboot的单元测试
public class StudentDaoTest &#123;

    @Autowired  //从容器中获取StudentDao的实现类
    private StudentDao studentDao;


    /**
     *    @Test 表示当前方法是单元测试方法
     *       方法必须是 public void  而且无参
     */
    @Test
    public void findAllStudentTest()&#123;

        List&lt;Student&gt; allStudent = studentDao.findAllStudent();
        System.out.println(&quot;allStudent = &quot; + allStudent);
    &#125;

&#125;
</code></pre><p>测试</p><p><img data-src="springboot-01-class.assets/image-20230901165737520.png" alt="image-20230901165737520"></p><h4 id="7使用studentcontroller调用studentservice-studentdao"><a class="anchor" href="#7使用studentcontroller调用studentservice-studentdao">#</a> 7. 使用 StudentController 调用 StudentService StudentDao</h4><p>StudentService 相关</p><pre><code>package com.qfedu.service;

import com.qfedu.entity.Student;

import java.util.List;

public interface StudentService &#123;

    /**
     * 查询所有学生
     * @return
     */
    List&lt;Student&gt; findAllStudent();


&#125;

</code></pre><pre><code>package com.qfedu.service.impl;

import com.qfedu.dao.StudentDao;
import com.qfedu.entity.Student;
import com.qfedu.service.StudentService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.List;

@Service// 加入容器
public class StudentServiceImpl  implements StudentService &#123;

    @Autowired
    private StudentDao studentDao;

    @Override
    public List&lt;Student&gt; findAllStudent() &#123;
        return studentDao.findAllStudent();
    &#125;
&#125;

</code></pre><p>StudentController 相关</p><pre><code>package com.qfedu.controller;

import com.qfedu.entity.Student;
import com.qfedu.service.StudentService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;

import java.util.List;

@Controller
public class StudentController &#123;

    @Autowired //从容器中获取studentService
    private StudentService studentService;


    @ResponseBody
    @RequestMapping(&quot;/findAllStudent&quot;)
    public List&lt;Student&gt; findAllStudent()&#123;

        // 查询所有学生
        List&lt;Student&gt; allStudent = studentService.findAllStudent();

        return allStudent;

    &#125;

&#125;

</code></pre><p>测试</p><p><span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdDo4MDgwL2ZpbmRBbGxTdHVkZW50">http://localhost:8080/findAllStudent</span></p><p><img data-src="springboot-01-class.assets/image-20230901170344724.png" alt="image-20230901170344724"></p><p>mybatis 跳转插件</p><p><img data-src="springboot-01-class.assets/image-20230901170424384.png" alt="image-20230901170424384"></p><h2 id="64基于mybatis实现curd"><a class="anchor" href="#64基于mybatis实现curd">#</a> 6.4. 基于 mybatis 实现 curd</h2><h4 id="根据id查询学生"><a class="anchor" href="#根据id查询学生">#</a> 根据 id 查询学生</h4><p>接口</p><pre><code>
    /**
     * 根据id查找学生
     * @param id
     * @return
     */
    Student findStudentById(int id);
</code></pre><p>映射</p><pre><code>
    &lt;!--
         id = #&#123;id&#125; 获取findStudentById(int id)方法中参数id对象的值 （仅限于只有一个参数）
         查询结果：  所有的查询都要使用 resultType=&quot;com.qfedu.entity.Student&quot;
                          resultMap 配置查询结果的映射
         请求参数：   所有的参数类型都可以不写类型声明 parameterType=&quot;int&quot;
    --&gt;
    &lt;select id=&quot;findStudentById&quot; resultType=&quot;com.qfedu.entity.Student&quot; &gt;
        SELECT id,name,age,sex,height,birthday from student_tb where id = #&#123;id&#125;
    &lt;/select&gt;

</code></pre><p>说明</p><pre><code>- parameterType：为传入参数的类型    可以省略不写
- resultType：为输出参数的类型    必须写 

- #&#123;id&#125; 为占位符 获取接口中的参数
</code></pre><p>测试</p><pre><code> /**
     * 根据id查找学生
     */
    @Test
    public void findStudentByIdTest()&#123;
        Student student = studentDao.findStudentById(2);
        System.out.println(&quot;student = &quot; + student);
    &#125;
</code></pre><h4 id="增加学生"><a class="anchor" href="#增加学生">#</a> 增加学生</h4><p>dao 接口</p><pre><code> /**
     * 增加学生
     * 返回的受影响行数
     * @param student
     * @return
     */
    int  addStudent(Student student);
</code></pre><p>映射</p><pre><code>&lt;!--
        &lt;insert表示要执行插入的sql
            #&#123;name&#125;,#&#123;age&#125;,#&#123;sex&#125;,#&#123;height&#125;,#&#123;birthday&#125; 从请求参数 (Student student) student对象属性中获取参数

            插入的返回值：受影响的行数 不需要写 resultType！！！！！
            所有的增删改都不要写  resultType！！！！！
    --&gt;
    &lt;insert id=&quot;addStudent&quot; &gt;


        INSERT INTO  student_tb (name,age,sex,height,birthday) VALUES (#&#123;name&#125;,#&#123;age&#125;,#&#123;sex&#125;,#&#123;height&#125;,#&#123;birthday&#125; )

    &lt;/insert&gt;
</code></pre><p>测试</p><pre><code>  @Test //增加学生
    public void addStudentTest() throws ParseException &#123;

        Student student = new Student();
        student.setName(&quot;李四&quot;);
        student.setAge(18);
        student.setSex(&quot;F&quot;);
        student.setHeight(180);

        // 未来可能被淘汰
//        Date birthday = new Date(2003,5,1);

        SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);
        Date birthday = simpleDateFormat.parse(&quot;2003-05-01&quot;);

        student.setBirthday(birthday);

        // 返回值收影响行数
        int num = studentDao.addStudent(student);

        if(num &gt; 0)&#123;
            System.out.println(&quot; 增加成功num = &quot; + num);
        &#125;

    &#125;
</code></pre><h4 id="修改学生"><a class="anchor" href="#修改学生">#</a> 修改学生</h4><p>修改和增加没有任何区别</p><p>dao 接口</p><pre><code>
    /**
     * 更新学生
     * 返回受影响行数
     * @param student
     * @return
     */
    int  updateStudentById(Student student);
</code></pre><p>映射</p><pre><code>
    &lt;!--
        &lt;update 表示要执行更新的sql
         返回值是受影响行数 但是不需要写 resultType！！！！！
      --&gt;
    &lt;update id=&quot;updateStudentById&quot; &gt;

        UPDATE student_tb set name = #&#123;name&#125; ,age = #&#123;age&#125;,sex=#&#123;sex&#125;,height = #&#123;height&#125; ,birthday = #&#123;birthday&#125; WHERE id = #&#123;id&#125;

    &lt;/update&gt;

</code></pre><p>测试</p><pre><code>
    /**
     * 更新学生
     */
    @Test
    public void  updateStudentByIdTest() throws ParseException &#123;

        Student student = new Student();

        student.setId(27);
        student.setName(&quot;李老四&quot;);
        student.setAge(18);
        student.setSex(&quot;F&quot;);
        student.setHeight(180);

        SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);
        Date birthday = simpleDateFormat.parse(&quot;2003-05-01&quot;);

        student.setBirthday(birthday);

        int num =   studentDao.updateStudentById(student);

        if (num&gt;0)&#123;
            System.out.println(&quot;更新成功&quot;);
        &#125;
    &#125;
</code></pre><h4 id="根据id-删除学生"><a class="anchor" href="#根据id-删除学生">#</a> 根据 id 删除学生</h4><p>dao 接口</p><pre><code>   /**
     * 根据id 删除学生
     * @param id
     * @return
     */
    int deleteStudentById(int id);
</code></pre><p>映射</p><pre><code>    &lt;!--
          shift+ ctrl / 注释
          注释尽量不要写在 标签内部

           返回值是受影响行数 但是不需要写 resultType！！！！！
     --&gt;
    &lt;delete id=&quot;deleteStudentById&quot;&gt;
        delete from student_tb WHERE id = #&#123;id&#125;
    &lt;/delete&gt;
</code></pre><p>测试</p><pre><code>    /**
     * 根据id删除学生
     */
    @Test
    public void deleteStudentByIdTest()&#123;

        int num = studentDao.deleteStudentById(27);

        if (num&gt;0)&#123;
            System.out.println(&quot;删除成功&quot;);
        &#125;
    &#125;

</code></pre><h4 id="多参数查询"><a class="anchor" href="#多参数查询">#</a> 多参数查询</h4><p>需求： 通过年龄和性别查询</p><h5 id="mybatis34及以前版本存在多参数找不到问题"><a class="anchor" href="#mybatis34及以前版本存在多参数找不到问题">#</a> mybatis3.4 及以前版本存在多参数找不到问题</h5><pre><code>        &lt;!-- MyBatis依赖启动器 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;
            &lt;version&gt;2.0.0&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;
            &lt;version&gt;3.4.0&lt;/version&gt;
        &lt;/dependency&gt;

</code></pre><p><img data-src="springboot-01-class.assets/image-20230902113456772.png" alt="image-20230902113456772"></p><p><img data-src="springboot-01-class.assets/image-20230902113736348.png" alt="image-20230902113736348"></p><h6 id="多参数解决方法"><a class="anchor" href="#多参数解决方法">#</a> 多参数解决方法</h6><p>1 使用 param1 param2 解决</p><pre><code>   List&lt;Student&gt; findStudentByAgeAndSex(int age, String sex);
</code></pre><pre><code>&lt;!--
    多参数查询 findStudentByAgeAndSex(int age,String sex);
--&gt;
&lt;select id=&quot;findStudentByAgeAndSex&quot; resultType=&quot;com.qfedu.entity.Student&quot;&gt;
    SELECT id,name,age,sex,height,birthday from student_tb where age = #&#123;param1&#125; and sex = #&#123;param2&#125;
&lt;/select&gt;
</code></pre><p>2. 使用注解 @Param () 解决</p><pre><code>
    /**
     * 根据 年龄和性别 查询
     *
     * (@Param(&quot;age&quot;) int age 解决mybatis 3.4 以前版本直接使用#&#123;age&#125; #&#123;sex&#125; 报错
     *
     *         SELECT id,name,age,sex,height,birthday from student_tb where age = #&#123;age&#125; and sex = #&#123;sex&#125;
     * @param age
     * @param sex
     * @return
     */
     List&lt;Student&gt; findStudentByAgeAndSex(@Param(&quot;age&quot;) int age, @Param(&quot;sex&quot;) String sex);

</code></pre><pre><code> &lt;!--
        多参数查询 findStudentByAgeAndSex(int age,String sex);
    --&gt;
    &lt;select id=&quot;findStudentByAgeAndSex&quot; resultType=&quot;com.qfedu.entity.Student&quot;&gt;
        SELECT id,name,age,sex,height,birthday from student_tb where age = #&#123;age&#125; and sex = #&#123;sex&#125;
    &lt;/select&gt;
</code></pre><p>3. 使用 map 解决</p><pre><code>  /**
     * 根据年龄 和性别 查询
     * @param map
     * @return
     */
    List&lt;Student&gt; findStudentByAgeAndSex2(Map&lt;String,Object&gt; map);

</code></pre><pre><code>    &lt;!--
      where age = #&#123;age&#125; and sex = #&#123;sex&#125; 获取请求参数 Map&lt;String,Object&gt; map 中的属性
    --&gt;
    &lt;select id=&quot;findStudentByAgeAndSex2&quot; resultType=&quot;com.qfedu.entity.Student&quot;&gt;
        SELECT id,name,age,sex,height,birthday from student_tb where age = #&#123;age&#125; and sex = #&#123;sex&#125;
    &lt;/select&gt;

</code></pre><h5 id="如果是mybatis-34以后的版本包括35版本不存在多参数找不到问题"><a class="anchor" href="#如果是mybatis-34以后的版本包括35版本不存在多参数找不到问题">#</a> 如果是 mybatis 3.4 以后的版本（包括 3.5 版本）不存在多参数找不到问题！！！！！！！！！</h5><pre><code>&lt;!-- MyBatis依赖启动器 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;
            &lt;version&gt;2.0.0&lt;/version&gt;
        &lt;/dependency&gt;
</code></pre><p><img data-src="springboot-01-class.assets/image-20230902120033936.png" alt="image-20230902120033936"></p><p>可以直接使用 既可</p><pre><code>
    /**
     * 根据 年龄和性别 查询
     *

     * @param age
     * @param sex
     * @return
     */
     List&lt;Student&gt; findStudentByAgeAndSex(int age,  String sex);

</code></pre><p>​</p><pre><code>    &lt;!--
        多参数查询 findStudentByAgeAndSex(int age,String sex);
    --&gt;
    &lt;select id=&quot;findStudentByAgeAndSex&quot; resultType=&quot;com.qfedu.entity.Student&quot;&gt;
        SELECT id,name,age,sex,height,birthday from student_tb where age = #&#123;age&#125; and sex = #&#123;sex&#125;
    &lt;/select&gt;

</code></pre><p><img data-src="springboot-01-class.assets/image-20230902120701604.png" alt="image-20230902120701604"></p><h4 id="typealiases别名"><a class="anchor" href="#typealiases别名">#</a> typeAliases 别名</h4><pre><code>#配置别名 统一为当前包下的实体类取别名 别名为类名 首字母也可以小写
#  com.qfedu.entity.Student   别名  Student  student
mybatis.type-aliases-package=com.qfedu.entity
</code></pre><pre><code>    &lt;!--
        &lt;select标签 表示内部sql用于查询
             id=&quot;findAllStudent&quot; 表示该查询对应哪个方法
              resultType=&quot;com.qfedu.entity.Student&quot; 配置的类型是将查询结果的每一行 转化为那种类型的对象

         resultType=&quot;Student&quot; 使用别名配置需要转换的类型
         resultType=&quot;student&quot;
    --&gt;
    &lt;select id=&quot;findAllStudent&quot; resultType=&quot;student&quot;&gt;
        SELECT id,name,age,sex,height,birthday from student_tb
    &lt;/select&gt;
</code></pre><h3 id="查询的结果集一般都要使用实体类接收其实也可以使用map接收"><a class="anchor" href="#查询的结果集一般都要使用实体类接收其实也可以使用map接收">#</a> 查询的结果集，一般都要使用实体类接收，其实也可以使用 Map 接收</h3><p>适用于查询结果和实体类不照应情况</p><p><img data-src="springboot-01-class.assets/image-20230902145450495.png" alt="image-20230902145450495"></p><p>dao 接口</p><pre><code> /**
     * 查询 性别 对应的平均身高  年龄
     * @return
     */
    List&lt;Map&gt; getAvgAgeAndHeightBySex();

</code></pre><p>映射</p><pre><code>    &lt;!--
        resultType=&quot;map&quot; 将查询的结果集使用map接收
    --&gt;
    &lt;select id=&quot;getAvgAgeAndHeightBySex&quot; resultType=&quot;map&quot;&gt;

        SELECT  sex,AVG(height) avg_height ,AVG(age) avg_age FROM student_tb GROUP BY sex;
    &lt;/select&gt;

</code></pre><p>测试</p><pre><code>
    /**
     * 根据性别查询平局年龄 身高
     */
    @Test
    public void  getAvgAgeAndHeightBySexTest()&#123;

        List&lt;Map&gt; mapList = studentDao.getAvgAgeAndHeightBySex();

        for (Map map : mapList) &#123;
            System.out.println(&quot;map = &quot; + map);
        &#125;

    &#125;
</code></pre><h2 id="65-orm映射"><a class="anchor" href="#65-orm映射">#</a> 6.5 ORM 映射</h2><hr><h3 id="651-mybatis自动orm失效"><a class="anchor" href="#651-mybatis自动orm失效">#</a> 6.5.1 MyBatis 自动 ORM 失效</h3><p><img data-src="springboot-01-class.assets/image-20230902150512399.png" alt="image-20230902150512399"></p><h4 id="开启驼峰映射"><a class="anchor" href="#开启驼峰映射">#</a> 开启驼峰映射</h4><p>在配置文件开启驼峰映射</p><pre><code>#开启驼峰写法
# 如果查询结果集 列名自动转换为驼峰  student_info ===&gt; studentInfo 此时可以自动映射属性
mybatis.configuration.map-underscore-to-camel-case=true

</code></pre><p>直接使用</p><pre><code>    &lt;!--
        解决列名映射 不一致问题：
                1.使用驼峰 自动映射
    --&gt;
    &lt;select id=&quot;findAllStudent&quot; resultType=&quot;student&quot;&gt;
        SELECT id,name,age,sex,height,birthday,student_info from student_tb
    &lt;/select&gt;
</code></pre><h4 id="列的别名"><a class="anchor" href="#列的别名">#</a> 列的别名</h4><blockquote><p>在 SQL 中使用 as 为查询字段添加列别名，以匹配属性名。</p></blockquote><pre><code>    &lt;!--
        解决列名映射 不一致问题：
                1.使用驼峰 自动映射
                2.使用列的别名   student_info as studentInfo
    --&gt;
    &lt;select id=&quot;findAllStudent&quot; resultType=&quot;student&quot;&gt;
        SELECT id,name,age,sex,height,birthday,student_info as studentInfo from student_tb
    &lt;/select&gt;

</code></pre><p><img data-src="springboot-01-class.assets/image-20230902151158288.png" alt="image-20230902151158288"></p><h3 id="结果映射resultmap-查询结果的封装规则"><a class="anchor" href="#结果映射resultmap-查询结果的封装规则">#</a> 结果映射（ResultMap - 查询结果的封装规则）</h3><blockquote><p>通过 &lt;resultMap id=&quot;&quot;type=&quot;&quot;&gt; 映射，匹配列名与属性名。</p></blockquote><p>dao 接口</p><pre><code> /**
     * 查询所有学生
     * @return
     */
    List&lt;Student&gt; findAllStudent2();
</code></pre><p>映射</p><pre><code>    &lt;!--
        &lt;resultMap 声明一个自定义映射 可以将查询结果集的列名  和 实体属性名 进行手动一一映射，还可以解决一对一 一对多问题

             &lt;id column=&quot;id&quot; property=&quot;id&quot;&gt;&lt;/id&gt;  &lt;id 对应表的主键列 将表中主键id列 映射到实体类属性id
                            column=&quot;id&quot; 查询结果集的列名
                             property=&quot;id&quot; java实体类属性id
              &lt;result column=&quot;name&quot; property=&quot;name&quot;&gt;&lt;/result&gt; &lt;result 指定普通列的映射
                            column=&quot;name&quot;       查询结果集的列名
                             property=&quot;name&quot;    java实体类属性name
    --&gt;
    &lt;resultMap id=&quot;studentMap1&quot; type=&quot;com.qfedu.entity.Student&quot;&gt;

        &lt;!-- 如果 结果集的列和 属性名一致，也可以省略--&gt;
        &lt;id column=&quot;id&quot; property=&quot;id&quot;&gt;&lt;/id&gt;
        &lt;result column=&quot;name&quot; property=&quot;name&quot;&gt;&lt;/result&gt;
        &lt;result column=&quot;age&quot; property=&quot;age&quot;&gt;&lt;/result&gt;
        &lt;result column=&quot;sex&quot; property=&quot;sex&quot;&gt;&lt;/result&gt;
        &lt;result column=&quot;height&quot; property=&quot;height&quot;&gt;&lt;/result&gt;
        &lt;result column=&quot;birthday&quot; property=&quot;birthday&quot;&gt;&lt;/result&gt;

        &lt;!-- 此时完成 查询结果集列名student_info  和实体类studentInfo 映射  --&gt;
        &lt;result column=&quot;student_info&quot; property=&quot;studentInfo&quot;&gt;&lt;/result&gt;

    &lt;/resultMap&gt;

    &lt;!--
        resultMap=&quot;studentMap1&quot; 使用自定义的resultMap进行 映射
    --&gt;
    &lt;select id=&quot;findAllStudent2&quot; resultMap=&quot;studentMap1&quot;&gt;
        SELECT id,name,age,sex,height,birthday,student_info  from student_tb
    &lt;/select&gt;

</code></pre><p>测试</p><pre><code>
    /**
     *    @Test 表示当前方法是单元测试方法
     *       方法必须是 public void  而且无参
     */
    @Test
    public void findAllStudent2Test()&#123;

        List&lt;Student&gt; allStudent = studentDao.findAllStudent2();
        System.out.println(&quot;allStudent = &quot; + allStudent);
    &#125;

</code></pre><h2 id="66mybatis多表查询"><a class="anchor" href="#66mybatis多表查询">#</a> 6.6mybatis 多表查询</h2><p>mybatis 将多张表关联的查询结果，映射到 java 的实体类中</p><p><img data-src="springboot-01-class.assets/image-20230904104732900.png" alt="image-20230904104732900"></p><h4 id="多表查询分为两种"><a class="anchor" href="#多表查询分为两种">#</a> 多表查询分为两种</h4><ul><li>一对一</li></ul><p>一个成绩归属于一个学生</p><pre><code>SELECT a.id,a.course,a.score,a.student_id,b.id sid , b.name,b.sex,b.age,b.height,b.birthday,b.student_info 
		FROM score_tb a LEFT JOIN student_tb b on a.student_id = b.id;
</code></pre><p><img data-src="springboot-01-class.assets/image-20230904105141177.png" alt="image-20230904105141177"></p><p><img data-src="springboot-01-class.assets/image-20230904105324578.png" alt="image-20230904105324578"></p><ul><li>一对多</li></ul><p>一个学生可以有多个成绩</p><pre><code>SELECT a.id,a.name, a.sex,a.age,a.height,a.birthday,a.student_info,
	     b.id sid,b.course,b.score,b.student_id 
	FROM student_tb a LEFT JOIN score_tb b on a.id = b.student_id

</code></pre><p><img data-src="springboot-01-class.assets/image-20230904105808301.png" alt="image-20230904105808301"></p><p><img data-src="springboot-01-class.assets/image-20230904110106271.png" alt="image-20230904110106271"></p><h3 id="一对一实战"><a class="anchor" href="#一对一实战">#</a> 一对一实战</h3><p><img data-src="springboot-01-class.assets/image-20230904111659281.png" alt="image-20230904111659281"></p><p>1. 创建实体类</p><pre><code>package com.qfedu.entity;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.io.Serializable;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class Score  implements Serializable &#123;

    private int id;

    private String course;

    private float score;

    private int studentId;

    private Student student;

&#125;

</code></pre><p>2.ScoreDao 接口</p><pre><code>package com.qfedu.dao;

import com.qfedu.entity.Score;

import java.util.List;

public interface ScoreDao &#123;


    /**
     * 一对一查询
     *      查询所有成绩 并包含归属的学生信息
     * @return
     */
    List&lt;Score&gt; findAllScoreWithStudent();

&#125;

</code></pre><p>3. 对应的映射</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.qfedu.dao.ScoreDao&quot;&gt;


    &lt;resultMap id=&quot;scoreMap1&quot; type=&quot;com.qfedu.entity.Score&quot;&gt;
        &lt;!-- 左表的映射--&gt;
        &lt;id column=&quot;id&quot; property=&quot;id&quot;&gt;&lt;/id&gt;
        &lt;result column=&quot;course&quot; property=&quot;course&quot;&gt;&lt;/result&gt;
        &lt;result column=&quot;score&quot; property=&quot;score&quot;&gt;&lt;/result&gt;
        &lt;result column=&quot;student_id&quot; property=&quot;studentId&quot;&gt;&lt;/result&gt;
        &lt;!--
            右表映射
                 &lt;association 完成一对一的右表映射
                 property=&quot;student&quot; 要设置到Score中的属性
                  column=&quot;student_id&quot; 对应左表和右表关联的左边关联的列
                   javaType=&quot;com.qfedu.entity.Student&quot; 将查询的右表转化为一个对象
        --&gt;
        &lt;association property=&quot;student&quot; column=&quot;student_id&quot; javaType=&quot;com.qfedu.entity.Student&quot;&gt;
                &lt;id column=&quot;student_id&quot; property=&quot;id&quot;&gt;&lt;/id&gt;
                &lt;result column=&quot;name&quot; property=&quot;name&quot;&gt;&lt;/result&gt;
                &lt;result column=&quot;sex&quot; property=&quot;sex&quot;&gt;&lt;/result&gt;
                &lt;result column=&quot;age&quot; property=&quot;age&quot;&gt;&lt;/result&gt;
                &lt;result column=&quot;height&quot; property=&quot;height&quot;&gt;&lt;/result&gt;
                &lt;result column=&quot;birthday&quot; property=&quot;birthday&quot;&gt;&lt;/result&gt;
                &lt;result column=&quot;student_info&quot; property=&quot;studentInfo&quot;&gt;&lt;/result&gt;

        &lt;/association&gt;

    &lt;/resultMap&gt;

    &lt;!-- 一对一查询
          使用resultMap 完成查询结果的映射
    --&gt;
    &lt;select id=&quot;findAllScoreWithStudent&quot; resultMap=&quot;scoreMap1&quot;&gt;

        SELECT a.id,a.course,a.score,a.student_id,b.id sid , b.name,b.sex,b.age,b.height,b.birthday,b.student_info
        FROM score_tb a LEFT JOIN student_tb b on a.student_id = b.id;

    &lt;/select&gt;

&lt;/mapper&gt;
</code></pre><p>4 测试</p><pre><code>package com.qfedu;

import com.qfedu.dao.ScoreDao;
import com.qfedu.entity.Score;
import lombok.AllArgsConstructor;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.junit4.SpringRunner;

import java.util.List;

@RunWith(SpringRunner.class)
@SpringBootTest
public class MybatisTest &#123;


    @Autowired
    private ScoreDao scoreDao;


    /**
     * 一对一映射
     */
    @Test
    public void findAllScoreWithStudentTest()&#123;


        List&lt;Score&gt; allScoreWithStudent = scoreDao.findAllScoreWithStudent();

        for (Score score : allScoreWithStudent) &#123;
            System.out.println(&quot;score = &quot; + score);
        &#125;

    &#125;




&#125;
</code></pre><pre><code>
</code></pre><p><img data-src="springboot-01-class.assets/image-20230904113512626.png" alt="image-20230904113512626"></p><h3 id="一对多实战"><a class="anchor" href="#一对多实战">#</a> 一对多实战</h3><p><img data-src="springboot-01-class.assets/image-20230904142510126.png" alt="image-20230904142510126"></p><p>1. 在 Student 实体类增加属性</p><pre><code>package com.qfedu.entity;

import com.fasterxml.jackson.annotation.JsonFormat;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.springframework.format.annotation.DateTimeFormat;

import java.io.Serializable;
import java.util.Date;
import java.util.List;

/**
 * @Setter
 * @Getter
 * @ToString
 * 以上三个等价于@Data
 */
@Data  //自动生成 set get toString方法
@AllArgsConstructor// 所有参数构造方法
@NoArgsConstructor // 无惨构造
public class Student implements Serializable &#123;

    private int id;

    private String name;

    private int  age;

    private String sex;

    private float height;

    //只要遇到时间都加时间转换注解
    @JsonFormat(pattern = &quot;yyyy-MM-dd&quot;,timezone = &quot;GMT+8&quot;) //响应 1.当处理器方法返回对象时，将java.utils.Date 转化为对应的字符串 2023-08-31
    //接收   2.如果前端提交的json字符串 使用java对象接收    字符串2023-08-31 转化为java.utils.Date类型
    @DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;) // 将前端提交的键值对的时间字符串2023-08-31 转化为java.utils.Date类型
    private Date birthday;

    // 此时 studentInfo和 数据表中的字段不一致
    private  String studentInfo;



    private  List&lt;Score&gt; scoreList;


&#125;

</code></pre><p>2.StudentDao</p><pre><code>package com.qfedu.dao;

import com.qfedu.entity.Student;

import java.util.List;

public interface StudentDao &#123;

    /**
     * 查询所有学生 并包含对应的成绩
     * @return
     */
    List&lt;Student&gt; findAllStudentWithScore();

&#125;

</code></pre><p>3. 映射 StudentDao.xml</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.qfedu.dao.StudentDao&quot;&gt;


    &lt;resultMap id=&quot;studentMap1&quot; type=&quot;com.qfedu.entity.Student&quot;&gt;
        &lt;!-- 配置左表 学生表--&gt;
        &lt;id column=&quot;id&quot; property=&quot;id&quot;&gt;&lt;/id&gt;
        &lt;result column=&quot;name&quot; property=&quot;name&quot;&gt;&lt;/result&gt;
        &lt;result column=&quot;sex&quot; property=&quot;sex&quot;&gt;&lt;/result&gt;
        &lt;result column=&quot;age&quot; property=&quot;age&quot;&gt;&lt;/result&gt;
        &lt;result column=&quot;height&quot; property=&quot;height&quot;&gt;&lt;/result&gt;
        &lt;result column=&quot;birthday&quot; property=&quot;birthday&quot;&gt;&lt;/result&gt;
        &lt;result column=&quot;student_info&quot; property=&quot;studentInfo&quot;&gt;&lt;/result&gt;

        &lt;!--  映射右表
            collection 配置一对多的右表，将多行右表中的结果转化为集合
                property=&quot;scoreList&quot; 对应Student属性的成绩集合
                column=&quot;id&quot; 左表关联的列
                ofType=&quot;com.qfedu.entity.Score&quot; 表示同一个学生对应的每一个成绩转化为一个Score对象 放置到list集合中


        --&gt;
        &lt;collection property=&quot;scoreList&quot; column=&quot;id&quot; ofType=&quot;com.qfedu.entity.Score&quot; &gt;
            &lt;id column=&quot;sid&quot; property=&quot;id&quot;&gt;&lt;/id&gt;
            &lt;result column=&quot;course&quot; property=&quot;course&quot;&gt;&lt;/result&gt;
            &lt;result column=&quot;score&quot; property=&quot;score&quot;&gt;&lt;/result&gt;
            &lt;!--  一对多  关联的列 尽量使用右表的值  --&gt;
            &lt;result column=&quot;student_id&quot;   property=&quot;studentId&quot;&gt;&lt;/result&gt;
        &lt;/collection&gt;

    &lt;/resultMap&gt;

    &lt;select id=&quot;findAllStudentWithScore&quot; resultMap=&quot;studentMap1&quot;&gt;
        SELECT a.id,a.name, a.sex,a.age,a.height,a.birthday,a.student_info,
               b.id sid,b.course,b.score,b.student_id
        FROM student_tb a LEFT JOIN score_tb b on a.id = b.student_id
    &lt;/select&gt;



&lt;/mapper&gt;
</code></pre><p>4. 测试</p><pre><code>   @Autowired
    private StudentDao studentDao;


    /**
     * 一对多查询
     */
    @Test
    public void  findAllStudentWithScoreTest()&#123;

        List&lt;Student&gt; allStudentWithScore = studentDao.findAllStudentWithScore();

        for (Student student : allStudentWithScore) &#123;
            System.out.println(&quot;student = &quot; + student);
        &#125;
    &#125;
</code></pre><p><img data-src="springboot-01-class.assets/image-20230904144117365.png" alt="image-20230904144117365"></p><h3 id="多对多"><a class="anchor" href="#多对多">#</a> 多对多</h3><p><img data-src="springboot-01-class.assets/image-20230904150753100.png" alt="image-20230904150753100"></p><p>查询所有的角色并包含对应的学生 列表</p><p>左表是角色 右表，学生角色中间表 学生表</p><pre><code>SELECT * from role_tb 

SELECT * from role_tb  r LEFT JOIN  student_role_tb sr on r.roleid=
		sr.roleid

SELECT r.*,s.* from role_tb  r 
		LEFT JOIN  student_role_tb sr on r.roleid=sr.roleid
    LEFT JOIN  student_tb s  on  sr.studentid = s.id
		
</code></pre><p><img data-src="springboot-01-class.assets/image-20230904151435067.png" alt="image-20230904151435067"></p><p>1. 创建 Role 实体类</p><pre><code>package com.qfedu.entity;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.io.Serializable;
import java.util.List;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class Role implements Serializable &#123;

    private int roleId;

    private String roleName;

    private List&lt;Student&gt; studentList;

&#125;

</code></pre><p>2.RoleDao</p><pre><code>package com.qfedu.dao;

import com.qfedu.entity.Role;

import java.util.List;

public interface RoleDao &#123;

    /**
     * 多对多中的一对多
     * 查询所有角色 包含对应成绩
     * @return
     */
  List&lt;Role&gt; findAllRoleWithStudent();

&#125;

</code></pre><p>3.RoleDao.xml</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.qfedu.dao.RoleDao&quot;&gt;


    &lt;resultMap id=&quot;roleMap1&quot; type=&quot;com.qfedu.entity.Role&quot;&gt;
        &lt;!-- 左表映射--&gt;
        &lt;id column=&quot;roleid&quot; property=&quot;roleId&quot;&gt;&lt;/id&gt;
        &lt;result column=&quot;rolename&quot; property=&quot;roleName&quot;&gt;&lt;/result&gt;

        &lt;!-- 右表映射
              column=&quot;roleid&quot; 对应左表的关联列
        --&gt;
        &lt;collection property=&quot;studentList&quot; column=&quot;roleid&quot; ofType=&quot;com.qfedu.entity.Student&quot;&gt;
            &lt;id column=&quot;id&quot; property=&quot;id&quot;&gt;&lt;/id&gt;
            &lt;result column=&quot;name&quot; property=&quot;name&quot;&gt;&lt;/result&gt;
            &lt;result column=&quot;sex&quot; property=&quot;sex&quot;&gt;&lt;/result&gt;
            &lt;result column=&quot;age&quot; property=&quot;age&quot;&gt;&lt;/result&gt;
            &lt;result column=&quot;height&quot; property=&quot;height&quot;&gt;&lt;/result&gt;
            &lt;result column=&quot;birthday&quot; property=&quot;birthday&quot;&gt;&lt;/result&gt;
            &lt;result column=&quot;student_info&quot; property=&quot;studentInfo&quot;&gt;&lt;/result&gt;
        &lt;/collection&gt;
    &lt;/resultMap&gt;

    &lt;select id=&quot;findAllRoleWithStudent&quot; resultMap=&quot;roleMap1&quot;&gt;

        SELECT r.*,s.* from role_tb  r
                                LEFT JOIN  student_role_tb sr on r.roleid=sr.roleid
                                LEFT JOIN  student_tb s  on  sr.studentid = s.id
    &lt;/select&gt;

&lt;/mapper&gt;
</code></pre><p>4. 测试</p><pre><code> @Autowired
    private RoleDao roleDao;

    /**
     * 多对多测试
     */
    @Test
    public void findAllRoleWithStudentTest()&#123;

        List&lt;Role&gt; allRoleWithStudent = roleDao.findAllRoleWithStudent();

        for (Role role : allRoleWithStudent) &#123;
            System.out.println(&quot;role = &quot; + role);
        &#125;

    &#125;
</code></pre><p><img data-src="springboot-01-class.assets/image-20230904152234520.png" alt="image-20230904152234520"></p><h2 id="67mybatis-的动态-sql-语句"><a class="anchor" href="#67mybatis-的动态-sql-语句">#</a> 6.7Mybatis 的动态 SQL 语句</h2><h3 id="671动态sql语句if"><a class="anchor" href="#671动态sql语句if">#</a> 6.7.1 动态 sql 语句 &lt;if&gt;</h3><p>在后台管理系统中，经常遇到多条件查询</p><p>1. 查询所有学生</p><pre><code> SELECT id,name,age,sex,height,birthday,student_info as studentInfo from student_tb
</code></pre><p>2. 按照性别查询所有学生</p><pre><code> SELECT id,name,age,sex,height,birthday,student_info as studentInfo from student_tb where
 sex = #&#123;sex&#125;
</code></pre><p>3. 按照姓名模糊查询学生</p><pre><code> SELECT id,name,age,sex,height,birthday,student_info as studentInfo from student_tb where
 name like #&#123;name&#125;
</code></pre><p>4. 按照性别 姓名查询学生</p><pre><code> SELECT id,name,age,sex,height,birthday,student_info as studentInfo from student_tb where
 name like #&#123;name&#125;  and sex = #&#123;sex&#125;
</code></pre><p>以上查询我们可以在一个 sql 中完成，通过动态 sql &lt;if&gt; 标签进项 sql 的动态拼接</p><pre><code> SELECT id,name,age,sex,height,birthday,student_info as studentInfo 
			from student_tb WHERE  1=1  
					AND sex = 'F'
          AND name like '%洋%'
</code></pre><h4 id="实战-3"><a class="anchor" href="#实战-3">#</a> 实战</h4><p>1.StudentDao 增加</p><pre><code>   /**
     * 按照条件查询所有学生
     *  Student student 封装查询条件
     * @param student
     * @return
     */
    List&lt;Student&gt; findStudentByCondition(Student student);

</code></pre><p>2. 对应映射</p><pre><code>
    &lt;!--按照条件查询
          &lt;if test=&quot;name !=null and name!=''&quot;&gt;  动态sql
                            测试参数name不为null 不等于空  如果条件成立，拼接内部sql
                                    AND name like #&#123;name&#125;
    --&gt;
    &lt;select id=&quot;findStudentByCondition&quot; resultType=&quot;com.qfedu.entity.Student&quot;&gt;
        SELECT id,name,age,sex,height,birthday,student_info as studentInfo
                from student_tb WHERE  1=1
         &lt;if test=&quot;name !=null and name!=''&quot;&gt;
             AND name like #&#123;name&#125;
         &lt;/if&gt;
        &lt;if test=&quot;sex !=null and sex!=''&quot;&gt;
            AND sex = #&#123;sex&#125;
        &lt;/if&gt;
         

    &lt;/select&gt;
</code></pre><p>3 测试</p><pre><code>
    /**
     * 多条件查询学生
     *  动态sql &lt;if
     */
    @Test
    public void  findStudentByConditionTest()&#123;

        Student student = new Student();

        // 如果student的属性都为null  执行：SELECT id,name,age,sex,height,birthday,student_info as studentInfo from student_tb WHERE 1=1

        student.setName(&quot;%洋%&quot;); // 此时执行sql  SELECT id,name,age,sex,height,birthday,student_info as studentInfo from student_tb WHERE 1=1 AND name like ?

        student.setSex(&quot;F&quot;); // 此时执行sql  SELECT id,name,age,sex,height,birthday,student_info as studentInfo from student_tb WHERE 1=1 AND name like ? AND sex = ?

        List&lt;Student&gt; studentList = studentDao.findStudentByCondition(student);
        System.out.println(&quot;studentList = &quot; + studentList);

    &#125;

</code></pre><p><img data-src="springboot-01-class.assets/image-20230904161817961.png" alt="image-20230904161817961"></p><h3 id="672动态sql语句-where-where"><a class="anchor" href="#672动态sql语句-where-where">#</a> 6.7.2 动态 sql 语句 &lt;where&gt; &lt;/where&gt;</h3><p>&lt;where&gt; &lt;/where &gt; 可以替代 sql 语句中的 where 1=1</p><pre><code>&lt;!--按照条件查询
          &lt;if test=&quot;name !=null and name!=''&quot;&gt;  动态sql
                            测试参数name不为null 不等于空  如果条件成立，拼接内部sql
                                    AND name like #&#123;name&#125;

             &lt;where&gt; 本质： 1.等价于 where   1=1
                           2.自动将第一个and 去掉
    --&gt;
    &lt;select id=&quot;findStudentByCondition&quot; resultType=&quot;com.qfedu.entity.Student&quot;&gt;
        SELECT id,name,age,sex,height,birthday,student_info as studentInfo
                from student_tb
                &lt;where&gt;
                    &lt;if test=&quot;name !=null and name!=''&quot;&gt;
                        AND name like #&#123;name&#125;
                    &lt;/if&gt;
                    &lt;if test=&quot;sex !=null and sex!=''&quot;&gt;
                        AND sex = #&#123;sex&#125;
                    &lt;/if&gt;
                &lt;/where&gt;
         

    &lt;/select&gt;
</code></pre><p><img data-src="springboot-01-class.assets/image-20230904162247837.png" alt="image-20230904162247837"></p><h3 id="673动态语句foreach-foreach"><a class="anchor" href="#673动态语句foreach-foreach">#</a> 6.7.3 动态语句 &lt;foreach&gt; &lt;/foreach&gt;</h3><p>&lt;foreach&gt; 标签是为解决 mybatis 接受集合参数设置的。适用场景如下</p><pre><code># 根据id列表查询
 SELECT id,name,age,sex,height,birthday,student_info as studentInfo 
			from student_tb WHERE id in (1,3,5,7,9)
</code></pre><p>1. 创建接口</p><pre><code>
    /**
     * 根据id列表 查询学生
     * @Param(&quot;ids&quot;) List&lt;Integer&gt; ids 使用@Param(&quot;ids&quot;)  解决动态sql 无法获取问题
     * @param ids
     * @return
     */
    List&lt;Student&gt; findStudentByIds(@Param(&quot;ids&quot;) List&lt;Integer&gt; ids);
</code></pre><p>2 映射</p><pre><code>
    &lt;!--
        # 根据id列表查询
 SELECT id,name,age,sex,height,birthday,student_info as studentInfo
			from student_tb WHERE id in (1,3,5,7,9)\

	      &lt;foreach collection=&quot;ids&quot; item=&quot;id&quot;&gt;
	            collection=&quot;ids&quot;  遍历集合的参数名
	            item=&quot;id&quot; 遍历集合中的每一个赋值给id
	             open=&quot;and id in (&quot; 拼接的开头
	             close=&quot;)&quot; 拼接的结尾
	             separator=&quot;,&quot; 每隔元素的分割
	                    #&#123;id&#125; 获取赋值的id变量

    --&gt;
    &lt;select id=&quot;findStudentByIds&quot; resultType=&quot;com.qfedu.entity.Student&quot;&gt;
        SELECT id,name,age,sex,height,birthday,student_info as studentInfo from student_tb
        &lt;where&gt;
              
            &lt;if test=&quot;ids !=null and ids.size()&gt;0&quot;&gt;

                    &lt;foreach collection=&quot;ids&quot; item=&quot;id&quot; open=&quot;and id in (&quot; close=&quot;)&quot; separator=&quot;,&quot;&gt;
                            #&#123;id&#125;
                    &lt;/foreach&gt;

            &lt;/if&gt;

        &lt;/where&gt;

    &lt;/select&gt;

</code></pre><p><img data-src="springboot-01-class.assets/image-20230904163059324.png" alt="image-20230904163059324"></p><p>3. 测试</p><pre><code>
    /**
     * 根据id 列表查询
     * 动态sql &lt;foreach&gt;&lt;/foreach&gt;
     */
    @Test
    public void findStudentByIdsTest()&#123;

        List&lt;Integer&gt; ids = new ArrayList&lt;&gt;();

        ids.add(1);
        ids.add(3);
        ids.add(5);
        ids.add(7);
        ids.add(9);

        // 执行sql  SELECT id,name,age,sex,height,birthday,student_info as studentInfo from student_tb WHERE id in ( ? , ? , ? , ? , ? )

        List&lt;Student&gt; studentList = studentDao.findStudentByIds(ids);
        System.out.println(&quot;studentList = &quot; + studentList);
    &#125;
</code></pre><p><img data-src="springboot-01-class.assets/image-20230904163729547.png" alt="image-20230904163729547"></p><h3 id="674动态语句sql-sql"><a class="anchor" href="#674动态语句sql-sql">#</a> 6.7.4 动态语句 &lt;sql&gt; &lt;/sql&gt;</h3><p>在 xml 配置我们可以通过 &lt;sql&gt; 完成语句的声明，通过 &lt; include&gt; 标签进行应用拼接</p><p>&lt;sql&gt; 抽离公共的 sql</p><p>&lt;include&gt; 引用公共的 sql</p><pre><code>&lt;!--
        声明一个公共的sql id=&quot;student_select_sql1&quot;
    --&gt;
    &lt;sql id=&quot;student_select_sql1&quot;&gt;
        SELECT id,name,age,sex,height,birthday,student_info as studentInfo from student_tb
    &lt;/sql&gt;

    &lt;!--
        # 根据id列表查询
 SELECT id,name,age,sex,height,birthday,student_info as studentInfo
			from student_tb WHERE id in (1,3,5,7,9)\

	      &lt;foreach collection=&quot;ids&quot; item=&quot;id&quot;&gt;
	            collection=&quot;ids&quot;  遍历集合的参数名
	            item=&quot;id&quot; 遍历集合中的每一个赋值给id
	             open=&quot;and id in (&quot; 拼接的开头
	             close=&quot;)&quot; 拼接的结尾
	             separator=&quot;,&quot; 每隔元素的分割
	                    #&#123;id&#125; 获取赋值的id变量

          &lt;include refid=&quot;student_select_sql1&quot;&gt;&lt;/include&gt; 引用公共的sql
    --&gt;
    &lt;select id=&quot;findStudentByIds&quot; resultType=&quot;com.qfedu.entity.Student&quot;&gt;
        &lt;include refid=&quot;student_select_sql1&quot;&gt;&lt;/include&gt;
        &lt;where&gt;
              
            &lt;if test=&quot;ids !=null and ids.size()&gt;0&quot;&gt;

                    &lt;foreach collection=&quot;ids&quot; item=&quot;id&quot; open=&quot;and id in (&quot; close=&quot;)&quot; separator=&quot;,&quot;&gt;
                            #&#123;id&#125;
                    &lt;/foreach&gt;

            &lt;/if&gt;

        &lt;/where&gt;

    &lt;/select&gt;

</code></pre><h2 id="68事务"><a class="anchor" href="#68事务">#</a> 6.8 事务</h2><p>事务：保证多条 sql 执行时，要么都成功，要么有一条失败，成功的要回滚</p><p>jdbc 开启事务</p><pre><code>1.开启事务 /关闭自动提交
2.执行sql 一系列sql
3.提交事务
	如果有异常需要回滚


以上事务的完成都是基于connection 链接

完成事务的本质是 ：多条sql都在同一个connection 链接中执行并提交事务 

</code></pre><p>事务四大特性：</p><p>原子性：：保证多条 sql 执行时，要么都成功，要么有一条失败，成功的要回滚</p><p>​ 不可再分</p><p>一致性： 事务执行前后，整体一致</p><p>​ 以转账为例 转账前后总金额没有变化</p><p>隔离性： 多个 sqlSession 之间互补影响</p><p>​ 一个事务不可以不去读取到另一个事务未提交数据</p><p>持久性： 掉电不丢失，重启之后数据还在</p><p>mybatis 开启事务</p><pre><code>   /**
     * 测试事务
     *  一次性删除两条数据，保证数据一致性
     *  @Transactional 标记在方法上，一般是在service层的方法 开启事务
     *                  本质：该方法调用的所有的dao方法 执行都使用同一个sqlSession(连接) 提交事务 回滚事务
     */
    @Test
    @Transactional
    public void deleteStudentByIdsTest()&#123;

        int num1 = studentDao.deleteStudentById(3);

        // 故意抛出异常
        int i = 1/0;

        int num2 = studentDao.deleteStudentById(5);


        System.out.println(&quot;num1 = &quot; + num1);
        System.out.println(&quot;num2 = &quot; + num2);

    &#125;
</code></pre><p>一般来说在 Service 层开启事务</p><pre><code>package com.qfedu.controller;

import com.qfedu.service.StudentService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.test.context.ActiveProfiles;
import org.springframework.web.bind.annotation.RequestMapping;

import java.util.HashMap;
import java.util.Map;

@Controller
public class StudentController &#123;


    @Autowired
    private StudentService studentService;

    @RequestMapping(&quot;/deleteStudentByIds&quot;)
    public Map&lt;String,Object&gt; deleteStudentByIds(int id1, int id2)&#123;


        studentService.deleteStudentByIds(id1, id2);

        Map&lt;String,Object&gt; map = new HashMap&lt;&gt;();

        map.put(&quot;code&quot;,1);
        map.put(&quot;msg&quot;,&quot;ok&quot;);

        return map;

    &#125;


&#125;

</code></pre><pre><code>package com.qfedu.service.impl;

import com.qfedu.dao.StudentDao;
import com.qfedu.service.StudentService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
public class StudentServiceImpl  implements StudentService &#123;

    @Autowired
    private StudentDao studentDao;

    @Transactional //开启事务  一般都在service层
    @Override
    public void deleteStudentByIds(int id1, int id2) &#123;

        int num1 = studentDao.deleteStudentById(id1);

        // 故意抛出异常
        int i = 1/0;

        int num2 = studentDao.deleteStudentById(id2);


    &#125;
&#125;

</code></pre><h2 id="68-缓存cache面试"><a class="anchor" href="#68-缓存cache面试">#</a> 6.8 缓存 (cache)【面试】</h2><p><strong>前提：mybatis 只要使用一级 二级缓存，对应映射的实体类都要实现序列化</strong></p><p><img data-src="springboot-01-class.assets/image-20230905095807550.png" alt="image-20230905095807550"></p><blockquote><p>缓存主要目的是为了 <code>提高查询效率</code> 。缓存其实就是一个内存空间，存储在程序的某个地方，存储数据.</p><p>mybatis 支持缓存的，且有两级缓存</p><ul><li>一级缓存</li><li>二级缓存</li></ul></blockquote><table><thead><tr><th>无缓存：用户在访问相同数据时，需要发起多次对数据库的直接访问，导致产生大量 IO、读写硬盘的操作，效率低下</th></tr></thead><tbody><tr><td><img data-src="https://qiushiju-tuchuang.oss-cn-hangzhou.aliyuncs.com/image/image-20230601165546620.png" alt="image-20230601165546620"></td></tr></tbody><tbody><tr><td>有缓存：首次访问时，查询数据库，将数据存储到缓存中；再次访问时，直接访问缓存，减少 IO、硬盘读写次数、提高效率</td></tr><tr><td>------------------------------------------------------------</td></tr><tr><td><img data-src="https://qiushiju-tuchuang.oss-cn-hangzhou.aliyuncs.com/image/image-20230601165610966.png" alt="image-20230601165610966"></td></tr></tbody></table><p><img data-src="springboot-01-class.assets/image-20230905095240935.png" alt="image-20230905095240935"></p><h3 id="681-一级缓存"><a class="anchor" href="#681-一级缓存">#</a> 6.8.1 一级缓存</h3><blockquote><p>MyBatis 的 <code>一级缓存是默认的</code> 。无需配置，自动实现.</p><p>默认的 <code>一级缓存是SqlSession（链接）级别</code> ，是指同一个 SqlSession 发起的多次查询同一条数据，会使用缓存.</p></blockquote><p><img data-src="springboot-01-class.assets/image-20230905095552145.png" alt="image-20230905095552145"></p><p>ps: Mybatis 内部存储缓存使用的是一个 HashMap 对象，key 为 hashCode + sqlId + sql 语句。而 value 值就是从查询出来映射生成的 java 对象。</p><h4 id="实战-4"><a class="anchor" href="#实战-4">#</a> 实战</h4><pre><code>
    /**
     * 测试一级缓存
     *      一级缓存基于sqlSession存储
     *      只要 发生增删改 缓存清空  避免数据出现混乱，缓存数据和数据库数据不一致问题
     */
    @Transactional // 只有开启事务才能让多个sql 共享同一个sqlSession ，共享一级缓存
    @Test
    public void  cacheTest1()&#123;

        System.out.println(&quot;第一次查询&quot;);
        Student student1 = studentDao.findStudentById(3);
        System.out.println(&quot;student1=&quot;+student1);

        System.out.println(&quot;第二次查询&quot;);
        Student student2 = studentDao.findStudentById(3);
        System.out.println(&quot;student2=&quot;+student2);

        System.out.println(&quot;执行 删除操作清除缓存&quot;);
        int num = studentDao.deleteStudentById(1000);
        System.out.println(&quot;num = &quot; + num);



        System.out.println(&quot;第三次查询&quot;);
        Student student3 = studentDao.findStudentById(3);
        System.out.println(&quot;student3=&quot;+student3);



    &#125;
</code></pre><p><img data-src="springboot-01-class.assets/image-20230905100542026.png" alt="image-20230905100542026"></p><p><img data-src="springboot-01-class.assets/image-20230905101046963.png" alt="image-20230905101046963"></p><h3 id="682-二级缓存"><a class="anchor" href="#682-二级缓存">#</a> 6.8.2 二级缓存</h3><blockquote><p><code>二级缓存是Mapper级别</code> ，比 SqlSession 级别范围更大.</p><ul><li><p>需要在 mapper 中设置 caceh 即可</p><figure class="highlight xml"><figcaption data-lang="XML"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>cache</span><span class="token punctuation">/></span></span></pre></td></tr></table></figure><ul><li>映射语句文件中的所有 select 语句的结果将会被缓存。</li><li>映射语句文件中的所有 insert、update 和 delete 语句会刷新缓存。</li></ul></li></ul></blockquote><h4 id="实战-5"><a class="anchor" href="#实战-5">#</a> 实战</h4><p>1. 开启二级缓存</p><pre><code>&lt;!-- 开启二级缓存
         type=&quot;&quot; 用于自定义二级缓存 
         size=&quot;1000&quot;表示当前mapper(命名空间下)最多存储 1000条数据
          flushInterval=&quot;60000&quot;  配置缓存有效期 没个60s 都会自动清空缓存一次
                                   尽可能保证数据的新鲜 保证一致性
           eviction=&quot;FIFO&quot;  缓存满了以后 淘汰策略
                            FIFO 最先缓存 最先删除
                            LRU 最近最少使用原则                        
           
    --&gt;
    &lt;cache size=&quot;1000&quot; flushInterval=&quot;60000&quot; eviction=&quot;LRU&quot; &gt;&lt;/cache&gt;
</code></pre><p>2. 配置实体类映射序列化</p><p><img data-src="springboot-01-class.assets/image-20230905105730179.png" alt="image-20230905105730179"></p><p>3. 测试二级缓存</p><p><img data-src="springboot-01-class.assets/image-20230905110652473.png" alt="image-20230905110652473"></p><p><img data-src="springboot-01-class.assets/image-20230905111021631.png" alt="image-20230905111021631"></p><pre><code>/**
 * 测试二级缓存
 *    二级缓存是基于mapper(namespace)的，多个sqlSession 也可以从二级缓存获取数据
 */
@Test
public void cacheTest2()&#123;

    // 1.查询   并且提交二级缓存（事务提交）
    System.out.println(&quot;----第一次查询&quot;);
    startTransaction();

    System.out.println(&quot;----第二次查询&quot;);
    Student student2 = studentDao.findStudentById(3);
    System.out.println(&quot;student2 = &quot; + student2);


    System.out.println(&quot;发生增删改清空 一级缓存，二级缓存&quot;);
    studentDao.deleteStudentById(1000);

    System.out.println(&quot;----第三次查询&quot;);
    Student student3 = studentDao.findStudentById(3);
    System.out.println(&quot;student3 = &quot; + student3);


&#125;


/*
        开启事务,方法结束，提交事务（将查询结果提交二级缓存）
 */
@Transactional
public void startTransaction()&#123;
    Student student1 =   studentDao.findStudentById(3);
    System.out.println(&quot;student1 = &quot; + student1);
&#125;
</code></pre><h3 id="683mybatis-一级缓存-二级缓存优先级"><a class="anchor" href="#683mybatis-一级缓存-二级缓存优先级">#</a> 6.8.3mybatis 一级缓存 二级缓存优先级</h3><p>一级缓存 ：基于 sqlSession</p><p>二级缓存：基于 mapper (namespace) 多个 sqlSession 可以从二级缓存获取数据</p><p>结论：二级缓存 优先于 一级缓存</p><p><img data-src="springboot-01-class.assets/image-20230905113609342.png" alt="image-20230905113609342"></p><h2 id="69-注解方式整合mybatis了解"><a class="anchor" href="#69-注解方式整合mybatis了解">#</a> 6.9 注解方式整合 Mybatis [了解]</h2><p>mybatis 的注解开发不是主流形式，只能开发最简的增删改查，复杂一些的一对一，一对多，就很难阅读</p><h3 id="691-mapper接口"><a class="anchor" href="#691-mapper接口">#</a> 6.9.1 Mapper 接口</h3><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">/**</span></pre></td></tr><tr><td data-num="2"></td><td><pre> * 将 dao 接口加入到 spring 容器两种方式</pre></td></tr><tr><td data-num="3"></td><td><pre> *    1. 在 dao 接口上加入 @Mapper 注解</pre></td></tr><tr><td data-num="4"></td><td><pre> *    2. 在启动类上加入 @MapperScan ("com.qfedu.dao") 注解</pre></td></tr><tr><td data-num="5"></td><td><pre> */</pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token annotation punctuation">@Mapper</span> <span class="token comment">// 将 mybatis 生成 dao 接口的实现类加入容器中</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">StudentDao</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token keyword">int</span>  <span class="token function">deleteStudentById</span><span class="token punctuation">(</span><span class="token keyword">int</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token class-name">Student</span> <span class="token function">findStudentById</span><span class="token punctuation">(</span><span class="token keyword">int</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id="692-添加mybatis注解"><a class="anchor" href="#692-添加mybatis注解">#</a> 6.9.2 添加 Mybatis 注解</h3><blockquote><p>针对增删改查：@Insert，@Delete，@Update，@Select</p><p>还是需要在启动类中添加 @MapperScan 注解</p></blockquote><pre><code>package com.qfedu.dao;

import com.qfedu.entity.Student;
import org.apache.ibatis.annotations.*;

import java.util.List;

/**
 * mybatis  基于注解的开发
 *  @Insert，@Delete，@Update，@Select
 */
@CacheNamespace // 注解开启二级缓存
public interface StudentDao2 &#123;


    @Select(value = &quot;  SELECT id,name,age,sex,height,birthday,student_info from student_tb &quot;)
    List&lt;Student&gt; findAllStudent();


    /**
     * 根据id 查询
     * @param id
     * @return
     */
    @Select(&quot; SELECT id,name,age,sex,height,birthday ,student_info from student_tb where id = #&#123;id&#125;&quot;)
    Student findStudentById(int id);


    /**
     * 插入学生
     * @param student
     * @return
     */
    @Insert(value = &quot;INSERT INTO  student_tb (name,age,sex,height,birthday) VALUES (#&#123;name&#125;,#&#123;age&#125;,#&#123;sex&#125;,#&#123;height&#125;,#&#123;birthday&#125; )&quot;)
    int addStudent(Student student);


    /**
     * 更新学生
     * @param student
     * @return
     */
    @Update(&quot;UPDATE student_tb set name = #&#123;name&#125; ,age = #&#123;age&#125;,sex=#&#123;sex&#125;,height = #&#123;height&#125; ,birthday = #&#123;birthday&#125; WHERE id = #&#123;id&#125;&quot;)
    int updateStudentById(Student student);

    /**
     * 根据id 删除
     * @param id
     * @return
     */
    @Delete(&quot; delete from student_tb WHERE id = #&#123;id&#125;&quot;)
    int deleteStudentById(int id);


&#125;

</code></pre><p>测试</p><pre><code>
    @Autowired
    private StudentDao2 studentDao2;
    /**
     * mybatis 基于注解开发
     */
    @Test
    public void  annotationTest()&#123;

        List&lt;Student&gt; allStudent = studentDao2.findAllStudent();
        System.out.println(&quot;allStudent = &quot; + allStudent);


        Student student = studentDao2.findStudentById(10);
        System.out.println(&quot;student = &quot; + student);


        Student student2 = new Student();

        student2.setName(&quot;蓝猫&quot;);
        student2.setSex(&quot;M&quot;);
        student2.setHeight(180);
        student2.setBirthday(new Date());
        student2.setAge(1);

        // 增加
        int num2 = studentDao2.addStudent(student2);
        System.out.println(&quot;num2 = &quot; + num2);

        // 删除
        int num3 = studentDao2.deleteStudentById(10);
        System.out.println(&quot;num3 = &quot; + num3);


    &#125;

</code></pre><h2 id="610pagehelper使用"><a class="anchor" href="#610pagehelper使用">#</a> 6.10pagehelper 使用</h2><p>select * from student_tb limit (pageIndex-1)*pageSize,pageSize</p><p>1. 引入依赖</p><pre><code>        &lt;!--pagehelper--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;
            &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt;
            &lt;version&gt;1.2.9&lt;/version&gt;
        &lt;/dependency&gt;
</code></pre><p>2. 配置</p><pre><code>#pagehelper配置
pagehelper.helper-dialect=mysql
pagehelper.page-size-zero=true
</code></pre><p>3. 使用 pagehelper</p><p>StudentService</p><pre><code>    /**
     * 分页查询
     * @param pageIndex
     * @param pageSize
     * @return
     */
    List&lt;Student&gt; getAllStudentByPage(int pageIndex, int pageSize);

</code></pre><p>对应实现 StudentServiceImpl</p><pre><code>@Override
    public List&lt;Student&gt; getAllStudentByPage(int pageIndex, int pageSize) &#123;

        // 使用分页 本质就是在后续查询语句之后 追加  limit (pageIndex-1)*pageSize,pageSize
        PageHelper.startPage(pageIndex,pageSize);

        // 执行sql    SELECT id,name,age,sex,height,birthday,student_info as studentInfo from student_tb  limit (pageIndex-1)*pageSize,pageSize
        // 查询所有 就会自动配置分页  limit (pageIndex-1)*pageSize,pageSize
        List&lt;Student&gt; allStudent = studentDao.findAllStudent();


        // pageInfo 封装所有的分页信息
        // 获取总页数 总行数
        PageInfo&lt;Student&gt; pageInfo = new PageInfo&lt;&gt;(allStudent);

        System.out.println(&quot;总行数 pageInfo.getTotal() = &quot; + pageInfo.getTotal());
        System.out.println(&quot;总页数 pageInfo.getPages() = &quot; + pageInfo.getPages());
        System.out.println(&quot;每页数量 pageInfo.ge = &quot; + pageInfo.getSize());


        return allStudent;
    &#125;
</code></pre><p>处理器方法</p><pre><code>
    /**
     * url  /getAllStudentByPage?pageIndex=1&amp;pageSize=10
     * @param pageIndex
     * @param pageSize
     * @return
     */
    @RequestMapping(&quot;/getAllStudentByPage&quot;)
    @ResponseBody
    public List&lt;Student&gt; getAllStudentByPage(int pageIndex,int pageSize)&#123;


        // 分页查询
        List&lt;Student&gt; allStudentByPage = studentService.getAllStudentByPage(pageIndex, pageSize);

        return allStudentByPage;

    &#125;
</code></pre><p>练习：按照性别 姓名模糊查询 分页实现</p><h1 id="七-jquery-ajax"><a class="anchor" href="#七-jquery-ajax">#</a> 七、jQuery AJAX</h1><hr><h2 id="71-jquery-ajax简介"><a class="anchor" href="#71-jquery-ajax简介">#</a> 7.1 jQuery AJAX 简介</h2><blockquote><ul><li><p>AJAX = 异步 JavaScript 和 XML（Asynchronous JavaScript and XML）。</p></li><li><p>简短地说，在不重载整个网页的情况下，AJAX 通过后台加载数据，并在网页上进行显示。</p></li><li><p>使用 AJAX 的应用程序案例：谷歌地图、腾讯微博、优酷视频、人人网等等。</p></li></ul></blockquote><p><img data-src="springboot-01-class.assets/image-20230905160808687.png" alt="image-20230905160808687"></p><h4 id="实战-6"><a class="anchor" href="#实战-6">#</a> 实战</h4><p>1. 修改 login 处理方法 返回 json 数据</p><pre><code>package com.qfedu.controller;


import com.qfedu.entity.Admin;
import com.qfedu.entity.R;
import com.qfedu.service.AdminService;
import org.apache.catalina.User;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;

import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.io.PrintWriter;

/**
 * admin 管理员用户相关
 */
@Controller
public class AdminController &#123;

    @Autowired
    private AdminService adminService;

    /**
     * url  /login?username=liu&amp;password=123456
     * 登录
     */
    @RequestMapping(&quot;/login&quot;)
    @ResponseBody
    public R&lt;Admin&gt; login(String username, String password) &#123;


        System.out.println(&quot;username = &quot; + username);
        System.out.println(&quot;password = &quot; + password);

        Admin admin = adminService.login(username, password);

        R&lt;Admin&gt; r = new R&lt;&gt;();
        if (admin!=null)&#123; // 登录成功

            r.setCode(1);
            r.setMsg(&quot;success&quot;);
            r.setData(admin);
        &#125;else &#123;
            r.setCode(0);
            r.setMsg(&quot;用户名 或者 密码错误&quot;);
        &#125;

        return r;
    &#125;


&#125;

</code></pre><p><img data-src="springboot-01-class.assets/image-20230905162032510.png" alt="image-20230905162032510"></p><p>2. 修改前端登录界面</p><p>在 static 目录导入 jquery</p><p><img data-src="springboot-01-class.assets/image-20230905163054755.png" alt="image-20230905163054755"></p><p>login.html 使用 get 发起 ajax 请求</p><pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
    &lt;!-- 引入jquery--&gt;
    &lt;script src=&quot;js/jquery-3.4.1.min.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;登录&lt;/h1&gt;
&lt;!--

--&gt;
&lt;form  enctype=&quot;application/x-www-form-urlencoded&quot;&gt;
    &lt;!--  name=&quot;username&quot;表单提交时 username 就是key value就是input的输入值--&gt;
    username:&lt;input type=&quot;text&quot; name=&quot;username&quot; id=&quot;username&quot;&gt;&lt;br&gt;
    password:&lt;input type=&quot;password&quot; name=&quot;password&quot; id=&quot;password&quot;&gt;&lt;br&gt;
    &lt;input type=&quot;button&quot; value=&quot;登录&quot;  onclick=&quot;login()&quot;&gt;
&lt;/form&gt;

&lt;div id=&quot;msg&quot;&gt;&lt;/div&gt;

&lt;!-- js 代码块--&gt;
&lt;script type=&quot;text/javascript&quot;&gt;

    function login()&#123;

        // 获取input 输入框的值
        var username = $(&quot;#username&quot;).val();
        var password = $(&quot;#password&quot;).val();

        //打印
        console.log(&quot;username:&quot;+username+&quot;---password:&quot;+password);

        // $.get 通过jquery 发起get 请求
        //  &quot;/login&quot; 请求的地址 url
        //   &#123;username:username,password:password&#125; 提交的数据 js对象，后端接收的就是键值对
        //   function (data) &#123;   &#125; 请求响应成功的回调函数  response就是处理器方法返回的json数据--&gt;js对象
        //   &quot;json&quot;  将后端处理方法返回的json 直接转化js 对象
        $.get(&quot;/login&quot;,&#123;username:username,password:password&#125;,function (response) &#123;// 处理服务正常返回的数据
            alert(&quot;服务端正常数据&quot;);
            // response  == 响应的R对象
            alert(&quot;响应的数据：&quot;+JSON.stringify(response))

            //得到后端响应数据

            if (response.code == 1)&#123;
                // 1.将数据异步展示到当前界面
                // var admin = response.data;
                // $(&quot;#msg&quot;).html(&quot;欢迎&quot;+admin.username+&quot;登录&quot;);

                // 2.跳转欢迎页
                window.location.href=&quot;/welcome.html&quot;;
            &#125;else &#123;
                alert(&quot;登录失败&quot;)
            &#125;





        &#125;,&quot;json&quot;).fail(function () &#123;
            alert(&quot;服务端错误&quot;);
        &#125;);

    &#125;


&lt;/script&gt;




&lt;/body&gt;
&lt;/html&gt;
</code></pre><p><img data-src="springboot-01-class.assets/image-20230905164059828.png" alt="image-20230905164059828"></p><p>3. 测试</p><p><img data-src="springboot-01-class.assets/image-20230905165048842.png" alt="image-20230905165048842"></p><p><img data-src="springboot-01-class.assets/image-20230905165109243.png" alt="image-20230905165109243"></p><h2 id="72-get和post方法"><a class="anchor" href="#72-get和post方法">#</a> 7.2 get 和 post 方法</h2><p>get 方式</p><pre><code>  // $.get 通过jquery 发起get 请求
        //  &quot;/login&quot; 请求的地址 url
        //   &#123;username:username,password:password&#125; 提交的数据 js对象，后端接收的就是键值对
        //   function (data) &#123;   &#125; 请求响应成功的回调函数  response就是处理器方法返回的json数据--&gt;js对象
        //   &quot;json&quot;  将后端处理方法返回的json 直接转化js 对象
        $.get(&quot;/login&quot;,&#123;username:username,password:password&#125;,function (response) &#123;// 处理服务正常返回的数据
            alert(&quot;服务端正常数据&quot;);
            // response  == 响应的R对象
            alert(&quot;响应的数据：&quot;+JSON.stringify(response))

            //得到后端响应数据

            if (response.code == 1)&#123;
                // 1.将数据异步展示到当前界面
                // var admin = response.data;
                // $(&quot;#msg&quot;).html(&quot;欢迎&quot;+admin.username+&quot;登录&quot;);

                // 2.跳转欢迎页
                window.location.href=&quot;/welcome.html&quot;;
            &#125;else &#123;
                alert(&quot;登录失败&quot;)
            &#125;
        &#125;,&quot;json&quot;).fail(function () &#123;
            alert(&quot;服务端错误&quot;);
        &#125;);
</code></pre><p>post</p><pre><code>        // post请求方式   和get请求方式没有区别
        $.post(&quot;/login&quot;,&#123;username:username,password:password&#125;,function (response) &#123;// 处理服务正常返回的数据
            alert(&quot;服务端正常数据&quot;);
            // response  == 响应的R对象
            alert(&quot;响应的数据：&quot;+JSON.stringify(response))

            //得到后端响应数据

            if (response.code == 1)&#123;
                // 1.将数据异步展示到当前界面
                // var admin = response.data;
                // $(&quot;#msg&quot;).html(&quot;欢迎&quot;+admin.username+&quot;登录&quot;);

                // 2.跳转欢迎页
                window.location.href=&quot;/welcome.html&quot;;
            &#125;else &#123;
                alert(&quot;登录失败&quot;)
            &#125;
        &#125;,&quot;json&quot;).fail(function () &#123;
            alert(&quot;服务端错误&quot;);
        &#125;);
</code></pre><p>综合方式 $.ajax</p><pre><code> // 综合请求方式  可以get 也可以 post
        $.ajax(&#123;
            url:&quot;/login&quot;,
            type:&quot;get&quot;,  // 请求方式 get  post
            // data:&#123;username:username,password:password&#125;, // 提交的数据
            data:$(&quot;#form1&quot;).serialize(),// $(&quot;#form1&quot;).serialize() 获取表单中所有input的数据值 == username=liu&amp;passwrod=123456
            success:function (response) &#123;  //服务器成功返回的数据
                    alert(&quot;服务端正常数据&quot;);
                    // response  == 响应的R对象
                    alert(&quot;响应的数据：&quot;+JSON.stringify(response))

                    //得到后端响应数据

                    if (response.code == 1)&#123;
                        // 1.将数据异步展示到当前界面
                        // var admin = response.data;
                        // $(&quot;#msg&quot;).html(&quot;欢迎&quot;+admin.username+&quot;登录&quot;);

                        // 2.跳转欢迎页
                        window.location.href=&quot;/welcome.html&quot;;
                    &#125;else &#123;
                        alert(&quot;登录失败&quot;)
                    &#125;
            &#125;,
            error:function (data) &#123;// 服务器返回失败的数据
                alert(data);
            &#125;,
            //ajax 会将服务器返回的json字符串-----》js对象
            dataType:&quot;json&quot;
        &#125;);
</code></pre><p><img data-src="springboot-01-class.assets/image-20230906095531799.png" alt="image-20230906095531799"></p><h1 id="八-springboot常用配置重点"><a class="anchor" href="#八-springboot常用配置重点">#</a> 八、SpringBoot 常用配置【 <code>重点</code> 】</h1><h2 id="81-springboot的配置文件格式"><a class="anchor" href="#81-springboot的配置文件格式">#</a> 8.1 SpringBoot 的配置文件格式</h2><p>SpringBoot 的配置文件 （常用两种）</p><ul><li>application.properties</li><li>application.yaml /application.yml</li></ul><blockquote><p>SpringBoot 的配置文件， <code>文件名必须是application</code> , 格式支持 <code>properties</code> 和 <code>yml</code> 。</p></blockquote><p>application.yaml 语法</p><pre><code>   1. yml文件，会根据换行和缩进帮助咱们管理配置文件所在位置

  2. yml文件，相比properties更轻量级一些

  3. K: V 表示一对键值对(冒号: 后一定有一个空格)

  4. 以空格的缩进来控制层级关系;只要是左对齐的都是属于一个层级的数据

  5. 属性和值大小写敏感.
</code></pre><p>application.properties</p><pre><code>server.port=8080
</code></pre><p>application.yaml</p><p>原来的 application.properties . 语法使用 ： + 换行 替代， key 和 value 之间使用：空格 进行分割</p><pre><code>server:
	port: 8080

</code></pre><p>示例 application.yaml</p><pre><code>

# 如果application.properties  和 application.yaml 都配置了同一属性，
#  application.properties中属性优先级高
server:
  port: 8090


spring:
  datasource:
    url: jdbc:mysql://localhost:3306/java2310_1?serverTimezone=Asia/Shanghai&amp;useSSL=false
    username: root
    password: 123456
    type: com.alibaba.druid.pool.DruidDataSource
    druid:
      initial-size: 5
      max-active: 10
      min-idle: 3
</code></pre><h4 id="注意"><a class="anchor" href="#注意">#</a> 注意：</h4><p>1. 如果 application.properties 和 application.yaml 都配置了同一属性，application.properties 中属性优先级高</p><p>2.application.yaml key 和 value 之间 必有 :</p><h2 id="82-多环境配置"><a class="anchor" href="#82-多环境配置">#</a> 8.2 多环境配置</h2><blockquote><p>实际开发中，有三种环境：</p><p>1. 开发环境 - 程序员日常开发所需 dev</p><p>2. 测试环境 - 项目的集成测试 test</p><p>3. 生产环境 - 最终项目部署的环境，真实环境 pro</p></blockquote><p>SpringBoot 支持多环境的配置。只需要根据环境需要，编写多个配置文件，通过配置属性选择使用哪个环境</p><p>使用步骤：</p><p>1. 多环境的配置文件命名：application - 环境名.yml application - 环境名.properties</p><p>​ application-dev.yaml application-dev.properties 开发环境</p><p>​ application-test.yaml application-test.properties 测试环境</p><p>​ application-prod.yaml application-prod.properties 生产环境</p><p>2. 在总文件 application.yml 中通过属性：spring.profiles.active 环境名</p><p><img data-src="springboot-01-class.assets/image-20230906112146410.png" alt="image-20230906112146410"></p><h3 id="在默认配置文件激活多环境配置"><a class="anchor" href="#在默认配置文件激活多环境配置">#</a> 在默认配置文件激活多环境配置</h3><pre><code>#  dev 激活开发环境配置
#  test 激活测试环境配置
#   prod 激活生产环境配置
spring.profiles.active=prod

</code></pre><p><img data-src="springboot-01-class.assets/image-20230906112536984.png" alt="image-20230906112536984"></p><h2 id="83-获取配置文件信息"><a class="anchor" href="#83-获取配置文件信息">#</a> 8.3 获取配置文件信息</h2><blockquote><p>场景: ....</p><p>解释：将 yml 配置的值，赋值给对应的类</p><p>方案:</p><ul><li><p>方案一: @ConfigurationProperties 批量读取配置文件的内容</p></li><li><p>方案二: @Value 单个读取配置文件</p></li></ul></blockquote><p>1. 在默认文件配置</p><p>application.properties 配置</p><pre><code>aliyun.accessKey=ATYSBD23B1N44
aliyun.accessSecret=123456
</code></pre><p>application.yaml 配置</p><pre><code># 阿里云的 key 和 秘钥
aliyun:
  accessKey: ATYSBD23B1N44
  accessSecret: 123456
</code></pre><p>2. 创建一个实体类 封装阿里云相关参数</p><p>方式一批量读取</p><pre><code>package com.qfedu.entity;


import lombok.Data;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.stereotype.Component;

import java.io.Serializable;

/**
 * 加入到容器中的bean 初始化属性的两种方式
 *    1.批量初始化
 *          @ConfigurationProperties(prefix = &quot;aliyun&quot;)
 *          作用：批量读取配置文件中以 aliyun开头的属性，配置到对应创建bean的属性中
 *
 *    2. 单个读取属性
 */
@ConfigurationProperties(prefix = &quot;aliyun&quot;)
@Component // 创建一个该类型的bean 加入到容器
@Data
public class AliYunProperties  implements Serializable &#123;



    private String accessKey;

    private String accessSecret;

&#125;

</code></pre><p>方式二 单个读取配置文件的值</p><pre><code>package com.qfedu.entity;


import lombok.Data;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.stereotype.Component;

import java.io.Serializable;

/**
 * 加入到容器中的bean 初始化属性的两种方式
 *    1.批量初始化
 *          @ConfigurationProperties(prefix = &quot;aliyun&quot;)
 *          作用：批量读取配置文件中以 aliyun开头的属性，配置到对应创建bean的属性中
 *
 *    2. 单个读取属性
 */
//@ConfigurationProperties(prefix = &quot;aliyun&quot;)
@Component // 创建一个该类型的bean 加入到容器
@Data
public class AliYunProperties  implements Serializable &#123;


    // 访问阿里云的key
    @Value(value = &quot;$&#123;aliyun.accessKey&#125;&quot;) // 单个读取配置文件aliyun.accessKey对应值赋值给当前属性 accessKey
    private String accessKey;

    // 访问阿里云 秘钥
    @Value(&quot;$&#123;aliyun.accessSecret&#125;&quot;)
    private String accessSecret;

&#125;

</code></pre><p>3. 测试</p><pre><code>
    @Autowired
    private AliYunProperties aliYunProperties;

    /**
     * 通过阿里云配置类 读取配置文件的属性
     * @return
     */
    @RequestMapping(&quot;/getAliYunProperties&quot;)
    @ResponseBody
    public R&lt;AliYunProperties&gt; getAliYunProperties()&#123;

          R&lt;AliYunProperties&gt; r = new R&lt;&gt;();

          r.setCode(1);
          r.setMsg(&quot;success&quot;);
          r.setData(aliYunProperties);

          return r;
    &#125;
</code></pre><p><img data-src="springboot-01-class.assets/image-20230906113909279.png" alt="image-20230906113909279"></p><h2 id="84其他注解"><a class="anchor" href="#84其他注解">#</a> 8.4 其他注解</h2><h4 id="生成bean注解"><a class="anchor" href="#生成bean注解">#</a> 生成 Bean 注解</h4><p>@Controler @Service @Respository @Component</p><pre><code>/**
 * @Controller 生成bean 加入到容器 ，默认名字（类名首字母小写 testController）
 * @Controller(value = &quot;testBean&quot;)  加入容器指定名字（id）testBean  
 * 
 *   凡是加入到容器中的Bean 都存在ConcurrentHashMap 中 key 就是bean名字（id）
 *                                                 value 就是容器创建对象的引用地址
 * 
 */
@Controller(value = &quot;testBean&quot;)
public class TestController &#123;

&#125;
</code></pre><p>@Bean 也可以生成注解 ，但是必须配合 @Configuration 使用</p><pre><code>package com.qfedu.config;

import com.qfedu.entity.User;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

/**
 * 创建一个配置类
 *  1使用@Bean标记在方法生 创建 明bean
 *  2.可以维护bean之间的依赖关系（后边会遇到）
 */
@Configuration
public class MyConfig &#123;

    /**
     *  @Bean 就是给了我们一个后门，可以根据程序员的业务逻辑定制bean，最终由容器调用此方法创建 持有bean
     *
     *  @Bean 默认的名字（id）为 方法名getUser1
     *
     *   @Bean(value = &quot;user1&quot;) 创建一个bean 名字（id）就是user1,可以通过名字获取bean
     *
     * @return
     */
    @Bean(value = &quot;user1&quot;) // 表示容器启动时，会调用此方法得到一个bean，并且加入到容器
    public User getUser1()&#123;
        User user = new User();

        user.setId(100);
        user.setUsername(&quot;xiaoming&quot;);
        user.setPassword(&quot;123456&quot;);

        return user;
    &#125;


&#125;

</code></pre><p>从容器中获取 bean</p><pre><code>   @Autowired
    private User user;

    @RequestMapping(&quot;/getUser&quot;)
    @ResponseBody
    public User getUser()&#123;

        System.out.println(&quot;获取user&quot;);

        return user;
    &#125;
</code></pre><p>测试</p><p><img data-src="springboot-01-class.assets/image-20230906144839666.png" alt="image-20230906144839666"></p><h4 id="如何识别多个同类型的bean-qualifier"><a class="anchor" href="#如何识别多个同类型的bean-qualifier">#</a> 如何识别多个同类型的 Bean @Qualifier</h4><p>1. 容器中放入多个 User</p><pre><code>package com.qfedu.config;

import com.qfedu.entity.User;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

/**
 * 创建一个配置类
 *  1使用@Bean标记在方法生 创建 明bean
 *  2.可以维护bean之间的依赖关系（后边会遇到）
 */
@Configuration
public class MyConfig &#123;

    /**
     *  @Bean 就是给了我们一个后门，可以根据程序员的业务逻辑定制bean，最终由容器调用此方法创建 持有bean
     *
     *  @Bean 默认的名字（id）为 方法名getUser1
     *
     *   @Bean(value = &quot;user1&quot;) 创建一个bean 名字（id）就是user1,可以通过名字获取bean
     *
     * @return
     */
    @Bean(value = &quot;user1&quot;) // 表示容器启动时，会调用此方法得到一个bean，并且加入到容器
    public User getUser1()&#123;
        User user = new User();

        user.setId(100);
        user.setUsername(&quot;xiaoming&quot;);
        user.setPassword(&quot;123456&quot;);

        return user;
    &#125;



    @Bean(value = &quot;user2&quot;) // 表示容器启动时，会调用此方法得到一个bean，并且加入到容器
    public User getUser2()&#123;
        User user = new User();

        user.setId(100);
        user.setUsername(&quot;xiaoming&quot;);
        user.setPassword(&quot;123456&quot;);

        return user;
    &#125;




&#125;

</code></pre><p><img data-src="springboot-01-class.assets/image-20230906145121272.png" alt="image-20230906145121272"></p><p>2. 从容器中获取 Bean</p><pre><code>
    /**
     *  @Autowired 从容器中获取同类型的Bean 注入进来
     *      查找类型的逻辑：
     *              1.根据类型从容器中获取bean,找到一个bean，直接注入
     *                                      找到多个bean,无法区分
     *                           2.如果无法区分，就会将属性名作为名字（id）从容器找到对应的 bean ，如果找到 则注入
     *                                      3.如果找不到 ,就要使用注解   @Qualifier(value = &quot;user1&quot;)
     *                                              明示当前属性需要从容器中获取那个bean
     *
     */
    @Autowired
    @Qualifier(value = &quot;user1&quot;)
    private User user;

    @RequestMapping(&quot;/getUser&quot;)
    @ResponseBody
    public User getUser()&#123;

        System.out.println(&quot;获取user&quot;);

        return user;
    &#125;
</code></pre><h4 id="restcontroller"><a class="anchor" href="#restcontroller">#</a> @RestController</h4><p>@RestController 也是标记在类上，等价于 @ResponsBody +@Controller</p><p>仅适用于：当前控制类下所有的处理器方法 都返回 json 数据</p><p><img data-src="springboot-01-class.assets/image-20230906155036573.png" alt="image-20230906155036573"></p><pre><code>package com.qfedu.controller;


import com.qfedu.entity.R;
import com.qfedu.entity.Student;
import com.qfedu.service.StudentService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.bind.annotation.RestController;

import java.util.List;

/**
 * @RestController 本质 == @Controller + @ResponseBody
 *          作用：1.加入到容器，生成Bean
 *               2.配置当前控制类下所有的处理器方法 都返回对象转json  处理器方法可以省略  @ResponseBody
 */
@RestController
//@Controller
public class StudentController &#123;


    @Autowired
    private StudentService studentService;

    /**
     * 根据id查询
     * @param id
     * @return
     */
    @RequestMapping(&quot;/findStudentById&quot;)
//    @ResponseBody
    public R&lt;Student&gt; findStudentById(int id)&#123;

        Student student = studentService.findStudentById(id);

        R&lt;Student&gt; r = new R&lt;&gt;();

        r.setCode(1);
        r.setMsg(&quot;success&quot;);
        r.setData(student);

        return r;
    &#125;


    /**
     * 查询所有学生
     * @return
     */
    @RequestMapping(&quot;/findAllStudent&quot;)
//    @ResponseBody
    public R&lt;List&lt;Student&gt;&gt; findAllStudent()&#123;

        List&lt;Student&gt; allStudent = studentService.findAllStudent();

        R&lt;List&lt;Student&gt;&gt; r = new R&lt;&gt;();

        r.setCode(1);
        r.setMsg(&quot;success&quot;);
        r.setData(allStudent);

        return r;
    &#125;


&#125;

</code></pre><h2 id="85debug"><a class="anchor" href="#85debug">#</a> 8.5debug</h2><p><img data-src="springboot-01-class.assets/image-20230906161002553.png" alt="image-20230906161002553"></p><h3 id="通过控制台报错分析"><a class="anchor" href="#通过控制台报错分析">#</a> 通过控制台报错分析</h3><p><img data-src="springboot-01-class.assets/image-20230906161402935.png" alt="image-20230906161402935"></p><p><img data-src="springboot-01-class.assets/image-20230906161703972.png" alt="image-20230906161703972"></p><p><img data-src="springboot-01-class.assets/image-20230906161916482.png" alt="image-20230906161916482"></p><p><img data-src="springboot-01-class.assets/image-20230906162111703.png" alt="image-20230906162111703"></p><p><img data-src="springboot-01-class.assets/image-20230906162200102.png" alt="image-20230906162200102"></p><p>结合错误原因 和 定位自己代表报错位置</p><p><img data-src="springboot-01-class.assets/image-20230906162249029.png" alt="image-20230906162249029"></p><h3 id="使用断点调试-完成debug"><a class="anchor" href="#使用断点调试-完成debug">#</a> 使用断点调试 完成 debug</h3><h4 id="1前端debug"><a class="anchor" href="#1前端debug">#</a> 1. 前端 debug</h4><p><img data-src="springboot-01-class.assets/image-20230906162645733.png" alt="image-20230906162645733"></p><p><img data-src="springboot-01-class.assets/image-20230906162901056.png" alt="image-20230906162901056"></p><p><img data-src="springboot-01-class.assets/image-20230906163014733.png" alt="image-20230906163014733"></p><h4 id="2后端-idea-debug"><a class="anchor" href="#2后端-idea-debug">#</a> 2. 后端 idea debug</h4><p><img data-src="springboot-01-class.assets/image-20230906163123332.png" alt="image-20230906163123332"></p><p><img data-src="springboot-01-class.assets/image-20230906163411616.png" alt="image-20230906163411616"></p><p><img data-src="springboot-01-class.assets/image-20230906163638958.png" alt="image-20230906163638958"></p><p><img data-src="springboot-01-class.assets/image-20230906163756101.png" alt="image-20230906163756101"></p><h4 id="3如果-前后debug-无法明确问题"><a class="anchor" href="#3如果-前后debug-无法明确问题">#</a> 3. 如果 前后 debug 无法明确问题 ？</h4><p>直接使用浏览器 或者 postman 发起请求，单独测试接口 ，确认是否后台接口报错 （缩小 bug 错误范围 ）</p><p><img data-src="springboot-01-class.assets/image-20230906164305368.png" alt="image-20230906164305368"></p><p><img data-src="springboot-01-class.assets/image-20230906164324689.png" alt="image-20230906164324689"></p><h4 id="4以上办法都不行"><a class="anchor" href="#4以上办法都不行">#</a> 4. 以上办法都不行？</h4><p>回到解放前：可以运行实例代码，或者将实例代码拷贝过来 对比测试</p><h2 id="86-文件上传会用既可"><a class="anchor" href="#86-文件上传会用既可">#</a> 8.6 文件上传（会用既可）</h2><p>图片 / 文件上传</p><p>上传 tomcat 服务器 / 上传本地磁盘</p><p>1. 引入文件上传依赖</p><pre><code>    &lt;!-- 使用工具类 --&gt;
		&lt;dependency&gt;
            &lt;groupId&gt;commons-fileupload&lt;/groupId&gt;
            &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt;
            &lt;version&gt;1.3.2&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;commons-io&lt;/groupId&gt;
            &lt;artifactId&gt;commons-io&lt;/artifactId&gt;
            &lt;version&gt;2.4&lt;/version&gt;
        &lt;/dependency&gt;
</code></pre><p>2. 在 static 创建 file.html 使用 form 表单提交文件</p><pre><code>&lt;!--
    上传文件只可以是post 方式
    
    上传文件配置格式 enctype=&quot;multipart/form-data&quot; 将文件以二级制流传输
--&gt;
&lt;form action=&quot;/uploadImg&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;
    图片：&lt;input type=&quot;file&quot; name=&quot;img&quot;&gt;&lt;br&gt;
    &lt;input type=&quot;submit&quot; value=&quot;上传&quot;&gt;
&lt;/form&gt;

</code></pre><p>3. 接收提交的文件</p><pre><code>package com.qfedu.controller;

import com.qfedu.entity.R;
import org.apache.commons.io.FileUtils;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.multipart.MultipartFile;

import javax.servlet.http.HttpServletRequest;
import java.io.File;
import java.io.IOException;
import java.util.Random;
import java.util.UUID;

/**
 * 文件相关controler
 */
@Controller
public class FileConTroller &#123;


    /**
     * 用于接收图片文件   MultipartFile img 对应form表单提交的name
     *                   图片：&lt;input type=&quot;file&quot; name=&quot;img&quot;&gt;&lt;br&gt;
     *
     * @param img
     * @return
     */
    @RequestMapping(&quot;/uploadFile&quot;)
    public String uploadFile(MultipartFile img, HttpServletRequest request) throws IOException &#123;

        //1.获取一个相对路径
        // tomcat 真正加载资源的路径
        String realPath = request.getServletContext().getRealPath(&quot;/upload&quot;);

        System.out.println(&quot;realPath = &quot; + realPath);

        // 存储文件的父路径
        File file = new File(realPath);

        // 2.如果路径不存在则创建
        if (!file.exists())&#123;
            file.mkdirs();
        &#125;

        // 3.得到文件的原始名字
        String originalFilename = img.getOriginalFilename();

        // 4.对文件重命名  防止文件被覆盖
        String newFileName = UUID.randomUUID().toString() +&quot;-&quot;+originalFilename;
        System.out.println(&quot;newFileName = &quot; + newFileName);

        // 5.将接收到的文件流写入到 到文件中
        //此时可以通过路径
        // http://localhost:8080/upload/132dcfd0-c1b2-495d-a506-eb19e03b00e2-8900.jpg
        FileUtils.writeByteArrayToFile(new File(file,newFileName),img.getBytes());

        //6.跳转界面
        return &quot;redirect:/success.html&quot;;

    &#125;


&#125;

</code></pre><p><img data-src="springboot-01-class.assets/image-20230906174812725.png" alt="image-20230906174812725"></p><p><img data-src="springboot-01-class.assets/image-20230906174844973.png" alt="image-20230906174844973"></p><h2 id="87-热加载了解"><a class="anchor" href="#87-热加载了解">#</a> 8.7 热加载（了解）</h2><p>可以配置 idea 中代码，修改以后自动编译部署（必须在 debug 模式）</p><p>不建议搭建使用，因为有时候不生效</p><h3 id="1导入依赖"><a class="anchor" href="#1导入依赖">#</a> 1. 导入依赖</h3><figure class="highlight xml"><figcaption data-lang="XML"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-devtools<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>optional</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>optional</span><span class="token punctuation">></span></span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></pre></td></tr></table></figure><h3 id="2配置settings配置"><a class="anchor" href="#2配置settings配置">#</a> 2. 配置 settings 配置</h3><p><img data-src="springboot-01-class.assets/image-20230906174133638.png" alt="image-20230906174133638"></p><p><img data-src="springboot-01-class.assets/image-20230906174203842.png" alt="image-20230906174203842"></p><h3 id="3使用-以-debug-模式启动-修改代码触发-热更新"><a class="anchor" href="#3使用-以-debug-模式启动-修改代码触发-热更新">#</a> 3. 使用 以 debug 模式启动， 修改代码触发 热更新</h3><pre><code>
    @RequestMapping(&quot;/test1&quot;)
    @ResponseBody
    public R&lt;String&gt;  test1()&#123;


        R&lt;String&gt; r = new R&lt;&gt;();

        r.setCode(1);
        r.setMsg(&quot;success&quot;);

        System.out.println(&quot;test1-----123456&quot;);

        return r;
    &#125;

</code></pre><h1 id="九-springboot整合日志框架"><a class="anchor" href="#九-springboot整合日志框架">#</a> 九、SpringBoot 整合日志框架</h1><p>什么是日志？为什么需要日志？</p><pre><code>sout  输出到控制台的文本信息 就是一种日志（log）
其实日志，不但可以输出到控制台，还可以写入到文件中


日志的作用：
1.在控制台打印，可以快速的查看程序运行到哪里 记录业务逻辑，帮助我们调试
2.日志记录到为文件 可以快速的帮助我们解决生产环境中遇到的问题 bug  所有的异常也会写入日志

3.还可以通过日志 进行统计分析， 统计哪些接口并发量较大 ，哪些接口响应慢  此时可以针对性的优化
            通过 elk  完成日志 分析


		


</code></pre><h2 id="80-日志"><a class="anchor" href="#80-日志">#</a> 8.0 日志</h2><blockquote><p>作用:</p><ol><li>方便调试</li><li>记录运行信息</li><li>记录异常信息</li></ol><p>现在如何实现记录日志的呢</p><ul><li>sout 这个输出语句</li></ul><p>弊端</p><ul><li>无论什么情况，只要只要到此处输出语句一定执行</li><li>只能输出控制台</li><li>信息不完整</li><li><strong>因为 sout 是加锁的，性能非常低</strong></li></ul></blockquote><h2 id="81-日志框架"><a class="anchor" href="#81-日志框架">#</a> 8.1 日志框架</h2><blockquote><p><strong>slf4j</strong></p><p>slf4j 只是一个日志标准，并不是日志系统的具体实现。它用于提供日志操作的接口，提供获取日志对象的方法</p><p><strong>log4j</strong></p><p>apache 实现的一个开源日志组件</p><p><strong>logback</strong></p><p>相对于 logback，有更好的特性， <code>springboot默认使用logback</code></p><p><strong>log4j2</strong></p><p><code>是 log4j的升级版本，拥有更好的性能，支持异步日志</code></p><p>注意：slf4j 属于日志接口，log4j、logback、log4j2 属于日志实现</p><p>springboot 默认使用 logcak 处理日志，但是通过使用通过<strong> slf4j</strong> 调用的</p></blockquote><h2 id="82-日志的等级"><a class="anchor" href="#82-日志的等级">#</a> 8.2 日志的等级</h2><blockquote><p>日志级别按照从低到高为：</p><p>ALL &lt; TRACE &lt; <strong><code>DEBUG &lt; INFO &lt; WARN &lt; ERROR</code> </strong>&lt; FATAL &lt; OFF</p><p>程序会打印高于或等于所设置级别的日志，设置的 ** <code>日志等级越高，打印出来的日志就越少</code> **</p><p>All：最低等级，会输出所有日志记录</p><p>Trace：追踪，就是程序推进一下</p><p>Debug：调试日志</p><p>Info：消息日志，可用于输出应用程序的运行过程</p><p>Warn：输出警告级别的日志</p><p>Error：输出错误信息日志</p><p>Fatal：输出每个严重的错误日志.</p><p>OFF：最高等级的，用于关闭所有日志记录</p></blockquote><p>DEBUG：在开发阶段，帮助我们调试程序，而生产环境不需要记录日志 常见的就是配置 mybatis 的日志级别为 debug</p><p>Info: 都是必要记录的日志</p><h2 id="83springboot使用日志"><a class="anchor" href="#83springboot使用日志">#</a> 8.3springboot 使用日志</h2><h3 id="1配置文件配置日志"><a class="anchor" href="#1配置文件配置日志">#</a> 1. 配置文件配置日志</h3><pre><code>
# 配置当前工程的日志默认级别info
logging.level.root=info

#配置所有service层日志界别debug
logging.level.com.qfedu.service=debug

#显示mybatis 日志 可以查看mybatis 的日志
logging.level.com.qfedu.dao=debug

#配置日志记录的文件名字
logging.file=my.log
</code></pre><h3 id="2使用日志"><a class="anchor" href="#2使用日志">#</a> 2. 使用日志</h3><pre><code>package com.qfedu.controller;


import com.qfedu.entity.AliYunProperties;
import com.qfedu.entity.R;
import com.qfedu.entity.User;
import lombok.extern.slf4j.Slf4j;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;

import java.util.concurrent.ConcurrentHashMap;

/**
 * @Controller 生成bean 加入到容器 ，默认名字（类名首字母小写 testController）
 * @Controller(value = &quot;testBean&quot;)  加入容器指定名字（id）testBean
 *
 *   凡是加入到容器中的Bean 都存在ConcurrentHashMap 中 key 就是bean名字（id）
 *                                                 value 就是容器创建对象的引用地址
 *
 */
@Slf4j // 作用就是在当前类中注入属性Logger log，
        // 相当于Logger log  = LoggerFactory.getLogger(TestController.class);
@Controller(value = &quot;testBean&quot;)
public class TestController &#123;

    // 得到一个日志 对象，可以将日志输出到控制台，并写入到日志文件
//   private Logger log  = LoggerFactory.getLogger(TestController.class);

    @RequestMapping(&quot;/test1&quot;)
    @ResponseBody
    public R&lt;String&gt;  test1()&#123;


        R&lt;String&gt; r = new R&lt;&gt;();

        r.setCode(1);
        r.setMsg(&quot;success&quot;);

//        System.out.println(&quot;test1-----123456&quot;);

        log.debug(&quot;test1-----debug&quot;);
        log.info(&quot;test1-----info&quot;);
        log.warn(&quot;test1-----warn&quot;);

        return r;
    &#125;

    @Autowired
    private AliYunProperties aliYunProperties;

    /**
     * 通过阿里云配置类 读取配置文件的属性
     * @return
     */
    @RequestMapping(&quot;/getAliYunProperties&quot;)
    @ResponseBody
    public R&lt;AliYunProperties&gt; getAliYunProperties()&#123;

          R&lt;AliYunProperties&gt; r = new R&lt;&gt;();

          r.setCode(1);
          r.setMsg(&quot;success&quot;);
          r.setData(aliYunProperties);

          return r;
    &#125;

    /**
     *  @Autowired 从容器中获取同类型的Bean 注入进来
     *      查找类型的逻辑：
     *              1.根据类型从容器中获取bean,找到一个bean，直接注入
     *                                      找到多个bean,无法区分
     *                           2.如果无法区分，就会将属性名作为名字（id）从容器找到对应的 bean ，如果找到 则注入
     *                                      3.如果找不到 ,就要使用注解   @Qualifier(value = &quot;user1&quot;)
     *                                              明示当前属性需要从容器中获取那个bean
     *
     */
    @Autowired
    @Qualifier(value = &quot;user1&quot;) // 将user1 作为名字去容器中找对应的Bean
    private User user;

    @RequestMapping(&quot;/getUser&quot;)
    @ResponseBody
    public User getUser()&#123;

        System.out.println(&quot;获取user&quot;);

        return user;
    &#125;

&#125;

</code></pre><p><img data-src="springboot-01-class.assets/image-20230907095406312.png" alt="image-20230907095406312"></p><p><img data-src="springboot-01-class.assets/image-20230907095600247.png" alt="image-20230907095600247"></p><p><img data-src="springboot-01-class.assets/image-20230907095728968.png" alt="image-20230907095728968"></p><h3 id="3创建日志切面"><a class="anchor" href="#3创建日志切面">#</a> 3. 创建日志切面</h3><p><img data-src="springboot-01-class.assets/image-20230907103748105.png" alt="image-20230907103748105"></p><h4 id="实战-7"><a class="anchor" href="#实战-7">#</a> 实战</h4><p>1. 引入 aop 依赖</p><pre><code>       &lt;!-- 导入aop相关 依赖--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;
        &lt;/dependency&gt;
</code></pre><p>2. 创建切面</p><pre><code>package com.qfedu.aspect;


import lombok.extern.slf4j.Slf4j;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Pointcut;
import org.springframework.stereotype.Component;
import org.springframework.web.context.request.RequestAttributes;
import org.springframework.web.context.request.RequestContextHolder;
import org.springframework.web.context.request.ServletRequestAttributes;
import org.springframework.web.servlet.mvc.condition.RequestConditionHolder;

import javax.servlet.http.HttpServletRequest;
import java.util.Map;

@Slf4j
@Component
@Aspect
public class LogAspect &#123;

    /**
     * 切点表达式
     * public  R com.qfedu.controller.TestController.test1()
     *
     *   * com.qfedu.controller.*.*(..)
     */
    @Pointcut(value = &quot;execution( * com.qfedu.controller.*.*(..))&quot;)
    public void pointCut()&#123;

    &#125;


    /**
     * 环绕通知
     * @param proceedingJoinPoint
     * @return
     */
    @Around(value = &quot;pointCut()&quot;)
    public Object around(ProceedingJoinPoint proceedingJoinPoint) throws Throwable &#123;

        // 获取请求的方法
        String methodName = proceedingJoinPoint.getSignature().getName();

        // 获取到当前请求的 的Request
        // 客户端每次请求对应的url tomcat都会为本次请求创建一个线程，处理对应请求 并相应
        //                       开辟一个线程调用对应的处理器方法、
        //                       RequestContextHolder.getRequestAttributes() 获取当前请求线程中的request
        ServletRequestAttributes requestAttributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();
        HttpServletRequest request = requestAttributes.getRequest();


        // 获取到该请求参数
        Map&lt;String, String[]&gt; parameterMap = request.getParameterMap();

        StringBuilder params = new StringBuilder();
        for (String key : parameterMap.keySet()) &#123;
            params.append(key);
            params.append(&quot;=&quot;);
            params.append(request.getParameter(key));
            params.append(&quot;&amp;&quot;);
        &#125;

        // 获取对应的url
        String url = request.getRequestURL().toString();


        long startTime  = System.currentTimeMillis();
        // 调用目标方法执行
        Object result = proceedingJoinPoint.proceed();


        long cost = System.currentTimeMillis() -startTime;

        log.info(&quot;请求方法：&quot;+methodName +&quot;--请求url:&quot;+url + &quot;--请求参数：&quot;+params+&quot;--耗时:&quot;+cost);

        return result;

    &#125;

&#125;

</code></pre><p>3 测试</p><p><img data-src="springboot-01-class.assets/image-20230907110218557.png" alt="image-20230907110218557"></p><p><img data-src="springboot-01-class.assets/image-20230907110236031.png" alt="image-20230907110236031"></p><p>09:30---10:00 日志框架，日志级别</p><p>0906</p><p>09:40-10:00 配置文件 application.properties application.yaml</p><p><span class="exturl" data-url="aHR0cHM6Ly9yZmxpdmUudmlkZW9jYy5uZXQvOTcwMjM1ZDYxYTE2ODg0MzM1MjUyODM1OTI1L3JlY29yZGZlLTk3MDIzNWQ2MWExNjg4NDMzNTI1MjgzNTkyNS0xNjkzOTY0OTIyMTY0Lm1wNA==">https://rflive.videocc.net/970235d61a16884335252835925/recordfe-970235d61a16884335252835925-1693964922164.mp4</span></p><p>11:07---11:44 多环境配置 ，读取配置文件属性</p><p><span class="exturl" data-url="aHR0cHM6Ly9yZmxpdmUudmlkZW9jYy5uZXQvOTcwMjM1ZDYxYTE2ODg0MzM1MjUyODM1OTI1L3JlY29yZGZlLTk3MDIzNWQ2MWExNjg4NDMzNTI1MjgzNTkyNS0xNjkzOTY5NjEyNjQ3Lm1wNA==">https://rflive.videocc.net/970235d61a16884335252835925/recordfe-970235d61a16884335252835925-1693969612647.mp4</span></p><p>14:20-15:00 @Bean @Qualifier 注解</p><p><span class="exturl" data-url="aHR0cHM6Ly9yZmxpdmUudmlkZW9jYy5uZXQvOTcwMjM1ZDYxYTE2ODg0MzM1MjUyODM1OTI1L3JlY29yZGZlLTk3MDIzNWQ2MWExNjg4NDMzNTI1MjgzNTkyNS0xNjkzOTgyMTMyNDYyLm1wNA==">https://rflive.videocc.net/970235d61a16884335252835925/recordfe-970235d61a16884335252835925-1693982132462.mp4</span></p><p>15:30---15:50 @RestController</p><p><span class="exturl" data-url="aHR0cHM6Ly9yZmxpdmUudmlkZW9jYy5uZXQvOTcwMjM1ZDYxYTE2ODg0MzM1MjUyODM1OTI1L3JlY29yZGZlLTk3MDIzNWQ2MWExNjg4NDMzNTI1MjgzNTkyNS0xNjkzOTg1NjE2MzU5Lm1wNA==">https://rflive.videocc.net/970235d61a16884335252835925/recordfe-970235d61a16884335252835925-1693985616359.mp4</span></p><p>16:04 ----16:46 debug 断点调试</p><p><span class="exturl" data-url="aHR0cHM6Ly9yZmxpdmUudmlkZW9jYy5uZXQvOTcwMjM1ZDYxYTE2ODg0MzM1MjUyODM1OTI1L3JlY29yZGZlLTk3MDIzNWQ2MWExNjg4NDMzNTI1MjgzNTkyNS0xNjkzOTg3NjQyMDMxLm1wNA==">https://rflive.videocc.net/970235d61a16884335252835925/recordfe-970235d61a16884335252835925-1693987642031.mp4</span></p><p>17:10---17:50 文件上传 热更新</p><p><span class="exturl" data-url="aHR0cHM6Ly9yZmxpdmUudmlkZW9jYy5uZXQvOTcwMjM1ZDYxYTE2ODg0MzM1MjUyODM1OTI1L3JlY29yZGZlLTk3MDIzNWQ2MWExNjg4NDMzNTI1MjgzNTkyNS0xNjkzOTkxNzAwMTg1Lm1wNA==">https://rflive.videocc.net/970235d61a16884335252835925/recordfe-970235d61a16884335252835925-1693991700185.mp4</span></p><p>作业：</p><p>1. 练习今日内容</p><p>2. 将上周四 --- 今日所有 springboot mybatis 相关内容 整理总结（写一个 md）</p><p>0905</p><p>09:45--10:10 一级缓存</p><p><span class="exturl" data-url="aHR0cHM6Ly9yZmxpdmUudmlkZW9jYy5uZXQvOTcwMjM1ZDYxYTE2ODg0MzM1MjUyODM1OTI1L3JlY29yZGZlLTk3MDIzNWQ2MWExNjg4NDMzNTI1MjgzNTkyNS0xNjkzODc4MzQ0Mzc5Lm1wNA==">https://rflive.videocc.net/970235d61a16884335252835925/recordfe-970235d61a16884335252835925-1693878344379.mp4</span></p><p>10：48--11: 30 mybatis 二级缓存</p><p><span class="exturl" data-url="aHR0cHM6Ly9yZmxpdmUudmlkZW9jYy5uZXQvOTcwMjM1ZDYxYTE2ODg0MzM1MjUyODM1OTI1L3JlY29yZGZlLTk3MDIzNWQ2MWExNjg4NDMzNTI1MjgzNTkyNS0xNjkzODg0NDY5ODU4Lm1wNA==">https://rflive.videocc.net/970235d61a16884335252835925/recordfe-970235d61a16884335252835925-1693884469858.mp4</span></p><p>14:36---15：00 分页</p><p><span class="exturl" data-url="aHR0cHM6Ly9yZmxpdmUudmlkZW9jYy5uZXQvOTcwMjM1ZDYxYTE2ODg0MzM1MjUyODM1OTI1L3JlY29yZGZlLTk3MDIzNWQ2MWExNjg4NDMzNTI1MjgzNTkyNS0xNjkzODk1NzU4MDI3Lm1wNA==">https://rflive.videocc.net/970235d61a16884335252835925/recordfe-970235d61a16884335252835925-1693895758027.mp4</span></p><p>15:41--- 16:59 登录示例 ajax</p><p><span class="exturl" data-url="aHR0cHM6Ly9yZmxpdmUudmlkZW9jYy5uZXQvOTcwMjM1ZDYxYTE2ODg0MzM1MjUyODM1OTI1L3JlY29yZGZlLTk3MDIzNWQ2MWExNjg4NDMzNTI1MjgzNTkyNS0xNjkzODk5NzI0MzY0Lm1wNA==">https://rflive.videocc.net/970235d61a16884335252835925/recordfe-970235d61a16884335252835925-1693899724364.mp4</span></p><p>17：30-17：50 ajax get post put 请求</p><p><span class="exturl" data-url="aHR0cHM6Ly9yZmxpdmUudmlkZW9jYy5uZXQvOTcwMjM1ZDYxYTE2ODg0MzM1MjUyODM1OTI1L3JlY29yZGZlLTk3MDIzNWQ2MWExNjg4NDMzNTI1MjgzNTkyNS0xNjkzOTA2OTIxNzI5Lm1wNA==">https://rflive.videocc.net/970235d61a16884335252835925/recordfe-970235d61a16884335252835925-1693906921729.mp4</span></p><p>作业：</p><p>1. 将今日内容敲两边</p><p>2. 完成 一个学生对应 多个角色的一对多</p><p>3. 完成依赖两张表的 一对一 一对多</p><pre><code>用户 ---&gt; 订单 (1 VS N)     一个用户有多个订单
订单  ---&gt; 用户 (1 VS 1)    一个订单只会属于一个人
</code></pre><p>4. 复习 js jquery css html</p><p>今日作业：</p><p>1. 将今日内容敲两边</p><p>2. 完成 一个学生对应 多个角色的一对多</p><p>3. 完成依赖两张表的 一对一 一对多</p><pre><code>用户 ---&gt; 订单 (1 VS N)     一个用户有多个订单
订单  ---&gt; 用户 (1 VS 1)    一个订单只会属于一个人
</code></pre><pre><code>tb_user表

​```sql
CREATE TABLE `tb_user` (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '用户编号',
  `username` varchar(10) DEFAULT NULL COMMENT '用户名',
  `password` varchar(10) DEFAULT NULL COMMENT '密码',
  `phone` varchar(11) DEFAULT NULL COMMENT '手机号',
  `create_time` date DEFAULT NULL COMMENT '注册时间',
  `money` double(10,2) DEFAULT NULL COMMENT '账户余额'
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=34 DEFAULT CHARSET=utf8;
​```

tb_order表

​```sql
CREATE TABLE `tb_order` (
  `oid` int(11) NOT NULL AUTO_INCREMENT COMMENT '订单编号',
  `order_time` datetime DEFAULT NULL COMMENT '订单时间',
  `order_desc` varchar(255) DEFAULT NULL COMMENT '订单详情',
  `uid` int(11) DEFAULT NULL COMMENT '关联用户id',
  PRIMARY KEY (`oid`)
) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8;

INSERT INTO `tb_order` VALUES (1, '2022-11-17 15:06:29', '笔记本电脑', 1);
INSERT INTO `tb_order` VALUES (2, '2022-12-16 11:00:41', 'Cherry键盘', 1);
INSERT INTO `tb_order` VALUES (3, '2022-12-16 11:01:23', 'Logi鼠标', 2);
​```


</code></pre><p>4. 将今日所有内容 使用 controller service 展示到浏览器中</p><p>0904</p><p>10:40---11:05 一对一 一对多概念</p><p><span class="exturl" data-url="aHR0cHM6Ly9yZmxpdmUudmlkZW9jYy5uZXQvOTcwMjM1ZDYxYTE2ODg0MzM1MjUyODM1OTI1L3JlY29yZGZlLTk3MDIzNWQ2MWExNjg4NDMzNTI1MjgzNTkyNS0xNjkzNzk1MTQzNzkyLm1wNA==">https://rflive.videocc.net/970235d61a16884335252835925/recordfe-970235d61a16884335252835925-1693795143792.mp4</span></p><p>11:13-- 11:37 一对一</p><p><span class="exturl" data-url="aHR0cHM6Ly9yZmxpdmUudmlkZW9jYy5uZXQvOTcwMjM1ZDYxYTE2ODg0MzM1MjUyODM1OTI1L3JlY29yZGZlLTk3MDIzNWQ2MWExNjg4NDMzNTI1MjgzNTkyNS0xNjkzNzk3MTg2NjkzLm1wNA==">https://rflive.videocc.net/970235d61a16884335252835925/recordfe-970235d61a16884335252835925-1693797186693.mp4</span></p><p>14:18--- 14:44 一对多</p><p><span class="exturl" data-url="aHR0cHM6Ly9yZmxpdmUudmlkZW9jYy5uZXQvOTcwMjM1ZDYxYTE2ODg0MzM1MjUyODM1OTI1L3JlY29yZGZlLTk3MDIzNWQ2MWExNjg4NDMzNTI1MjgzNTkyNS0xNjkzODA4MzI0MTM3Lm1wNA==">https://rflive.videocc.net/970235d61a16884335252835925/recordfe-970235d61a16884335252835925-1693808324137.mp4</span></p><p>14:55-15:22 多对多</p><p><span class="exturl" data-url="aHR0cHM6Ly9yZmxpdmUudmlkZW9jYy5uZXQvOTcwMjM1ZDYxYTE2ODg0MzM1MjUyODM1OTI1L3JlY29yZGZlLTk3MDIzNWQ2MWExNjg4NDMzNTI1MjgzNTkyNS0xNjkzODEwNzIwMDMzLm1wNA==">https://rflive.videocc.net/970235d61a16884335252835925/recordfe-970235d61a16884335252835925-1693810720033.mp4</span></p><p>16:00 ---16:45 动态 sql</p><p><span class="exturl" data-url="aHR0cHM6Ly9yZmxpdmUudmlkZW9jYy5uZXQvOTcwMjM1ZDYxYTE2ODg0MzM1MjUyODM1OTI1L3JlY29yZGZlLTk3MDIzNWQ2MWExNjg4NDMzNTI1MjgzNTkyNS0xNjkzODE0Mzk5MTk2Lm1wNA==">https://rflive.videocc.net/970235d61a16884335252835925/recordfe-970235d61a16884335252835925-1693814399196.mp4</span></p><p>周末作业：</p><p>使用 springboot + mybatis 重写上周的作业 **（新建一个工程）**</p><p>1. 登录例子</p><p>2. 展示所有 admin</p><ol start="3"><li>完成 admin 使用 form 表单更新</li><li>查询所有的学生表（仿照 admin 列表）</li></ol><p>5. 以下查询使用表格展示</p><pre><code>- 1.查询所有年龄大于18 并且 性别为M 的学生列表   使用 BaseDao实现

? 占位符 只能替换 对应列的值，不能替换列名，关键字

SELECT id,name,age,sex,height,birthday ,createtime FROM student_tb
    where  age &gt;? and sex = ?;
</code></pre><pre><code>- 2.查询所有成绩并包含学生信息   

1.SELECT * FROM score_tb 
		LEFT JOIN student_tb ON score_tb.student_id= student_tb.id ;


2.使用BaseDao  实现，返回 List&lt;Map&gt; 


</code></pre><p>本周学的内容</p><p>springboot 替代了 Servlet</p><p>mybattis 替代了 BaseDao dbutils （jdbc ）</p><p>0902</p><p>10:00--111 mybatis 增删改查</p><p><span class="exturl" data-url="aHR0cHM6Ly9yZmxpdmUudmlkZW9jYy5uZXQvOTcwMjM1ZDYxYTE2ODg0MzM1MjUyODM1OTI1L3JlY29yZGZlLTk3MDIzNWQ2MWExNjg4NDMzNTI1MjgzNTkyNS0xNjkzNjIxNzgwNTc0Lm1wNA==">https://rflive.videocc.net/970235d61a16884335252835925/recordfe-970235d61a16884335252835925-1693621780574.mp4</span></p><p>14:30--15:20 mybatis 别名 映射结果集</p><p><span class="exturl" data-url="aHR0cHM6Ly9yZmxpdmUudmlkZW9jYy5uZXQvOTcwMjM1ZDYxYTE2ODg0MzM1MjUyODM1OTI1L3JlY29yZGZlLTk3MDIzNWQ2MWExNjg4NDMzNTI1MjgzNTkyNS0xNjkzNjM3MTIzNTc1Lm1wNA==">https://rflive.videocc.net/970235d61a16884335252835925/recordfe-970235d61a16884335252835925-1693637123575.mp4</span></p><p>0901</p><p>09:39----10:10 session 界面跳转，回话</p><p><span class="exturl" data-url="aHR0cHM6Ly9yZmxpdmUudmlkZW9jYy5uZXQvOTcwMjM1ZDYxYTE2ODg0MzM1MjUyODM1OTI1L3JlY29yZGZlLTk3MDIzNWQ2MWExNjg4NDMzNTI1MjgzNTkyNS0xNjkzNTMyMzU5MDI0Lm1wNA==">https://rflive.videocc.net/970235d61a16884335252835925/recordfe-970235d61a16884335252835925-1693532359024.mp4</span></p><p>10:47----11:17 json 数据格式</p><p><span class="exturl" data-url="aHR0cHM6Ly9yZmxpdmUudmlkZW9jYy5uZXQvOTcwMjM1ZDYxYTE2ODg0MzM1MjUyODM1OTI1L3JlY29yZGZlLTk3MDIzNWQ2MWExNjg4NDMzNTI1MjgzNTkyNS0xNjkzNTM2NDI2NjA1Lm1wNA==">https://rflive.videocc.net/970235d61a16884335252835925/recordfe-970235d61a16884335252835925-1693536426605.mp4</span></p><p>11:25---11:55 响应 json 数据 @ResponseBody，接收 json 数据 @RequesBody</p><p><span class="exturl" data-url="aHR0cHM6Ly9yZmxpdmUudmlkZW9jYy5uZXQvOTcwMjM1ZDYxYTE2ODg0MzM1MjUyODM1OTI1L3JlY29yZGZlLTk3MDIzNWQ2MWExNjg4NDMzNTI1MjgzNTkyNS0xNjkzNTM4NjY4MTI4Lm1wNA==">https://rflive.videocc.net/970235d61a16884335252835925/recordfe-970235d61a16884335252835925-1693538668128.mp4</span></p><p>14:31---14:40 拦截器</p><p><span class="exturl" data-url="aHR0cHM6Ly9yZmxpdmUudmlkZW9jYy5uZXQvOTcwMjM1ZDYxYTE2ODg0MzM1MjUyODM1OTI1L3JlY29yZGZlLTk3MDIzNWQ2MWExNjg4NDMzNTI1MjgzNTkyNS0xNjkzNTQ5OTEwNTIzLm1wNA==">https://rflive.videocc.net/970235d61a16884335252835925/recordfe-970235d61a16884335252835925-1693549910523.mp4</span></p><p>15-30-15:52 全局异常处理</p><p><span class="exturl" data-url="aHR0cHM6Ly9yZmxpdmUudmlkZW9jYy5uZXQvOTcwMjM1ZDYxYTE2ODg0MzM1MjUyODM1OTI1L3JlY29yZGZlLTk3MDIzNWQ2MWExNjg4NDMzNTI1MjgzNTkyNS0xNjkzNTUzNjAyMDI3Lm1wNA==">https://rflive.videocc.net/970235d61a16884335252835925/recordfe-970235d61a16884335252835925-1693553602027.mp4</span></p><p>16:00--17:00 mybatis 入门 例子</p><p><span class="exturl" data-url="aHR0cHM6Ly9yZmxpdmUudmlkZW9jYy5uZXQvOTcwMjM1ZDYxYTE2ODg0MzM1MjUyODM1OTI1L3JlY29yZGZlLTk3MDIzNWQ2MWExNjg4NDMzNTI1MjgzNTkyNS0xNjkzNTU1NTc5MDc4Lm1wNA==">https://rflive.videocc.net/970235d61a16884335252835925/recordfe-970235d61a16884335252835925-1693555579078.mp4</span></p><p>作业</p><p>1. 将原有 demo 敲 2 遍</p><p>2. 写一个切面 切向 dao 层</p><p>3. 将周末 servlet + service + dao 改造为 springbot 写法 （20 分钟）</p><p>0831</p><p>10:37----aop 概念</p><p><span class="exturl" data-url="aHR0cHM6Ly9yZmxpdmUudmlkZW9jYy5uZXQvOTcwMjM1ZDYxYTE2ODg0MzM1MjUyODM1OTI1L3JlY29yZGZlLTk3MDIzNWQ2MWExNjg4NDMzNTI1MjgzNTkyNS0xNjkzNDQ5NDM5NDQ1Lm1wNA==">https://rflive.videocc.net/970235d61a16884335252835925/recordfe-970235d61a16884335252835925-1693449439445.mp4</span></p><p>11:17---11:45 aop 实例</p><p><span class="exturl" data-url="aHR0cHM6Ly9yZmxpdmUudmlkZW9jYy5uZXQvOTcwMjM1ZDYxYTE2ODg0MzM1MjUyODM1OTI1L3JlY29yZGZlLTk3MDIzNWQ2MWExNjg4NDMzNTI1MjgzNTkyNS0xNjkzNDUxNzkyMTYxLm1wNA==">https://rflive.videocc.net/970235d61a16884335252835925/recordfe-970235d61a16884335252835925-1693451792161.mp4</span></p><p>14:26--- 15：00 Aop 的五种通知</p><p><span class="exturl" data-url="aHR0cHM6Ly9yZmxpdmUudmlkZW9jYy5uZXQvOTcwMjM1ZDYxYTE2ODg0MzM1MjUyODM1OTI1L3JlY29yZGZlLTk3MDIzNWQ2MWExNjg4NDMzNTI1MjgzNTkyNS0xNjkzNDYzMjA4ODc1Lm1wNA==">https://rflive.videocc.net/970235d61a16884335252835925/recordfe-970235d61a16884335252835925-1693463208875.mp4</span></p><p>15:48--- 16：10 @PostMapping @GetMapping 请求方式</p><p><span class="exturl" data-url="aHR0cHM6Ly9yZmxpdmUudmlkZW9jYy5uZXQvOTcwMjM1ZDYxYTE2ODg0MzM1MjUyODM1OTI1L3JlY29yZGZlLTk3MDIzNWQ2MWExNjg4NDMzNTI1MjgzNTkyNS0xNjkzNDY4MDgwNTAwLm1wNA==">https://rflive.videocc.net/970235d61a16884335252835925/recordfe-970235d61a16884335252835925-1693468080500.mp4</span></p><p>16：30---16：50 接收基本类型参数， 使用对象处理基本类型参数</p><p><span class="exturl" data-url="aHR0cHM6Ly9yZmxpdmUudmlkZW9jYy5uZXQvOTcwMjM1ZDYxYTE2ODg0MzM1MjUyODM1OTI1L3JlY29yZGZlLTk3MDIzNWQ2MWExNjg4NDMzNTI1MjgzNTkyNS0xNjkzNDcwOTE3NDkxLm1wNA==">https://rflive.videocc.net/970235d61a16884335252835925/recordfe-970235d61a16884335252835925-1693470917491.mp4</span></p><p>17：32 接收基本类型参数， 使用 map 接收， 路径参数</p><p><span class="exturl" data-url="aHR0cHM6Ly9yZmxpdmUudmlkZW9jYy5uZXQvOTcwMjM1ZDYxYTE2ODg0MzM1MjUyODM1OTI1L3JlY29yZGZlLTk3MDIzNWQ2MWExNjg4NDMzNTI1MjgzNTkyNS0xNjkzNDc0MzM2NTc0Lm1wNA==">https://rflive.videocc.net/970235d61a16884335252835925/recordfe-970235d61a16884335252835925-1693474336574.mp4</span></p><p>0830</p><p>09:40---10:35 本地分支合并冲突</p><p><span class="exturl" data-url="aHR0cHM6Ly9yZmxpdmUudmlkZW9jYy5uZXQvOTcwMjM1ZDYxYTE2ODg0MzM1MjUyODM1OTI1L3JlY29yZGZlLTk3MDIzNWQ2MWExNjg4NDMzNTI1MjgzNTkyNS0xNjkzMzU5OTMzMTM1Lm1wNA==">https://rflive.videocc.net/970235d61a16884335252835925/recordfe-970235d61a16884335252835925-1693359933135.mp4</span></p><p>10：40---10:56 远程分支合并本地分支冲突</p><p><span class="exturl" data-url="aHR0cHM6Ly9yZmxpdmUudmlkZW9jYy5uZXQvOTcwMjM1ZDYxYTE2ODg0MzM1MjUyODM1OTI1L3JlY29yZGZlLTk3MDIzNWQ2MWExNjg4NDMzNTI1MjgzNTkyNS0xNjkzMzYzMzU2ODg0Lm1wNA==">https://rflive.videocc.net/970235d61a16884335252835925/recordfe-970235d61a16884335252835925-1693363356884.mp4</span></p><p>11:10--12:00 提交远程代码冲突 代码协作</p><p><span class="exturl" data-url="aHR0cHM6Ly9yZmxpdmUudmlkZW9jYy5uZXQvOTcwMjM1ZDYxYTE2ODg0MzM1MjUyODM1OTI1L3JlY29yZGZlLTk3MDIzNWQ2MWExNjg4NDMzNTI1MjgzNTkyNS0xNjkzMzY0OTU4NTg3Lm1wNA==">https://rflive.videocc.net/970235d61a16884335252835925/recordfe-970235d61a16884335252835925-1693364958587.mp4</span></p><p>14:20--15:00 idea git 工具</p><p><span class="exturl" data-url="aHR0cHM6Ly9yZmxpdmUudmlkZW9jYy5uZXQvOTcwMjM1ZDYxYTE2ODg0MzM1MjUyODM1OTI1L3JlY29yZGZlLTk3MDIzNWQ2MWExNjg4NDMzNTI1MjgzNTkyNS0xNjkzMzc3MzU4Mjc5Lm1wNA==">https://rflive.videocc.net/970235d61a16884335252835925/recordfe-970235d61a16884335252835925-1693377358279.mp4</span></p><p>15:44-----16:20 springboot 简介 demo</p><p><span class="exturl" data-url="aHR0cHM6Ly9yZmxpdmUudmlkZW9jYy5uZXQvOTcwMjM1ZDYxYTE2ODg0MzM1MjUyODM1OTI1L3JlY29yZGZlLTk3MDIzNWQ2MWExNjg4NDMzNTI1MjgzNTkyNS0xNjkzMzgxNDM2MDA2Lm1wNA==">https://rflive.videocc.net/970235d61a16884335252835925/recordfe-970235d61a16884335252835925-1693381436006.mp4</span></p><p>16:36-----17:00 ioc demo</p><p><span class="exturl" data-url="aHR0cHM6Ly9yZmxpdmUudmlkZW9jYy5uZXQvOTcwMjM1ZDYxYTE2ODg0MzM1MjUyODM1OTI1L3JlY29yZGZlLTk3MDIzNWQ2MWExNjg4NDMzNTI1MjgzNTkyNS0xNjkzMzgxNDM2MDA2LTIwMjMwODMwMTYzNjU0Lm1wNA==">https://rflive.videocc.net/970235d61a16884335252835925/recordfe-970235d61a16884335252835925-1693381436006-20230830163654.mp4</span></p><div class="tags"><a href="/tags/springboot/" rel="tag"><i class="ic i-tag"></i>springboot</a></div></div><footer><div class="meta"><span class="icon"><i class="ic i-eye"></i></span><span>此文章已被阅读次数:</span><span class="waline-pageview-count" id="twikoo_visitors" data-path="2023/10/22/springframe/spring/springboot/springboot-01-class/">正在加载...</span><span class="item"><span class="icon"><i class="ic i-calendar-check"></i></span><span class="text">更新于</span><time title="修改时间：2023-10-30 10:39:15" itemprop="dateModified" datetime="2023-10-30T10:39:15+08:00">2023-10-30</time></span><script type="module" data-pjax="data-pjax">import { pageviewCount } from 'https://unpkg.com/@waline/client/dist/pageview.mjs';

const path = document.getElementById("twikoo_visitors").getAttribute("data-path");
pageviewCount({
    serverURL: 'waline-biya.vercel.app',
    path: path,
});</script></div><div class="reward"><button><i class="ic i-heartbeat"></i>赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/assets/wechatpay.png" alt="biya 微信支付"><p>微信支付</p></div><div><img data-src="/assets/alipay.png" alt="biya 支付宝"><p>支付宝</p></div><div><img data-src="/assets/paypal.png" alt="biya 贝宝"><p>贝宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者：</strong>biya<i class="ic i-at"><em>@</em></i>夢のない賢魚です</li><li class="link"><strong>本文链接：</strong><a href="https://sbysg.github.io/2023/10/22/springframe/spring/springboot/springboot-01-class/" title="springboot">https://sbysg.github.io/2023/10/22/springframe/spring/springboot/springboot-01-class/</a></li><li class="license"><strong>版权声明：</strong>本站所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2023/10/22/backend/java/base/%E7%88%AA%E5%93%87%E5%A7%A8%E5%A7%A8/" rel="prev" itemprop="url" data-background-image="https:&#x2F;&#x2F;tva2.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1gipeybxm1pj20zk0m8niv.jpg" title="爪哇基础"><span class="type">上一篇</span><span class="category"><i class="ic i-flag"></i>Java基础</span><h3>爪哇基础</h3></a></div><div class="item right"><a href="/2023/10/22/springframe/spring/mybatis/mybatis-plus/3-02Mybatis-plus/" rel="next" itemprop="url" data-background-image="https:&#x2F;&#x2F;tva2.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1gicit31ffoj20zk0m8naf.jpg" title="mybatis-plus"><span class="type">下一篇</span><span class="category"><i class="ic i-flag"></i>Mybatis</span><h3>mybatis-plus</h3></a></div></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1spring-boot-%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">1.Spring Boot 概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E4%BB%80%E4%B9%88%E6%98%AFspringboot"><span class="toc-number">1.0.1.</span> <span class="toc-text">1. 什么是 springboot？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2spring-boot-%E4%BC%98%E7%82%B9"><span class="toc-number">1.0.2.</span> <span class="toc-text">2.Spring Boot 优点？</span></a></li></ol></li></ol><li class="toc-item toc-level-1"><a class="toc-link" href="#2%E4%BD%BF%E7%94%A8springboot%E5%88%9B%E5%BB%BA%E5%B7%A5%E7%A8%8B"><span class="toc-number">2.</span> <span class="toc-text">2. 使用 springboot 创建工程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-spring"><span class="toc-number">3.</span> <span class="toc-text">3、Spring</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#31-iocdi%E9%87%8D%E7%82%B9"><span class="toc-number">3.1.</span> <span class="toc-text">3.1 IOC+DI [重点]</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#310-%E5%BC%95%E8%A8%80"><span class="toc-number">3.1.1.</span> <span class="toc-text">3.1.0 引言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#311-%E4%BB%8B%E7%BB%8D"><span class="toc-number">3.1.2.</span> <span class="toc-text">3.1.1 介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E6%88%98%E9%87%8D%E5%86%99%E7%99%BB%E5%BD%95%E5%B0%8F%E4%BE%8B%E5%AD%90"><span class="toc-number">3.1.2.1.</span> <span class="toc-text">实战（重写登录小例子）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#313-%E6%BC%94%E7%A4%BA2"><span class="toc-number">3.1.3.</span> <span class="toc-text">3.1.3 演示 2</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#32-aop"><span class="toc-number">3.2.</span> <span class="toc-text">3.2 AOP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#321-%E4%BB%8B%E7%BB%8D"><span class="toc-number">3.2.1.</span> <span class="toc-text">3.2.1 介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#322-aop%E6%9C%AF%E8%AF%AD"><span class="toc-number">3.2.2.</span> <span class="toc-text">3.2.2 AOP 术语</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">3.2.3.</span> <span class="toc-text"></span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B"><span class="toc-number">3.2.3.1.</span> <span class="toc-text">实例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#324-aop%E5%BC%80%E5%8F%91%E6%AD%A5%E9%AA%A4"><span class="toc-number">3.2.4.</span> <span class="toc-text">3.2.4 Aop 开发步骤</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#51-mvc"><span class="toc-number">3.3.</span> <span class="toc-text">5.1 MVC</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#52-%E8%AF%B7%E6%B1%82%E5%93%8D%E5%BA%94%E9%87%8D%E7%82%B9"><span class="toc-number">3.4.</span> <span class="toc-text">5.2 请求 &amp; 响应【重点】</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#53-%E5%8F%82%E6%95%B0%E7%BB%91%E5%AE%9A-%E9%87%8D%E7%82%B9"><span class="toc-number">3.5.</span> <span class="toc-text">5.3 参数绑定 【重点】</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#531-%E7%AE%80%E5%8D%95%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0%E7%BB%91%E5%AE%9A%E9%87%8D%E7%82%B9"><span class="toc-number">3.5.1.</span> <span class="toc-text">5.3.1 简单类型参数绑定 [重点]</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#532-%E5%AF%B9%E8%B1%A1%E9%87%8D%E7%82%B9"><span class="toc-number">3.5.2.</span> <span class="toc-text">5.3.2 对象 [重点]</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#535-map%E9%9B%86%E5%90%88"><span class="toc-number">3.5.3.</span> <span class="toc-text">5.3.5 Map 集合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#536-%E8%B7%AF%E5%BE%84%E5%8F%82%E6%95%B0pathvariable"><span class="toc-number">3.5.4.</span> <span class="toc-text">5.3.6 路径参数 @PathVariable</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#54-%E9%A1%B5%E9%9D%A2%E8%B7%B3%E8%BD%AC%E7%86%9F%E6%82%89"><span class="toc-number">3.6.</span> <span class="toc-text">5.4 页面跳转 [熟悉]</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#55-%E4%BC%9A%E8%AF%9D%E9%87%8D%E7%82%B9"><span class="toc-number">3.7.</span> <span class="toc-text">5.5 会话 [重点]</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#57-json%E5%A4%84%E7%90%86%E9%87%8D%E7%82%B9"><span class="toc-number">3.8.</span> <span class="toc-text">5.7 json 处理【重点】</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E5%99%A8%E6%96%B9%E6%B3%95%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">3.8.1.</span> <span class="toc-text">处理器方法返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E5%99%A8%E6%96%B9%E6%B3%95%E6%8E%A5%E6%94%B6%E5%8F%82%E6%95%B0"><span class="toc-number">3.8.2.</span> <span class="toc-text">处理器方法接收参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#json"><span class="toc-number">3.8.3.</span> <span class="toc-text">json</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#json%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.8.3.0.1.</span> <span class="toc-text">json 对象</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E5%99%A8%E6%96%B9%E6%B3%95%E8%BF%94%E5%9B%9E%E5%AF%B9%E8%B1%A1%E8%BD%ACjson-responsebody%E6%A0%87%E8%AE%B0%E5%9C%A8%E5%A4%84%E7%90%86%E5%99%A8%E6%96%B9%E6%B3%95%E4%B8%8A"><span class="toc-number">3.8.4.</span> <span class="toc-text">处理器方法返回对象转 json @ResponseBody，标记在处理器方法上</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E5%99%A8%E6%96%B9%E6%B3%95%E6%8E%A5%E6%94%B6json-%E8%BD%ACjava-%E5%AF%B9%E8%B1%A1-%E4%BD%BF%E7%94%A8requesbody%E6%A0%87%E8%AE%B0%E5%9C%A8%E5%AF%B9%E8%B1%A1%E5%8F%82%E6%95%B0%E4%B8%8A"><span class="toc-number">3.8.5.</span> <span class="toc-text">处理器方法接收 json 转 java 对象 使用 @RequesBody，标记在对象参数上</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#56-%E6%8B%A6%E6%88%AA%E5%99%A8"><span class="toc-number">3.9.</span> <span class="toc-text">5.6 拦截器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E6%88%98"><span class="toc-number">3.9.0.1.</span> <span class="toc-text">实战</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#59-%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">3.10.</span> <span class="toc-text">5.9 全局异常处理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E6%88%98-2"><span class="toc-number">3.10.0.1.</span> <span class="toc-text">实战</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AD-mybatis"><span class="toc-number">4.</span> <span class="toc-text">六、Mybatis</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#61-%E4%B9%8B%E5%89%8D%E7%9A%84jdbc%E7%9A%84%E4%BD%BF%E7%94%A8%E7%BC%BA%E7%82%B9"><span class="toc-number">4.1.</span> <span class="toc-text">6.1 之前的 JDBC 的使用缺点？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#62-mybatis%E7%9A%84%E4%BB%8B%E7%BB%8D"><span class="toc-number">4.2.</span> <span class="toc-text">6.2 Mybatis 的介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-mybatis"><span class="toc-number">4.2.1.</span> <span class="toc-text">什么是 MyBatis？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#63%E5%AE%9E%E6%88%98"><span class="toc-number">4.3.</span> <span class="toc-text">6.3 实战</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E5%88%9B%E5%BB%BA%E5%B7%A5%E7%A8%8B"><span class="toc-number">4.3.0.1.</span> <span class="toc-text">1. 创建工程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E5%AF%BC%E5%85%A5%E4%BE%9D%E8%B5%96"><span class="toc-number">4.3.0.2.</span> <span class="toc-text">2. 导入依赖</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3lombok"><span class="toc-number">4.3.0.3.</span> <span class="toc-text">3.lombok</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E5%88%9B%E5%BB%BAdao%E6%8E%A5%E5%8F%A3"><span class="toc-number">4.3.0.4.</span> <span class="toc-text">4. 创建 Dao 接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6%E5%9C%A8resources-%E5%88%9B%E5%BB%BA%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-applicationproperties"><span class="toc-number">4.3.0.5.</span> <span class="toc-text">6. 在 resources 创建配置文件 application.properties</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E5%88%9B%E5%BB%BA%E5%90%AF%E5%8A%A8%E7%B1%BB"><span class="toc-number">4.3.0.6.</span> <span class="toc-text">5 创建启动类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6springboot%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95"><span class="toc-number">4.3.0.7.</span> <span class="toc-text">6.springboot 单元测试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7%E4%BD%BF%E7%94%A8studentcontroller%E8%B0%83%E7%94%A8studentservice-studentdao"><span class="toc-number">4.3.0.8.</span> <span class="toc-text">7. 使用 StudentController 调用 StudentService StudentDao</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#64%E5%9F%BA%E4%BA%8Emybatis%E5%AE%9E%E7%8E%B0curd"><span class="toc-number">4.4.</span> <span class="toc-text">6.4. 基于 mybatis 实现 curd</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B9%E6%8D%AEid%E6%9F%A5%E8%AF%A2%E5%AD%A6%E7%94%9F"><span class="toc-number">4.4.0.1.</span> <span class="toc-text">根据 id 查询学生</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A2%9E%E5%8A%A0%E5%AD%A6%E7%94%9F"><span class="toc-number">4.4.0.2.</span> <span class="toc-text">增加学生</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E5%AD%A6%E7%94%9F"><span class="toc-number">4.4.0.3.</span> <span class="toc-text">修改学生</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B9%E6%8D%AEid-%E5%88%A0%E9%99%A4%E5%AD%A6%E7%94%9F"><span class="toc-number">4.4.0.4.</span> <span class="toc-text">根据 id 删除学生</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E5%8F%82%E6%95%B0%E6%9F%A5%E8%AF%A2"><span class="toc-number">4.4.0.5.</span> <span class="toc-text">多参数查询</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#mybatis34%E5%8F%8A%E4%BB%A5%E5%89%8D%E7%89%88%E6%9C%AC%E5%AD%98%E5%9C%A8%E5%A4%9A%E5%8F%82%E6%95%B0%E6%89%BE%E4%B8%8D%E5%88%B0%E9%97%AE%E9%A2%98"><span class="toc-number">4.4.0.5.1.</span> <span class="toc-text">mybatis3.4 及以前版本存在多参数找不到问题</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%A4%9A%E5%8F%82%E6%95%B0%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95"><span class="toc-number">4.4.0.5.1.1.</span> <span class="toc-text">多参数解决方法</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E6%98%AFmybatis-34%E4%BB%A5%E5%90%8E%E7%9A%84%E7%89%88%E6%9C%AC%E5%8C%85%E6%8B%AC35%E7%89%88%E6%9C%AC%E4%B8%8D%E5%AD%98%E5%9C%A8%E5%A4%9A%E5%8F%82%E6%95%B0%E6%89%BE%E4%B8%8D%E5%88%B0%E9%97%AE%E9%A2%98"><span class="toc-number">4.4.0.5.2.</span> <span class="toc-text">如果是 mybatis 3.4 以后的版本（包括 3.5 版本）不存在多参数找不到问题！！！！！！！！！</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#typealiases%E5%88%AB%E5%90%8D"><span class="toc-number">4.4.0.6.</span> <span class="toc-text">typeAliases 别名</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E7%9A%84%E7%BB%93%E6%9E%9C%E9%9B%86%E4%B8%80%E8%88%AC%E9%83%BD%E8%A6%81%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BD%93%E7%B1%BB%E6%8E%A5%E6%94%B6%E5%85%B6%E5%AE%9E%E4%B9%9F%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8map%E6%8E%A5%E6%94%B6"><span class="toc-number">4.4.1.</span> <span class="toc-text">查询的结果集，一般都要使用实体类接收，其实也可以使用 Map 接收</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#65-orm%E6%98%A0%E5%B0%84"><span class="toc-number">4.5.</span> <span class="toc-text">6.5 ORM 映射</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#651-mybatis%E8%87%AA%E5%8A%A8orm%E5%A4%B1%E6%95%88"><span class="toc-number">4.5.1.</span> <span class="toc-text">6.5.1 MyBatis 自动 ORM 失效</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%80%E5%90%AF%E9%A9%BC%E5%B3%B0%E6%98%A0%E5%B0%84"><span class="toc-number">4.5.1.1.</span> <span class="toc-text">开启驼峰映射</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%97%E7%9A%84%E5%88%AB%E5%90%8D"><span class="toc-number">4.5.1.2.</span> <span class="toc-text">列的别名</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%9C%E6%98%A0%E5%B0%84resultmap-%E6%9F%A5%E8%AF%A2%E7%BB%93%E6%9E%9C%E7%9A%84%E5%B0%81%E8%A3%85%E8%A7%84%E5%88%99"><span class="toc-number">4.5.2.</span> <span class="toc-text">结果映射（ResultMap - 查询结果的封装规则）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#66mybatis%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2"><span class="toc-number">4.6.</span> <span class="toc-text">6.6mybatis 多表查询</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2%E5%88%86%E4%B8%BA%E4%B8%A4%E7%A7%8D"><span class="toc-number">4.6.0.1.</span> <span class="toc-text">多表查询分为两种</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E5%AF%B9%E4%B8%80%E5%AE%9E%E6%88%98"><span class="toc-number">4.6.1.</span> <span class="toc-text">一对一实战</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E5%AF%B9%E5%A4%9A%E5%AE%9E%E6%88%98"><span class="toc-number">4.6.2.</span> <span class="toc-text">一对多实战</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E5%AF%B9%E5%A4%9A"><span class="toc-number">4.6.3.</span> <span class="toc-text">多对多</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#67mybatis-%E7%9A%84%E5%8A%A8%E6%80%81-sql-%E8%AF%AD%E5%8F%A5"><span class="toc-number">4.7.</span> <span class="toc-text">6.7Mybatis 的动态 SQL 语句</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#671%E5%8A%A8%E6%80%81sql%E8%AF%AD%E5%8F%A5if"><span class="toc-number">4.7.1.</span> <span class="toc-text">6.7.1 动态 sql 语句 &lt;if&gt;</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E6%88%98-3"><span class="toc-number">4.7.1.1.</span> <span class="toc-text">实战</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#672%E5%8A%A8%E6%80%81sql%E8%AF%AD%E5%8F%A5-where-where"><span class="toc-number">4.7.2.</span> <span class="toc-text">6.7.2 动态 sql 语句 &lt;where&gt; &lt;&#x2F;where&gt;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#673%E5%8A%A8%E6%80%81%E8%AF%AD%E5%8F%A5foreach-foreach"><span class="toc-number">4.7.3.</span> <span class="toc-text">6.7.3 动态语句 &lt;foreach&gt; &lt;&#x2F;foreach&gt;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#674%E5%8A%A8%E6%80%81%E8%AF%AD%E5%8F%A5sql-sql"><span class="toc-number">4.7.4.</span> <span class="toc-text">6.7.4 动态语句 &lt;sql&gt; &lt;&#x2F;sql&gt;</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#68%E4%BA%8B%E5%8A%A1"><span class="toc-number">4.8.</span> <span class="toc-text">6.8 事务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#68-%E7%BC%93%E5%AD%98cache%E9%9D%A2%E8%AF%95"><span class="toc-number">4.9.</span> <span class="toc-text">6.8 缓存 (cache)【面试】</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#681-%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98"><span class="toc-number">4.9.1.</span> <span class="toc-text">6.8.1 一级缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E6%88%98-4"><span class="toc-number">4.9.1.1.</span> <span class="toc-text">实战</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#682-%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98"><span class="toc-number">4.9.2.</span> <span class="toc-text">6.8.2 二级缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E6%88%98-5"><span class="toc-number">4.9.2.1.</span> <span class="toc-text">实战</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#683mybatis-%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98-%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">4.9.3.</span> <span class="toc-text">6.8.3mybatis 一级缓存 二级缓存优先级</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#69-%E6%B3%A8%E8%A7%A3%E6%96%B9%E5%BC%8F%E6%95%B4%E5%90%88mybatis%E4%BA%86%E8%A7%A3"><span class="toc-number">4.10.</span> <span class="toc-text">6.9 注解方式整合 Mybatis [了解]</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#691-mapper%E6%8E%A5%E5%8F%A3"><span class="toc-number">4.10.1.</span> <span class="toc-text">6.9.1 Mapper 接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#692-%E6%B7%BB%E5%8A%A0mybatis%E6%B3%A8%E8%A7%A3"><span class="toc-number">4.10.2.</span> <span class="toc-text">6.9.2 添加 Mybatis 注解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#610pagehelper%E4%BD%BF%E7%94%A8"><span class="toc-number">4.11.</span> <span class="toc-text">6.10pagehelper 使用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%83-jquery-ajax"><span class="toc-number">5.</span> <span class="toc-text">七、jQuery AJAX</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#71-jquery-ajax%E7%AE%80%E4%BB%8B"><span class="toc-number">5.1.</span> <span class="toc-text">7.1 jQuery AJAX 简介</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E6%88%98-6"><span class="toc-number">5.1.0.1.</span> <span class="toc-text">实战</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#72-get%E5%92%8Cpost%E6%96%B9%E6%B3%95"><span class="toc-number">5.2.</span> <span class="toc-text">7.2 get 和 post 方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AB-springboot%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE%E9%87%8D%E7%82%B9"><span class="toc-number">6.</span> <span class="toc-text">八、SpringBoot 常用配置【 重点 】</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#81-springboot%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F"><span class="toc-number">6.1.</span> <span class="toc-text">8.1 SpringBoot 的配置文件格式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F"><span class="toc-number">6.1.0.1.</span> <span class="toc-text">注意：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#82-%E5%A4%9A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE"><span class="toc-number">6.2.</span> <span class="toc-text">8.2 多环境配置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E9%BB%98%E8%AE%A4%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%BF%80%E6%B4%BB%E5%A4%9A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE"><span class="toc-number">6.2.1.</span> <span class="toc-text">在默认配置文件激活多环境配置</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#83-%E8%8E%B7%E5%8F%96%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%BF%A1%E6%81%AF"><span class="toc-number">6.3.</span> <span class="toc-text">8.3 获取配置文件信息</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#84%E5%85%B6%E4%BB%96%E6%B3%A8%E8%A7%A3"><span class="toc-number">6.4.</span> <span class="toc-text">8.4 其他注解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%9F%E6%88%90bean%E6%B3%A8%E8%A7%A3"><span class="toc-number">6.4.0.1.</span> <span class="toc-text">生成 Bean 注解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%AF%86%E5%88%AB%E5%A4%9A%E4%B8%AA%E5%90%8C%E7%B1%BB%E5%9E%8B%E7%9A%84bean-qualifier"><span class="toc-number">6.4.0.2.</span> <span class="toc-text">如何识别多个同类型的 Bean @Qualifier</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#restcontroller"><span class="toc-number">6.4.0.3.</span> <span class="toc-text">@RestController</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#85debug"><span class="toc-number">6.5.</span> <span class="toc-text">8.5debug</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E6%8E%A7%E5%88%B6%E5%8F%B0%E6%8A%A5%E9%94%99%E5%88%86%E6%9E%90"><span class="toc-number">6.5.1.</span> <span class="toc-text">通过控制台报错分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95-%E5%AE%8C%E6%88%90debug"><span class="toc-number">6.5.2.</span> <span class="toc-text">使用断点调试 完成 debug</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E5%89%8D%E7%AB%AFdebug"><span class="toc-number">6.5.2.1.</span> <span class="toc-text">1. 前端 debug</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E5%90%8E%E7%AB%AF-idea-debug"><span class="toc-number">6.5.2.2.</span> <span class="toc-text">2. 后端 idea debug</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E5%A6%82%E6%9E%9C-%E5%89%8D%E5%90%8Edebug-%E6%97%A0%E6%B3%95%E6%98%8E%E7%A1%AE%E9%97%AE%E9%A2%98"><span class="toc-number">6.5.2.3.</span> <span class="toc-text">3. 如果 前后 debug 无法明确问题 ？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E4%BB%A5%E4%B8%8A%E5%8A%9E%E6%B3%95%E9%83%BD%E4%B8%8D%E8%A1%8C"><span class="toc-number">6.5.2.4.</span> <span class="toc-text">4. 以上办法都不行？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#86-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%BC%9A%E7%94%A8%E6%97%A2%E5%8F%AF"><span class="toc-number">6.6.</span> <span class="toc-text">8.6 文件上传（会用既可）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#87-%E7%83%AD%E5%8A%A0%E8%BD%BD%E4%BA%86%E8%A7%A3"><span class="toc-number">6.7.</span> <span class="toc-text">8.7 热加载（了解）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E5%AF%BC%E5%85%A5%E4%BE%9D%E8%B5%96"><span class="toc-number">6.7.1.</span> <span class="toc-text">1. 导入依赖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E9%85%8D%E7%BD%AEsettings%E9%85%8D%E7%BD%AE"><span class="toc-number">6.7.2.</span> <span class="toc-text">2. 配置 settings 配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E4%BD%BF%E7%94%A8-%E4%BB%A5-debug-%E6%A8%A1%E5%BC%8F%E5%90%AF%E5%8A%A8-%E4%BF%AE%E6%94%B9%E4%BB%A3%E7%A0%81%E8%A7%A6%E5%8F%91-%E7%83%AD%E6%9B%B4%E6%96%B0"><span class="toc-number">6.7.3.</span> <span class="toc-text">3. 使用 以 debug 模式启动， 修改代码触发 热更新</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B9%9D-springboot%E6%95%B4%E5%90%88%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6"><span class="toc-number">7.</span> <span class="toc-text">九、SpringBoot 整合日志框架</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#80-%E6%97%A5%E5%BF%97"><span class="toc-number">7.1.</span> <span class="toc-text">8.0 日志</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#81-%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6"><span class="toc-number">7.2.</span> <span class="toc-text">8.1 日志框架</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#82-%E6%97%A5%E5%BF%97%E7%9A%84%E7%AD%89%E7%BA%A7"><span class="toc-number">7.3.</span> <span class="toc-text">8.2 日志的等级</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#83springboot%E4%BD%BF%E7%94%A8%E6%97%A5%E5%BF%97"><span class="toc-number">7.4.</span> <span class="toc-text">8.3springboot 使用日志</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E9%85%8D%E7%BD%AE%E6%97%A5%E5%BF%97"><span class="toc-number">7.4.1.</span> <span class="toc-text">1. 配置文件配置日志</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E4%BD%BF%E7%94%A8%E6%97%A5%E5%BF%97"><span class="toc-number">7.4.2.</span> <span class="toc-text">2. 使用日志</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E5%88%9B%E5%BB%BA%E6%97%A5%E5%BF%97%E5%88%87%E9%9D%A2"><span class="toc-number">7.4.3.</span> <span class="toc-text">3. 创建日志切面</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E6%88%98-7"><span class="toc-number">7.4.3.1.</span> <span class="toc-text">实战</span></a></li></ol></li></ol></li></ol></li></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/2023/10/22/springframe/spring/springcloud/SpringCloud/" rel="bookmark" title="springcloud">springcloud</a></li><li><a href="/2023/10/22/springframe/spring/mybatis/mybatis/MyBatis/" rel="bookmark" title="mybatis">mybatis</a></li><li><a href="/2023/10/22/springframe/spring/mybatis/mybatis-plus/3-02Mybatis-plus/" rel="bookmark" title="mybatis-plus">mybatis-plus</a></li><li class="active"><a href="/2023/10/22/springframe/spring/springboot/springboot-01-class/" rel="bookmark" title="springboot">springboot</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="biya" data-src="/assets/avatar.jpg"><p class="name" itemprop="name">biya</p><div class="description" itemprop="description">摸鱼之道，就在其中</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">13</span><span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">12</span><span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">12</span><span class="name">标签</span></a></div></nav><div class="social"><a href="https://github.com/sbysg" class="item github" rel="noopener" title="https:&#x2F;&#x2F;github.com&#x2F;sbysg" target="_blank"><i class="ic i-github"></i></a><a href="https://www.zhihu.com/people/xin-han-91-91" class="item zhihu" rel="noopener" title="https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;xin-han-91-91" target="_blank"><i class="ic i-zhihu"></i></a><a href="https://music.163.com/#/user/home?id=1657896798" class="item music" rel="noopener" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;1657896798" target="_blank"><i class="ic i-cloud-music"></i></a><a href="https://weibo.com/u/6667154460" class="item weibo" rel="noopener" title="https:&#x2F;&#x2F;weibo.com&#x2F;u&#x2F;6667154460" target="_blank"><i class="ic i-weibo"></i></a><a href="https://about.me/biyahan" class="item about" rel="noopener" title="https:&#x2F;&#x2F;about.me&#x2F;biyahan" target="_blank"><i class="ic i-address-card"></i></a><a href="https://t.me/kill_biya" class="item telegram" rel="noopener" title="https:&#x2F;&#x2F;t.me&#x2F;kill_biya" target="_blank"><i class="ic i-paper-plane"></i></a><a href="https://stackoverflow.com/users/22783860/kill-biya/" class="item stackoverflow" rel="noopener" title="https:&#x2F;&#x2F;stackoverflow.com&#x2F;users&#x2F;22783860&#x2F;kill-biya&#x2F;" target="_blank"><i class="ic i-stack-overflow"></i></a></div><div class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-user"></i>关于</a><ul class="submenu"><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于本站</a></li><li class="item"><a href="/admiration/" rel="section"><i class="ic i-coffee"></i>赞赏博主</a></li></ul></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>友達</a></li></div></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2023/10/22/springframe/spring/mybatis/mybatis-plus/3-02Mybatis-plus/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2023/10/22/backend/java/base/%E7%88%AA%E5%93%87%E5%A7%A8%E5%A7%A8/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/linux/" title="分类于Linux">Linux</a><i class="ic i-angle-right"></i><a href="/categories/linux/docker/" title="分类于Docker">Docker</a></div><span><a href="/2023/10/22/linux/docker/rabbitMQ/RabbitMQ/">rabbitMQ</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/linux/" title="分类于Linux">Linux</a><i class="ic i-angle-right"></i><a href="/categories/linux/docker/" title="分类于Docker">Docker</a></div><span><a href="/2023/10/22/linux/docker/docker/Docker/">docker</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/database/" title="分类于数据库">数据库</a></div><span><a href="/2023/10/22/database/sql/mysql/Java%E9%9D%A2%E8%AF%95%E9%A2%98-06-Mysql%E7%AF%87/">mysql</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/backend/" title="分类于Java后端">Java后端</a><i class="ic i-angle-right"></i><a href="/categories/backend/java/" title="分类于Java">Java</a><i class="ic i-angle-right"></i><a href="/categories/backend/java/base/" title="分类于Java基础">Java基础</a></div><span><a href="/2023/10/22/backend/java/base/first/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/">hi biya</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/springframe/" title="分类于Java框架">Java框架</a><i class="ic i-angle-right"></i><a href="/categories/springframe/spring/" title="分类于Spring全家桶">Spring全家桶</a></div><span><a href="/2023/10/22/springframe/spring/springcloud/SpringCloud/">springcloud</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/database/" title="分类于数据库">数据库</a></div><span><a href="/2023/10/22/database/no-sql/redis/Java%E9%9D%A2%E8%AF%95%E9%A2%98-07-Redis/">redis</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/springframe/" title="分类于Java框架">Java框架</a><i class="ic i-angle-right"></i><a href="/categories/springframe/spring/" title="分类于Spring全家桶">Spring全家桶</a><i class="ic i-angle-right"></i><a href="/categories/springframe/spring/mybatis/" title="分类于Mybatis">Mybatis</a></div><span><a href="/2023/10/22/springframe/spring/mybatis/mybatis/MyBatis/">mybatis</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/backend/" title="分类于Java后端">Java后端</a><i class="ic i-angle-right"></i><a href="/categories/backend/java/" title="分类于Java">Java</a><i class="ic i-angle-right"></i><a href="/categories/backend/java/base/" title="分类于Java基础">Java基础</a></div><span><a href="/2023/10/22/backend/java/base/hello/hello-world/">Hello World</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/frontend/" title="分类于前端">前端</a><i class="ic i-angle-right"></i><a href="/categories/frontend/vue/" title="分类于Vue">Vue</a></div><span><a href="/2023/10/22/frontend/vue/vue3/Vue3%E9%80%9F%E6%88%90/">vue3</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/third-apis/" title="分类于第三方api">第三方api</a></div><span><a href="/2023/10/22/third-apis/minio/%E4%B8%8A%E9%97%A8%E5%85%BB%E8%80%81-%E6%B3%A8%E5%86%8C%E5%8A%9F%E8%83%BD-%E7%9F%AD%E4%BF%A1/">sms</a></span></li></ul></div><div class="rpost pjax"><h2>最新评论</h2><ul class="leancloud-recent-comment" id="new-comment"></ul></div></div><div class="status"><div class="copyright"><span itemprop="copyrightYear">2023</span><span class="with-love"><i class="ic i-sakura rotate"></i></span><span class="author" itemprop="copyrightHolder">biya @ Ya Hallo</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i></span><span title="站点总字数">444k 字</span><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="ic i-coffee"></i></span><span title="站点阅读时长">6:44</span></div><div class="powered-by">基于 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & Theme.<a href="https://github.com/theme-shoka-x/hexo-theme-shokaX/" rel="noopener" target="_blank">ShokaX</a></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2023/10/22/springframe/spring/springboot/springboot-01-class/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,chart:!1,copy_tex:!1,katex:!1,mermaid:!1,audio:void 0,fancybox:!0,nocopy:!1,outime:!0,template:'<div class="note warning"><p><span class="label warning">文章时效性提示</span><br>这是一篇发布于 {{publish}} 天前，最后一次更新在 {{updated}} 天前的文章，部分信息可能已经发生改变，请注意甄别。</p></div>',quiz:{choice:"单选题",multiple:"多选题",true_false:"判断题",essay:"问答题",gap_fill:"填空题",mistake:"错题备注"},ignores:[e=>e.includes("#"),e=>new RegExp(LOCAL.path+"$").test(e),[]]}</script><script src="https://polyfill.io/v3/polyfill.min.js?features=default,fetch"></script><script src="https://lf9-cdn-tos.bytecdntp.com/cdn/expire-6-M/pace/1.0.2/pace.min.js"></script><script src="https://lf9-cdn-tos.bytecdntp.com/cdn/expire-6-M/algoliasearch/4.12.1/algoliasearch-lite.umd.min.js"></script><script src="https://lf9-cdn-tos.bytecdntp.com/cdn/expire-6-M/instantsearch.js/4.39.0/instantsearch.production.min.js"></script><script src="https://lf9-cdn-tos.bytecdntp.com/cdn/expire-6-M/quicklink/2.2.0/quicklink.umd.min.js"></script><script src="https://lf9-cdn-tos.bytecdntp.com/cdn/expire-6-M/??jquery/3.5.1/jquery.min.js,fancybox/3.5.7/jquery.fancybox.min.js,justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js" async></script><script src="https://lf9-cdn-tos.bytecdntp.com/cdn/expire-6-M/KaTeX/0.15.2/contrib/copy-tex.min.js" async></script><script src="/js/app.js?v=0.3.6"></script><script data-pjax="data-pjax">var _hmt=_hmt||[];!function(){var e=document.createElement("script"),t=(e.src="https://hm.baidu.com/hm.js?true",e.async=!0,document.getElementsByTagName("script")[0]);t.parentNode.insertBefore(e,t)}()</script><script>!function(t,e,n,c,r,a){t[n]=t[n]||function(){(t[n].q=t[n].q||[]).push(arguments)},(r=e.createElement(c)).async=1,r.src="https://www.clarity.ms/tag/true",(a=e.getElementsByTagName(c)[0]).parentNode.insertBefore(r,a)}(window,document,"clarity","script")</script><script async src="https://www.googletagmanager.com/gtag/js?id=true"></script><script data-pjax="data-pjax">function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","true")</script></body></html><!-- rebuild by hexo-renderer-multi-next-markdown-it -->